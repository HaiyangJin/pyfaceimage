{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pyfaceimage","text":"<p>Pyfaceimage is a Python package that processes (face) images.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Feature </li> <li>Feature 2</li> <li>Feature 3</li> </ul> <p>Get started by reading the installation guide!</p>"},{"location":"installation/","title":"Installation","text":"<p>You can install <code>Pyfaceimage</code> using pip:</p> <pre><code>pip install git+https://github.com/HaiyangJin/pyfaceimage\n</code></pre>"},{"location":"readim/","title":"Read images","text":"<pre><code>import pyfaceimage as fim\nimport os\n</code></pre> <pre><code># Your custom path to images\nPATH_to_image = os.path.join(\"..\", \"..\", \"test\")\n</code></pre> <p><code>fim.image()</code> can read one image and load the relevant information.</p> <pre><code>im = fim.image(os.path.join(PATH_to_image, \"im\", \"color.png\"),\n               read = True)\n</code></pre> <p>To check the image, you may use the following code:</p> <pre><code>im.pil\n\n# or\n# im.show()\n</code></pre> <p></p> <p>In most cases, we probably would like to load more images at a time:</p> <pre><code>im_dict = fim.dir(os.path.join(PATH_to_image, \"multi\"))\n</code></pre> <pre>\n<code>Found 4 files in ../../test/multi...\n</code>\n</pre> <p>The code above read all images in the folder at once and creates a dictionary of <code>im.image()</code> instances. Keys are the image names and values are the <code>im.image()</code> instances.</p> <pre><code>im_dict\n</code></pre> <pre>\n<code>{'L4': &lt;pyfaceimage.im.image at 0x12848f6e0&gt;,\n 'L1': &lt;pyfaceimage.im.image at 0x12f645a90&gt;,\n 'L2': &lt;pyfaceimage.im.image at 0x128b0b590&gt;,\n 'L3': &lt;pyfaceimage.im.image at 0x12f6c1520&gt;}</code>\n</pre> <p>You may extract the value and check the image content:</p> <pre><code>im_dict['L1'].pil\n</code></pre> <p>Alternatively, you may randomly sample one image and check its content:</p> <pre><code># random sample\nfim.sample(im_dict).pil\n</code></pre>"},{"location":"readim/#read-one-image","title":"Read one image","text":""},{"location":"readim/#read-multiple-images","title":"Read multiple images","text":""},{"location":"api/api/","title":"all","text":"<p>Auto-generate API documentation using <code>mkdocstrings</code>. Add the following content:</p>"},{"location":"api/api/#api-reference","title":"API Reference","text":"<p>Tools for dealing with images in dictionary.</p>"},{"location":"api/api/#pyfaceimage.image","title":"<code>image</code>","text":"<p>A class to process a single image.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>path and image filename.</p> required <code>read</code> <code>bool</code> <p>Whether to read the image via PIL, by default False.</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>filename</code> <code>str</code> <p>path and image filename.</p> <code>fname</code> <code>str</code> <p>the image filename.</p> <code>fnonly</code> <code>str</code> <p>the image filename without extension.</p> <code>ext</code> <code>str</code> <p>the image extension.</p> <code>dirname</code> <code>str</code> <p>the image directory.</p> <code>isfile</code> <code>bool</code> <p>whether the image file exists.</p> <code>group</code> <code>str</code> <p>the group name of the image.</p> <code>gpath</code> <code>str</code> <p>the global path of the image.</p> <code>pil</code> <code>Image</code> <p>the PIL image.</p> <code>mat</code> <code>array</code> <p>the image matrix.</p> <code>dims</code> <code>tuple</code> <p>the image dimensions.</p> <code>ndim</code> <code>int</code> <p>the number of dimensions.</p> <code>h</code> <code>int</code> <p>the height of the image.</p> <code>w</code> <code>int</code> <p>the width of the image.</p> <code>nchan</code> <code>int</code> <p>the number of channels.</p> <code>rgbmat</code> <code>array</code> <p>the RGB matrix.</p> <code>amat</code> <code>array</code> <p>the alpha matrix.</p> <p>Attributes:</p> Name Type Description <code>filename</code> <code>str</code> <p>Return the image filename.</p> <code>fname</code> <code>str</code> <p>Return the image filename.</p> <code>fnonly</code> <code>str</code> <p>Return the image filename without extension.</p> <code>ext</code> <code>str</code> <p>Return the image extension.</p> <code>dirname</code> <code>str</code> <p>Return the image directory.</p> <code>isfile</code> <code>bool</code> <p>Return whether the image file exists.</p> <code>dims</code> <code>tuple</code> <p>Return the image dimensions.</p> <code>ndim</code> <code>int</code> <p>Return the number of dimensions.</p> <code>h</code> <code>int</code> <p>Return the height of the image.</p> <code>w</code> <code>int</code> <p>Return the width of the image.</p> <code>nchan</code> <code>int</code> <p>Return the number of channels.</p> <code>maxlum</code> <code>float</code> <p>Return the maximum luminance of the image.</p> <code>minlum</code> <code>float</code> <p>Return the minimum luminance of the image.</p> <code>meanlum</code> <code>float</code> <p>Return the mean luminance of the image.</p> <code>rms</code> <code>float</code> <p>Return the RMS of the image.</p> <code>luminfo</code> <code>None</code> <p>Print the luminance information of the image.</p> <p>Methods:</p> Name Description <code>update_fninfor</code> <p>Update the image filename related information.</p> <code>updateext</code> <p>Update the filename information.</p> <code>read</code> <p>Read the image via PIL.</p> <code>imshow</code> <p>Show the image matrix.</p> <code>show</code> <p>Show the image PIL.</p> <code>imsave</code> <p>Save the image mat.</p> <code>save</code> <p>Save the image PIL.</p> <code>deepcopy</code> <p>Make a deep copy of the instance.</p> <code>remat</code> <p>Re-assign value to .mat and update related information.</p> <code>torgba</code> <p>Convert the image to RGBA.</p> <code>grayscale</code> <p>Convert the image to gray-scale.</p> <code>addbg</code> <p>Add background to the RGBA image.</p> <code>rotate</code> <p>Rotate the image unclockwise.</p> <code>stdmat</code> <p>Standardize the image matrix.</p> <code>adjust_pil</code> <p>Adjust the luminance and contrast of the image with <code>pillow</code>.</p> <code>cropoval</code> <p>Crop the image with an oval shape.</p> <code>croprect</code> <p>Crop the image with a rectangle box.</p> <code>resize</code> <p>Resize the image.</p> <code>pad</code> <p>Add padding to the image/stimuli.</p> <code>mkboxscr</code> <p>Make box scrambled stimuli.</p> <code>mkphasescr</code> <p>Make phase scrambled stimuli.</p> <code>filter</code> <p>Apply spatial frequency filter to the image.</p> <code>_logit</code> <p>Convert the ratio to log odds.</p> <code>_sigmoid</code> <p>Convert the log odds to the ratio.</p> <code>_repil</code> <p>Update the image PIL.</p> <code>_updatefrommat</code> <p>Update information from the image matrix.</p> <code>_newfilename</code> <p>Update the filename with newfname and newfolder.</p> <code>_setgroup</code> <p>Set the group name of the image.</p> <code>_setgpath</code> <p>Set the global path of the image.</p> <code>_filter</code> <p>Apply spatial frequency filter to the image.</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>class image:\n    \"\"\"A class to process a single image.\n\n    Parameters\n    ----------\n    filename : str\n        path and image filename.  \n    read : bool, optional\n        Whether to read the image via PIL, by default False.\n\n    Attributes\n    ----------\n    filename : str\n        path and image filename.\n    fname : str\n        the image filename.\n    fnonly : str\n        the image filename without extension.\n    ext : str\n        the image extension.\n    dirname : str\n        the image directory.\n    isfile : bool\n        whether the image file exists.\n    group : str\n        the group name of the image.\n    gpath : str\n        the global path of the image.\n    pil : PIL.Image\n        the PIL image.\n    mat : np.array\n        the image matrix.\n    dims : tuple\n        the image dimensions.\n    ndim : int\n        the number of dimensions.\n    h : int\n        the height of the image.\n    w : int\n        the width of the image.\n    nchan : int\n        the number of channels.\n    rgbmat : np.array\n        the RGB matrix.\n    amat : np.array\n        the alpha matrix.\n\n    Attributes\n    ----------\n    filename : str\n        Return the image filename.\n    fname : str\n        Return the image filename.\n    fnonly : str\n        Return the image filename without extension.\n    ext : str\n        Return the image extension.\n    dirname : str\n        Return the image directory.\n    isfile : bool\n        Return whether the image file exists.\n    dims : tuple\n        Return the image dimensions.\n    ndim : int\n        Return the number of dimensions.\n    h : int\n        Return the height of the image.\n    w : int\n        Return the width of the image.\n    nchan : int\n        Return the number of channels.\n    maxlum : float\n        Return the maximum luminance of the image.\n    minlum : float\n        Return the minimum luminance of the image.\n    meanlum : float\n        Return the mean luminance of the image.\n    rms : float\n        Return the RMS of the image.\n    luminfo : None\n        Print the luminance information of the image.\n\n    Methods\n    -------\n    update_fninfor()\n        Update the image filename related information.\n    updateext(ext)\n        Update the filename information.\n    read()\n        Read the image via PIL.\n    imshow()\n        Show the image matrix.\n    show()\n        Show the image PIL.\n    imsave(newfname='', newfolder='', addfn=True, **kwargs)\n        Save the image mat.\n    save(newfname='', newfolder='', addfn=True, **kwargs)\n        Save the image PIL.\n    deepcopy()\n        Make a deep copy of the instance.\n    remat(mat)\n        Re-assign value to .mat and update related information.\n    torgba()\n        Convert the image to RGBA.\n    grayscale()\n        Convert the image to gray-scale.\n    addbg(bgcolor=(255,255,255))\n        Add background to the RGBA image.\n    rotate(angle=180)\n        Rotate the image unclockwise.\n    stdmat(clip=2, lum=[0,255], range = None)\n        Standardize the image matrix.\n    adjust_pil(lum=None, rms=None, mask=None)\n        Adjust the luminance and contrast of the image with `pillow`.\n    cropoval(radius=(100,128), bgcolor=None)\n        Crop the image with an oval shape.\n    croprect(box=None)\n        Crop the image with a rectangle box.\n    resize(**kwargs)\n        Resize the image.\n    pad(**kwargs)\n        Add padding to the image/stimuli.\n    mkboxscr(**kwargs)\n        Make box scrambled stimuli.\n    mkphasescr(**kwargs)\n        Make phase scrambled stimuli.\n    filter(**kwargs)\n        Apply spatial frequency filter to the image.\n    _logit(ratio=None, correction=0.00001)\n        Convert the ratio to log odds.\n    _sigmoid(logodds, correction=0.00001)\n        Convert the log odds to the ratio.\n    _repil(pil)\n        Update the image PIL.\n    _updatefrommat()\n        Update information from the image matrix.\n    _newfilename(newfname='', newfolder='', addfn=True)\n        Update the filename with newfname and newfolder.\n    _setgroup(gname='')\n        Set the group name of the image.\n    _setgpath(gpath='')\n        Set the global path of the image.\n    _filter(**kwargs)\n        Apply spatial frequency filter to the image.\n    \"\"\"\n\n    def __init__(self, filename, read=False):\n        \"\"\"Create an image instance.\n\n        Parameters\n        ----------\n        filename : str\n            path and image filename.  \n        read : bool, optional\n            Whether to read the image via PIL, by default False.\n\n        Raises\n        ------\n        AssertionError\n            If the file does not exist.\n        \"\"\"\n        # make sure the file exists \n        self._filename = filename\n        self.update_fninfo(filename, newfn=False) \n        self._setgroup() \n        self._setgpath()\n        if read: self.read()\n\n    @property\n    def filename(self):\n        \"\"\"Return the image filename.\n\n        Returns\n        -------\n        str\n            the image filename.\n        \"\"\"\n        return self._filename\n\n    def update_fninfo(self, filename, newfn=True):\n        \"\"\"Set the image filename.\n\n        Parameters\n        ----------\n        filename : str\n            path and image filename.\n        newfn : bool, optional\n            whether `filename` is a new file name, by default True. So it will not check whether the file exists.\n        \"\"\"\n        if newfn &amp; os.path.isfile(filename):\n            # throw warning if filename is newly created and exists\n            warnings.warn(f\"The file named '{filename}' already exists...\")\n        elif not newfn:\n            # throw error if filename is not new and does not exist\n            assert os.path.isfile(filename) | (not bool(filename)), f'Cannot find {filename}...'\n\n        self._filename = filename\n        self._fname = os.path.basename(filename)\n        self._fnonly = \".\".join(os.path.splitext(self._fname)[0:-1])\n        self._ext = os.path.splitext(self._fname)[-1]\n        self._dirname = os.path.dirname(filename)\n        self._isfile = os.path.isfile(filename)\n\n    @property\n    def fname(self):\n        \"\"\"Return the image filename.\n\n        Returns\n        -------\n        str\n            the image filename.\n        \"\"\"\n        return self._fname\n\n    @property\n    def fnonly(self):\n        \"\"\"Return the image filename without extension.\n\n        Returns\n        -------\n        str\n            the image filename without extension.\n        \"\"\"\n        return self._fnonly\n\n    @property\n    def ext(self):\n        \"\"\"Return the image extension.\n\n        Returns\n        -------\n        str\n            the image extension.\n        \"\"\"\n        return self._ext\n\n    @property\n    def dirname(self):\n        \"\"\"Return the image directory.\n\n        Returns\n        -------\n        str\n            the image directory.\n        \"\"\"\n        return self._dirname\n\n    @property\n    def isfile(self):\n        \"\"\"Return whether the image file exists.\n\n        Returns\n        -------\n        bool\n            whether the image file exists.\n        \"\"\"\n        return self._isfile\n\n    def updateext(self, ext):\n        \"\"\"Update the filename information.\n\n        Parameters\n        ----------\n        ext : str\n            the new extension.\n        \"\"\"\n        if ext[0] != '.':\n            ext = '.'+ext\n        self.update_fninfo(self._dirname + os.sep + self._fnonly + ext)\n\n    def read(self):\n        \"\"\"Read the image via PIL.\n        \"\"\"\n        self._repil(Image.open(self.filename)) # PIL.Image.open() \n        # potential useful functions\n        # .filename .format, .mode, .split()\n\n    def _setgroup(self, gname=''):\n        \"\"\"Set the group name of the image.\n\n        Parameters\n        ----------\n        gname : str, optional\n            the group name, by default the upper directory name of the image.\n        \"\"\"\n        # update group information\n        if not bool(gname):\n            gname = os.path.split(os.path.dirname(self.filename))[1]\n        self.group = gname\n\n    def _setgpath(self, gpath=''):\n        \"\"\"Set the global path of the image (among other images). [This atribute matters only when mutiltple images are processed together. more see dir().]\n\n        Parameters\n        ----------\n        gpath : str, optional\n            global path, i.e. path in dir(), by default ''\n        \"\"\"\n        self.gpath = gpath\n\n    def imshow(self):\n        \"\"\"Show the image matrix.\n        \"\"\"\n        # for debugging purpose (check the mat)\n        # it seems that .show() is more useful\n        Image.fromarray(self.mat).show()\n\n    def show(self):\n        \"\"\"Show the image PIL.\n        \"\"\"\n        # for debugging purpose (check the PIL)\n        self.pil.show()\n\n    def imsave(self, newfname='', newfolder='', addfn=True, **kwargs):\n        \"\"\"Save the image mat.\n\n        Parameters\n        ----------\n        newfname : str, optional\n            strings to be added before the extension, by default ''\n        newfolder : str, optional\n            folder name to replace the global directory or the last directory level, by default ''\n        addfn : bool, optional\n            whether to add the newfname to the the original fname (instead of replacing it), by default True\n        kwargs : dict, optional\n            keyword arguments for matplotlib.pyplot.imsave(), by default {}\n        \"\"\"\n        # update the filename\n        self._newfilename(newfname, newfolder, addfn=addfn)\n\n        # make dir(s)\n        if not os.path.isdir(os.path.dirname(self.filename)):\n            os.makedirs(os.path.dirname(self.filename))\n        if self._nchan==1:\n            outmat = self.mat[:,:,0]\n        else:\n            outmat = self.mat\n\n        # use matplotlib.pyplot.imsave() to save .mat\n        mpimg.imsave(self.filename,outmat,**kwargs)\n        # mpimg.imsave(self.filename,outmat.copy(order='C'),**kwargs)\n        self._isfile = os.path.isfile(self.filename)\n\n\n    def save(self, newfname='', newfolder='', addfn=True, **kwargs):\n        \"\"\"Save the image PIL.\n\n        Parameters\n        ----------\n        newfname : str, optional\n            strings to be added before the extension, by default ''\n        newfolder : str, optional\n            folder name to replace the global directory or the last directory level, by default ''\n        addfn : bool, optional\n            whether to add the newfname to the the original fname (instead of replacing it), by default True\n        kwargs : dict, optional\n            keyword arguments for matplotlib.pyplot.imsave(), by default {}\n        \"\"\"\n        # update the filename\n        self._newfilename(newfname, newfolder, addfn=addfn)\n\n        # make dir(s)\n        if not os.path.isdir(os.path.dirname(self.filename)):\n            os.makedirs(os.path.dirname(self.filename))\n\n        # use PIL.Image.save() to save .pil    \n        self.pil.save(self.filename, format=None, **kwargs)\n        self._isfile = os.path.isfile(self.filename)\n\n\n    def touch(self, touchfolder=''):\n        \"\"\"Touch a new empty file.\n\n        Parameters\n        ----------\n        touchfolder : str, optional\n            folder name to replace the global directory or the last directory level, by default ''\n        \"\"\"\n        # update the directory\n        self._newfilename(newfolder=touchfolder)\n\n        if self.isfile:\n            # throw warnings if file exists\n            warnings.warn(\"The file named '%s' already exists...\" % self.filename)\n        else:\n            # make dir if needed\n            if not os.path.isdir(self._dirname):\n                os.makedirs(self._dirname)\n            # touch the file\n            Path(self.filename).touch()\n\n\n    def _newfilename(self, newfname='', newfolder='', addfn=True):\n        \"\"\"Update the filename with newfname and newfolder.\n\n        Parameters\n        ----------\n        newfname : str, optional\n            strings to be added before the extension, by default ''\n        newfolder : str, optional\n            folder name to replace the global directory or the last directory level, by default ''\n        addfn : bool, optional\n            whether to add the newfname to the the original fname (instead of replacing it), by default True\n        \"\"\"\n        # apply newfname to the old one\n        oldfname = os.path.splitext(self._fname)[0] if addfn else ''\n        fname = oldfname+newfname+os.path.splitext(self._fname)[1]\n\n        # replace the path folder with newfolder\n        if bool(self.gpath):\n            # rename the global path and filename\n            foldername = newfolder if bool(newfolder) else os.path.basename(self.gpath) # apply newfolder to the old one if needed\n            group = self.group if self.group != 'path' else ''\n            self.update_fninfo(os.path.join(os.path.dirname(self.gpath), foldername, group, fname))\n            self.gpath = os.path.join(os.path.dirname(self.gpath), foldername)\n        else:\n            foldername = newfolder if bool(newfolder) else os.path.basename(self._dirname) # apply newfolder to the old one if needed\n            self.update_fninfo(os.path.join(os.path.dirname(self.filename), foldername, fname))\n\n    def deepcopy(self):\n        \"\"\"make a deep copy of the instance\n        \"\"\"\n        return copy.deepcopy(self)\n\n\n    def remat(self, mat, mode=None):\n        \"\"\"Re-assign value to .mat and update related information.\n\n        Parameters\n        ----------\n        mat : np.array\n            the new image matrix.\n        \"\"\"\n        # re-assign value to .mat and update related information\n        self.mat = mat\n        self.pil = Image.fromarray(mat, mode=mode)\n        self._updatefrommat()\n\n\n    def _repil(self, pil):\n        self.pil = pil\n        self.mat = np.asarray(self.pil)\n        self._updatefrommat()\n\n    def _updatefrommat(self):\n        self._dims = self.mat.shape\n        self._ndim = len(self._dims)\n        self._h = self._dims[0]\n        self._w = self._dims[1]\n        self._nchan = self._dims[2] if self._ndim==3 else 0\n\n    @property\n    def dims(self):\n        \"\"\"Return the image dimensions.\n\n        Returns\n        -------\n        tuple\n            the image dimensions.\n        \"\"\"\n        return self._dims\n\n    @property\n    def ndim(self):\n        \"\"\"Return the number of dimensions.\n\n        Returns\n        -------\n        int\n            the number of dimensions.\n        \"\"\"\n        return self._ndim\n\n    @property\n    def h(self):\n        \"\"\"Return the height of the image.\n\n        Returns\n        -------\n        int\n            the height of the image.\n        \"\"\"\n        return self._h\n\n    @property\n    def w(self):\n        \"\"\"Return the width of the image.\n\n        Returns\n        -------\n        int\n            the width of the image.\n        \"\"\"\n        return self._w\n\n    @property\n    def nchan(self):\n        \"\"\"Return the number of channels.\n\n        Returns\n        -------\n        int\n            the number of channels.\n        \"\"\"\n        return self._nchan\n\n    @property\n    def maxlum(self):\n        \"\"\"Return the maximum luminance of the image.\n\n        Returns\n        -------\n        float\n            the maximum luminance of the image.\n        \"\"\"\n        return np.max(self.mat)\n\n    @property\n    def minlum(self):\n        \"\"\"Return the minimum luminance of the image.\n\n        Returns\n        -------\n        float\n            the minimum luminance of the image.\n        \"\"\"\n        return np.min(self.mat)\n\n    @property\n    def meanlum(self):\n        \"\"\"Return the mean luminance of the image.\n\n        Returns\n        -------\n        float\n            the mean luminance of the image.\n        \"\"\"\n        return np.mean(self.mat)\n\n    @property\n    def rms(self):\n        \"\"\"Return the RMS of the image.\n\n        Returns\n        -------\n        float\n            the RMS of the image.\n        \"\"\"\n        return np.std(self.mat)\n\n    @property\n    def luminfo(self):\n        \"\"\"Print the luminance information of the image.\n        \"\"\"\n        print(f'Maximum luminance: {self.maxlum}\\n'+\n              f'Minimum luminance: {self.minlum}\\n'+\n              f'Mean luminance: {self.meanlum}\\n'+\n              f'RMS: {self.rms}')\n\n\n    def torgba(self):\n        \"\"\"Convert the image to RGBA.\n        \"\"\"\n        # convert pil to RGBA and save in .mat\n        if len(self.mat.shape)==2: # Gray\n            self.mat = self.mat[..., np.newaxis]\n        assert len(self.mat.shape)==3\n\n        nchan = self.mat.shape[2]\n        if nchan==1: # Gray 'L'\n            rgbmat = np.repeat(self.mat, 3, axis=2) # RGB\n            alphavalue = 255 if rgbmat.max()&gt;1 else 1\n            amat = np.ones_like(rgbmat[:,:,0],dtype=np.uint8)*alphavalue # alpha\n        elif nchan==2: # Gray 'LA'\n            rgbmat = np.repeat(self.mat[:,:,0:1], 3, axis=2) # RGB\n            amat = self.mat[:,:,-1] # alpha\n        elif nchan==3: # RGB\n            rgbmat = self.mat # RGB\n            alphavalue = 255 if rgbmat.max()&gt;1 else 1\n            amat = np.ones_like(rgbmat[:,:,0],dtype=np.uint8)*alphavalue # alpha\n        elif nchan==4: # RGBA\n            rgbmat = self.mat[:,:,0:3]\n            amat = self.mat[:,:,-1]\n\n        self.rgbmat = rgbmat\n        self.amat = amat\n        self.remat(np.concatenate((rgbmat, amat[..., np.newaxis]), axis=2), 'RGBA')\n\n\n    def grayscale(self):\n        \"\"\"Convert the image to gray-scale.\n        \"\"\"\n        # convert image to gray-scale\n        self._repil(ImageOps.grayscale(self.pil))\n\n\n    def addbg(self, bgcolor=(255,255,255)):\n        \"\"\"Add background to the RGBA image.\n\n        Parameters\n        ----------\n        bgcolor : list, optional\n            the background color. Defaults to (255,255,255).\n        \"\"\"\n\n        if len(bgcolor)&gt;4:\n            bgcolor = bgcolor[:4]\n\n        # make sure the image is in RGBA\n        if self._ndim&lt;4:\n            self.torgba()\n\n        # make a new image with the same size and the background color\n        bg = Image.new('RGBA', (self._w, self._h), tuple(bgcolor))\n        # paste self to the background image\n        bg.paste(self.pil, (0,0), self.pil)\n        # apply pil\n        self._repil(bg)\n\n\n    def _logit(self, ratio=None, correction=0.00001):\n        \"\"\"Convert the ratio to log odds.\n\n        Parameters\n        ----------\n        ratio : np.array, optional\n            the ratio of the image. Defaults to None.\n        correction : float, optional\n            the correction value. Defaults to 0.00001.\n\n        Returns\n        -------\n        np.array\n            the log odds of the image.\n        \"\"\"\n\n        if ratio is None:\n            self.grayscale()\n            ratio = self.mat/255\n        elif type(ratio) is not np.ndarray:\n            ratio = np.array(ratio)\n\n        ratio[ratio==1] = (255-correction)/255\n        ratio[ratio==0] = correction/255\n\n        return np.log(ratio/(1-ratio))\n\n\n    def _sigmoid(self, logodds, correction=0.00001):\n        \"\"\"Convert the log odds to the ratio.\n\n        Parameters\n        ----------\n        logodds : np.array\n            the log odds of the image.\n        correction : float, optional\n            the correction value. Defaults to 0.00001.\n\n        Returns\n        -------\n        np.array\n            the ratio of the image.\n        \"\"\"\n\n        ratio = np.exp(logodds)/(np.exp(logodds)+1)\n        ratio[ratio&gt;=(1-correction)] = 1\n        ratio[ratio&lt;=(correction)] = 0\n\n        gray = ratio * 255\n\n        return gray.astype(dtype=np.uint8)\n\n\n    def rotate(self, angle=180):\n        \"\"\"Rotate the image unclockwise.\n\n        Parameters\n        ----------\n        angle : float\n            the angle to rotate the image. Defaults to 180.\n        \"\"\"\n        # rotate the image\n        self._repil(self.pil.rotate(angle))\n\n\n    def stdmat(self, clip=2, matkey='mat'):\n        \"\"\"Standardize the image with the desired Root-Mean-Square contrast or `outrange`. This function applies to self.\n\n        Parameters\n        ----------\n        clip : float, optional\n            the desired clip value. Defaults to 2.\n        matkey : str, optional\n            the key/name of the matrix to be standardized. Default to 'mat'.\n        \"\"\"\n\n        mat = getattr(self, matkey)\n        mat_out = self._stdmat(mat, clip=clip)\n        setattr(self, matkey, mat_out)\n\n        # update the image matrix to self\n        self.remat(mat_out.astype(dtype=np.uint8))\n\n\n    def _stdmat(self, mat, clip=2):\n        \"\"\"Standardize the image.\n\n        For the algorithm, see Appendix B in \n        Loschky, L. C., Sethi, A., Simons, D. J., Pydimarri, T. N., Ochs, D., &amp; Corbeille, J. L. (2007). The importance of information localization in scene gist recognition. Journal of Experimental Psychology: Human Perception and Performance, 33(6), 1431-1450. https://doi.org/10.1037/0096-1523.33.6.1431\n        Perfetto, S., Wilder, J., &amp; Walther, D. B. (2020). Effects of spatial frequency filtering choices on the perception of filtered images. Vision, 4(2), Article 2. https://doi.org/10.3390/vision4020029\n\n        Parameters\n        ----------\n        mat : np.array\n            the image matrix.\n        clip : float, optional\n            the desired clip value. Defaults to 2.\n\n        Returns\n        -------\n        np.array\n            the standardized image matrix, the range of the output is [-clip, clip].\n        \"\"\"\n        # convert the image to double\n        mat = mat.astype('double')\n\n        # standardize the image (the range of output should be -1,1)\n        mat_std = (mat - np.mean(mat))/np.std(mat)\n\n        # clip the image\n        clip = np.abs(clip)\n        if clip &gt; 0:\n            Nclipped = np.round(np.mean(np.abs(mat_std)&gt;clip) * 100, 2)\n            print(f'Clipped {Nclipped}% pixels...')\n\n            mat_std[mat_std&gt;clip] = clip\n            mat_std[mat_std&lt;-clip] = -clip\n\n            # rescale with std due to clipping\n            mat_std = mat_std / np.std(mat_std)\n\n        return mat_std\n\n\n    def rescale(self, range=None, matkey='mat'):\n        \"\"\"Rescale the image with the desired range. This function applies to self.\n\n        Parameters\n        ----------\n        range : list/tuple, optional\n            range to be used for standardization, by default None\n        matkey : str, optional\n            the key/name of the matrix to be standardized. Default to 'mat'.\n        \"\"\"\n        mat = getattr(self, matkey)\n\n        mat_out = self._rescale(mat, range=range)\n        setattr(self, matkey, mat_out)\n\n        # update the image matrix to self\n        self.remat(mat_out.astype(dtype=np.uint8))\n\n\n    def _rescale(self, mat, range=None):\n        \"\"\"Rescale the image matrix.\n\n        Parameters\n        ----------\n        mat : np.array\n            the image matrix.\n        range : list/tuple, optional\n            range to be used for standardization, by default None\n\n        Returns\n        -------\n        np.array\n            the rescaled image matrix.\n        \"\"\"\n        # rescale the image to the desired range\n        if range is None:\n            mat_min = np.min(mat)\n            mat_max = np.max(mat)\n\n        else:\n            mat_min = min(range)\n            mat_max = max(range)       \n\n        return (mat - mat_min) / (mat_max - mat_min) * 255 \n\n\n    def adjust_pil(self, lum=None, rms=None):\n        \"\"\"Adjust the luminance and contrast of the image with `pillow`.\n\n        Parameters\n        ----------\n        lum : int, optional\n            the luminance, by default None\n        rms : int, optional\n            the RMS contrast, by default None\n        \"\"\"\n        # adjust lumninance \n        enhancer = ImageEnhance.Brightness(self.pil)\n        brightness_factor = lum / ImageStat.Stat(self.pil.convert('L')).mean[0]\n        adjusted_image = enhancer.enhance(brightness_factor)\n\n        # adjust contrast of the image\n        enhancer = ImageEnhance.Contrast(adjusted_image)\n        contrast_factor = rms / ImageStat.Stat(adjusted_image.convert('L')).stddev[0]\n        adjusted_image = enhancer.enhance(contrast_factor)\n\n        self._repil(adjusted_image)\n\n\n    def cropoval(self, radius=(100,128), position=None, bgcolor=None, crop=True):\n        \"\"\"Crop the image with an oval shape.\n\n        Parameters\n        ----------\n        radius : tuple, optional\n            the radius of the oval. Defaults to (100,128).\n        position : tuple, optional\n            the position of the oval. Defaults to None.\n        bgcolor : tuple, optional\n            the background color. Defaults to None. For instance, if bgcolor is (255, 255, 255, 255), the output image is not transparent; if bgcolor is (255, 255, 255, 0), the output image is transparent.\n        sigma : float, optional\n            [Not in use] the standard deviation of the Gaussian blur. Defaults to 0, i.e., no blur.\n        crop : bool, optional\n            whether to crop the image to the oval (true) or keep its original dimension. Defaults to True.\n        \"\"\"\n\n        # duplicate the radius if only one value is given\n        if type(radius) is not tuple or len(radius) == 1:\n            radius = (radius, radius)\n\n        # by default, crop the image to the center\n        if position is None:\n            position = (self._w/2, self._h/2)\n\n        # to make circle\n        if type(radius) is not tuple:\n            radius = (radius, radius) # a and b in ellipse formula\n        bbox = (position[0]-radius[0], position[1]-radius[1], position[0]+radius[0], position[1]+radius[1])\n\n        # make a ellipse/oval mask\n        pil_a = Image.new(\"L\", self.pil.size, 0)\n        draw = ImageDraw.Draw(pil_a)\n        draw.ellipse(bbox, fill=255)\n\n        # apply Gaussian blur to the mask if needed\n        # if sigma&gt;0:\n        #     pil_a = pil_a.filter(ImageFilter.GaussianBlur(sigma))\n\n        if bgcolor is not None:\n            if type(bgcolor) is not tuple:\n                bgcolor = ((bgcolor),)*len(self.pil.mode)\n            pil_2 = Image.new(self.pil.mode, self.pil.size, bgcolor)\n            draw = ImageDraw.Draw(pil_2)\n            draw.ellipse(bbox, fill=255)\n            self.pil = Image.composite(self.pil, pil_2, pil_a)\n        else:\n            # only apply cropping to the alpha channel\n            self.pil.putalpha(pil_a)\n        # update to pil        \n        self._repil(self.pil)\n\n        # make it to a rectangle\n        if crop:\n            # make it a rectangle just containing the oval\n            self.croprect(bbox)\n        else:\n            # make it a rectangle containing the whole image\n            self.croprect((0, 0, self._w, self._h))\n\n\n    def croprect(self, box=None):\n        \"\"\"Crop the image with a rectangle box.\n\n        Parameters\n        ----------\n        box : tuple, optional\n            the box to crop the image. Defaults to None.\n        \"\"\"\n        # crop the image with a rectangle box\n        self._repil(self.pil.crop(box))\n\n\n    def resize(self, **kwargs):\n        \"\"\"Resize the image.\n\n        Other Parameters\n        ----------------\n        trgw : int\n            the width of the target/desired stimuli.\n        trgh : int\n            the height of the target/desired stimuli.\n        ratio : float\n            the ratio to resize the image. Defaults to 0.\n        newfolder : str\n            the folder to save the resized image. Defaults to None.\n        \"\"\"\n        # resize the image\n        defaultKwargs = {'trgw': None, 'trgh': None, 'ratio':0, 'newfolder':None}\n        kwargs = {**defaultKwargs, **kwargs}\n\n        if (kwargs['trgw'] is not None) &amp; (kwargs['trgh'] is not None):\n            (w, h) = (kwargs['trgw'], kwargs['trgh'])\n        elif (kwargs['trgw'] is not None) &amp; (kwargs['trgh'] is None):\n            w = kwargs['trgw']\n            h = int(w*self._h/self._w)\n        elif (kwargs['trgw'] is None) &amp; (kwargs['trgh'] is not None): \n            h = kwargs['trgh']\n            w = int(h*self._w/self._h)\n        elif kwargs['ratio']&gt;0:\n            w = int(self._w*kwargs['ratio'])\n            h = int(self._h*kwargs['ratio'])\n        else:\n            raise 'Cannot determine the desired dimentions...'\n\n        kwargs['size'] = (w,h)\n        if (kwargs['newfolder'] is None):\n            newfolder = str(w)+'_'+str(h)\n        else:\n            newfolder = kwargs['newfolder']\n\n        [kwargs.pop(k) for k in defaultKwargs.keys()] # remove unused keys\n\n        # save re-sized images (information)\n        self._repil(self.pil.resize(**kwargs))\n        self._newfilename(newfolder=newfolder)\n\n\n    def pad(self, **kwargs):  \n        \"\"\"\n        Add padding to the image/stimuli.\n\n        Other Parameters\n        ----------------\n        trgw : int\n            the width of the target/desired stimuli. \n        trgh : int\n            the height of the target/desired stimuli.\n        padvalue : int\n            padding value. Defaults to 0 (show as transparent if alpha channel exists).\n        top : bool\n            padding more to top if needed. Defaults to True.\n        left : bool \n            padding more to left if needed. Defaults to True.\n        padalpha : int\n            the transparent color. Defaults to -1, i.e., not to force it to transparent.\n        extrafn : str\n            the string to be added to the filename. Defaults to '_pad'.\n        \"\"\"\n\n        defaultKwargs = {'trgw':self._w, 'trgh':self._h, 'padvalue': 0, 'top': True, 'left':True, 'padalpha':-1, 'extrafn':'_pad'}\n        kwargs = {**defaultKwargs, **kwargs}\n\n        trgw,trgh = kwargs['trgw'], kwargs['trgh']\n\n        assert(trgw&gt;=self._w)\n        assert(trgh&gt;=self._h)\n\n        x1 = int(np.ceil(trgw-self._w)/2)\n        x2 = trgw-self._w-x1\n        y1 = int(np.ceil(trgh-self._h)/2)\n        y2 = trgh-self._h-y1\n\n        if kwargs['top']:\n            htop, hbot = y1,y2\n        else:\n            htop, hbot = y2,y1\n        if kwargs['left']:\n            wleft, wright = x1,x2\n        else:\n            wleft, wright = x2,x1\n\n        if self._nchan==0:\n            nchan = 1\n            mat = self.mat[..., np.newaxis] # add one more axis\n        else:\n            nchan = self._nchan\n            mat = self.mat\n\n        if (kwargs['padalpha']&gt;=0) &amp; (nchan==1 | nchan==3):\n            mat = np.concatenate((mat, np.ones((self._h, self._w, 1), dtype=np.uint8)*kwargs['padalpha']),axis=2)\n            nchan = nchan + 1\n\n        padmat = np.hstack((\n            np.ones((trgh,wleft,nchan),dtype=np.uint8)*kwargs['padvalue'], \n            np.vstack((\n                np.ones((htop,self._w,nchan),dtype=np.uint8)*kwargs['padvalue'], \n                mat,\n                np.ones((hbot,self._w,nchan),dtype=np.uint8)*kwargs['padvalue']\n            )),\n            np.ones((trgh,wright,nchan),dtype=np.uint8)*kwargs['padvalue'], \n        ))\n\n        if (self._nchan==0) &amp; (kwargs['padalpha']&lt;0):\n            padmat = padmat[:,:,0]\n\n        self.remat(padmat)\n        if kwargs['extrafn']!='':\n            self._newfilename(newfname=kwargs['extrafn'])\n\n\n    def mkboxscr(self, **kwargs):\n        \"\"\"Make box scrambled stimuli.\n\n        Other Parameters\n        ----------------\n        nBoxW : int\n            the number of boxes in width. Defaults to 10.\n        nBoxH : int\n            the number of boxes in height. Defaults to 16.\n        pBoxW : int\n            the width of a box. Defaults to 0.\n        pBoxH : int\n            the height of a box. Defaults to 0.\n        pad : bool\n            whether to add padding to the image. Defaults to False.\n        padcolor : int\n            the padding color. Defaults to 0.\n        padalpha : int\n            the padding alpha. Defaults to -1.\n        \"\"\"\n        defaultKwargs = {'nBoxW':10, 'nBoxH':16, \n                     'pBoxW':0, 'pBoxH':0, \n                     'pad': False, 'padcolor':0, 'padalpha': -1}\n        kwargs = {**defaultKwargs, **kwargs}\n\n        if (kwargs['pBoxW']!=0) &amp; (kwargs['pBoxH']!=0):\n\n            _nBoxW = self._w/kwargs['pBoxW']\n            _nBoxH = self._h/kwargs['pBoxH']\n\n            if not ((_nBoxW.is_integer()) &amp; (_nBoxH.is_integer())):\n                assert kwargs['pad'], 'Please input valid pBoxW and pBoxH. Or set \"pad\" to True.'\n\n                # add complementary parts to top and right\n                xnew = int(np.ceil(_nBoxW) * kwargs['pBoxW'])\n                ynew = int(np.ceil(_nBoxH) * kwargs['pBoxH'])\n\n                self.pad(trgw=xnew, trgh=ynew, padvalue=kwargs['padcolor'], padalpha=kwargs['padalpha'])\n\n            kwargs['nBoxW'] = int(self._w/kwargs['pBoxW'])\n            kwargs['nBoxH'] = int(self._h/kwargs['pBoxH'])\n\n        elif (kwargs['nBoxW']!=0) &amp; (kwargs['nBoxH']!=0):\n\n            # x and y pixels for each box\n            _pBoxW = self._w/kwargs['nBoxW']\n            _pBoxH = self._h/kwargs['nBoxH']\n\n            if not ((_pBoxW.is_integer()) &amp; (_pBoxH.is_integer())):\n                assert kwargs['pad'], 'Please input valid nBoxW and nBoxH. Or set \"pad\" to True.'\n\n                # add padding (top, right, bottom, left)\n                newW = int(np.ceil(_pBoxW) * kwargs['nBoxW'])\n                newY = int(np.ceil(_pBoxH) * kwargs['nBoxH'])\n                self.pad(trgw=newW, trgh=newY, padvalue=kwargs['padcolor'], padalpha=kwargs['padalpha'])\n\n            kwargs['pBoxW'] = int(self._w/kwargs['nBoxW'])\n            kwargs['pBoxH'] = int(self._h/kwargs['nBoxH'])\n        else:\n            raise 'Please set valid nBoxW and nBoxH (or pBoxW and pBoxH).'\n\n        assert kwargs['nBoxW']*kwargs['pBoxW']==self._w, f\"'nBoxW': {kwargs['nBoxW']}   'pBoxW': {kwargs['pBoxW']}    'self._w': {self._w}\"\n        assert kwargs['nBoxH']*kwargs['pBoxH']==self._h, f\"'nBoxH': {kwargs['nBoxH']}   'pBoxH': {kwargs['pBoxH']}    'self._h': {self._h}\"\n\n        # x and y for all boxes\n        xys = list(product(range(0,self._w,kwargs['pBoxW']), range(0,self._h,kwargs['pBoxH'])))\n        boxes = [self.mat[i[1]:(i[1]+kwargs['pBoxH']), i[0]:(i[0]+kwargs['pBoxW'])] for i in xys]\n        # randomize the boxes\n        bsboxes = np.random.permutation(boxes)\n        # save as np.array\n        bslist = [bsboxes[i:i+kwargs['nBoxW']] for i in range(0,len(bsboxes),kwargs['nBoxW'])]\n        # bsmat = np.moveaxis(np.asarray(bslist), [-1, 1], [0, -2]).reshape(-1, y, x)\n        bsmatm = np.asarray(bslist)\n        if len(bsmatm.shape)==4:\n            bsmatm = bsmatm[..., np.newaxis]\n        bsmat = np.moveaxis(bsmatm, [-1, 1], [0, -2]).reshape(-1, self._h, self._w)\n\n        # save box-scrambled images (and information)\n        self.remat(np.squeeze(np.moveaxis(bsmat,0,2)))\n        self._newfilename(newfname='_bscr')\n\n\n    def mkphasescr(self):\n        \"\"\"Make phase scrambled stimuli.\n        \"\"\"\n        # make a random phase\n        randphase = np.angle(np.fft.fft2(np.random.rand(self._h, self._w)))\n\n        if self._nchan==0:\n            nchan = 1\n            mat = self.mat[..., np.newaxis] # add one more axis\n        else:\n            nchan = self._nchan\n            mat = self.mat\n\n        outmat = np.empty(mat.shape)\n        outmat[:] = np.NaN\n\n        for i in range(nchan):\n            thismat = self.mat[:,:,i]\n            stdmat = (thismat - np.mean(thismat))/np.std(thismat)\n            img_freq = np.fft.fft2(stdmat)\n            amp = np.abs(img_freq)\n            phase = np.angle(img_freq) + randphase\n            outimg = np.real(np.fft.ifft2(amp * np.exp(np.sqrt(-1+0j)*phase)))\n            stdout= (outimg - np.mean(outimg))/np.std(outimg)\n            outmat[:,:,i] = (stdout - np.min(stdout)) * 255 / (np.max(stdout) - np.min(stdout))\n\n        if self._nchan==0:\n            outmat = outmat[:,:,0]\n\n        self.remat(np.uint8(outmat))\n        self._newfilename(newfname='_pscr')\n\n\n    def filter(self, **kwargs):\n        \"\"\"Filter the image with low-pass or high-pass filter.\n\n        Other Parameters\n        ----------------\n        filter : str\n            the filter type. Defaults to 'low'. Other option is 'high'.\n        vapi : int\n            visual angle per image. Defaults to 5.\n        cutoff : int\n            cycles per image (width) or cycles per degree if vapi&gt;0. Defaults to 8.\n        clip : int\n            the clip value. Defaults to 0, i.e., no clipping or normalization will be applied.\n        \"\"\"\n        # the other possible solution is:\n        # # https://www.djmannion.net/psych_programming/vision/sf_filt/sf_filt.html\n\n        defaultKwargs = {'filter':'low',\n                         'vapi': 5,  # visual angle per image\n                         'cutoff': 8,   # cycles per image (width) or cycles per degree if vapi&gt;0\n                         'clip': 0}   \n        kwargs = {**defaultKwargs, **kwargs}\n\n        # apply filter and save all LSF, HSF, and FS\n        images, sigma = self._filter(**kwargs)\n\n        # save the filtered images according to the filter type\n        if kwargs['filter'] in ['low', 'lsf', 'l']:\n            self.remat(images['lsf'].astype(dtype=np.uint8))\n            self.mat_filter = images['lsf']\n        elif kwargs['filter'] in ['high', 'hsf', 'h']:\n            self.remat(images['hsf'].astype(dtype=np.uint8))\n            self.mat_filter = images['hsf']\n        elif kwargs['filter'] in ['all', 'fs']:\n            # for debugging and standardization purpose\n            self.remat(images['fs'].astype(dtype=np.uint8))\n            self.mat_filter = images['fs']\n\n        # save the filter information\n        self.filterinfo = f'{kwargs[\"filter\"]}_{sigma}'\n\n        # update the filename\n        self._newfilename(newfname='_'+kwargs['filter'])\n\n\n    def _filter(self, **kwargs):\n        \"\"\"Filter the image with low-pass or high-pass filter. This function is used in filter().\n\n        Other Parameters\n        ----------------\n        vapi : int\n            visual angle per image. Defaults to 5.\n        cutoff : int\n            cycles per image (width) or cycles per degree if vapi&gt;0. Defaults to 8.\n        clip : int\n            the clip value. Defaults to 0, i.e., no clipping or normalization will be applied.\n\n        Returns\n        -------\n        dict\n            a dictionary with three keys: 'lsf', 'hsf', 'fs', corresponding to the low-pass filtered image, high-pass filtered image, and the original image, respectively.\n        \"\"\"\n\n        defaultKwargs = {'vapi': 5,  # visual angle per image\n                         'cutoff': 8,   # cutoff; cycles per image (width) or cycles per degree if vapi&gt;0\n                         'clip': 0}   \n        kwargs = {**defaultKwargs, **kwargs}\n\n        # grayscale image\n        self.grayscale()\n\n        # cycles per image (width) OR cycles per degree (along the width)\n        # FWHM = 2 * sqrt(2 * log(2)) * sigma\n        # sigma = self._w / (2 * np.pi * kwargs['cpi'] * kwargs['vapi'])\n        sigma = self._w / (kwargs['vapi'] * np.pi * np.sqrt(2 * np.log(2)) * kwargs['cutoff'])\n\n        # Apply low-pass filter\n        low_pass_image = self.pil.filter(ImageFilter.GaussianBlur(radius=sigma))\n        low_pass_mat = np.asarray(low_pass_image).astype('double')\n\n        # Create high-pass filter by subtracting low-pass image\n        # keep the negative values\n        high_pass_mat = self.mat.astype('double') - low_pass_mat.astype('double')\n        # make sure the minimum value is 0\n        high_pass_mat = high_pass_mat - np.min(high_pass_mat)\n        if np.any(high_pass_mat &gt; 255):\n            warnings.warn(\"Some values in the high-pass filtered image are above 255.\")\n            high_pass_mat = high_pass_mat / 255\n        # this does not work as expected, as it forces negative values to 0\n        # high_pass_image = ImageChops.subtract(self.pil, low_pass_image)\n        # high_pass_mat = np.asarray(high_pass_image)\n\n        # save output\n        mat_dict = {'lsf': low_pass_mat, \n                    'hsf': high_pass_mat,\n                    'fs': self.mat.astype('double')}\n\n        if kwargs['clip'] != 0:\n            # standardize across multiple images if clip is not 0\n            # similar to standardize() in __inti__.py\n\n            # standardize each image separately\n            mat_dict = {k: self._stdmat(mat=v, clip=kwargs['clip']) for k, v in mat_dict.items()}\n\n            # grand min and max\n            grand_min = min([np.min(v) for v in mat_dict.values()])\n            grand_max = max([np.max(v) for v in mat_dict.values()])\n\n            # Compute the grand normalized images\n            mat_dict = {k: self._rescale(mat=v, range=[grand_min,grand_max]) for k,v in mat_dict.items()}\n\n        return mat_dict, sigma\n</code></pre>"},{"location":"api/api/#pyfaceimage.image.dims","title":"<code>dims</code>  <code>property</code>","text":"<p>Return the image dimensions.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>the image dimensions.</p>"},{"location":"api/api/#pyfaceimage.image.dirname","title":"<code>dirname</code>  <code>property</code>","text":"<p>Return the image directory.</p> <p>Returns:</p> Type Description <code>str</code> <p>the image directory.</p>"},{"location":"api/api/#pyfaceimage.image.ext","title":"<code>ext</code>  <code>property</code>","text":"<p>Return the image extension.</p> <p>Returns:</p> Type Description <code>str</code> <p>the image extension.</p>"},{"location":"api/api/#pyfaceimage.image.filename","title":"<code>filename</code>  <code>property</code>","text":"<p>Return the image filename.</p> <p>Returns:</p> Type Description <code>str</code> <p>the image filename.</p>"},{"location":"api/api/#pyfaceimage.image.fname","title":"<code>fname</code>  <code>property</code>","text":"<p>Return the image filename.</p> <p>Returns:</p> Type Description <code>str</code> <p>the image filename.</p>"},{"location":"api/api/#pyfaceimage.image.fnonly","title":"<code>fnonly</code>  <code>property</code>","text":"<p>Return the image filename without extension.</p> <p>Returns:</p> Type Description <code>str</code> <p>the image filename without extension.</p>"},{"location":"api/api/#pyfaceimage.image.h","title":"<code>h</code>  <code>property</code>","text":"<p>Return the height of the image.</p> <p>Returns:</p> Type Description <code>int</code> <p>the height of the image.</p>"},{"location":"api/api/#pyfaceimage.image.isfile","title":"<code>isfile</code>  <code>property</code>","text":"<p>Return whether the image file exists.</p> <p>Returns:</p> Type Description <code>bool</code> <p>whether the image file exists.</p>"},{"location":"api/api/#pyfaceimage.image.luminfo","title":"<code>luminfo</code>  <code>property</code>","text":"<p>Print the luminance information of the image.</p>"},{"location":"api/api/#pyfaceimage.image.maxlum","title":"<code>maxlum</code>  <code>property</code>","text":"<p>Return the maximum luminance of the image.</p> <p>Returns:</p> Type Description <code>float</code> <p>the maximum luminance of the image.</p>"},{"location":"api/api/#pyfaceimage.image.meanlum","title":"<code>meanlum</code>  <code>property</code>","text":"<p>Return the mean luminance of the image.</p> <p>Returns:</p> Type Description <code>float</code> <p>the mean luminance of the image.</p>"},{"location":"api/api/#pyfaceimage.image.minlum","title":"<code>minlum</code>  <code>property</code>","text":"<p>Return the minimum luminance of the image.</p> <p>Returns:</p> Type Description <code>float</code> <p>the minimum luminance of the image.</p>"},{"location":"api/api/#pyfaceimage.image.nchan","title":"<code>nchan</code>  <code>property</code>","text":"<p>Return the number of channels.</p> <p>Returns:</p> Type Description <code>int</code> <p>the number of channels.</p>"},{"location":"api/api/#pyfaceimage.image.ndim","title":"<code>ndim</code>  <code>property</code>","text":"<p>Return the number of dimensions.</p> <p>Returns:</p> Type Description <code>int</code> <p>the number of dimensions.</p>"},{"location":"api/api/#pyfaceimage.image.rms","title":"<code>rms</code>  <code>property</code>","text":"<p>Return the RMS of the image.</p> <p>Returns:</p> Type Description <code>float</code> <p>the RMS of the image.</p>"},{"location":"api/api/#pyfaceimage.image.w","title":"<code>w</code>  <code>property</code>","text":"<p>Return the width of the image.</p> <p>Returns:</p> Type Description <code>int</code> <p>the width of the image.</p>"},{"location":"api/api/#pyfaceimage.image.__init__","title":"<code>__init__(filename, read=False)</code>","text":"<p>Create an image instance.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>path and image filename.</p> required <code>read</code> <code>bool</code> <p>Whether to read the image via PIL, by default False.</p> <code>False</code> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the file does not exist.</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>def __init__(self, filename, read=False):\n    \"\"\"Create an image instance.\n\n    Parameters\n    ----------\n    filename : str\n        path and image filename.  \n    read : bool, optional\n        Whether to read the image via PIL, by default False.\n\n    Raises\n    ------\n    AssertionError\n        If the file does not exist.\n    \"\"\"\n    # make sure the file exists \n    self._filename = filename\n    self.update_fninfo(filename, newfn=False) \n    self._setgroup() \n    self._setgpath()\n    if read: self.read()\n</code></pre>"},{"location":"api/api/#pyfaceimage.image.addbg","title":"<code>addbg(bgcolor=(255, 255, 255))</code>","text":"<p>Add background to the RGBA image.</p> <p>Parameters:</p> Name Type Description Default <code>bgcolor</code> <code>list</code> <p>the background color. Defaults to (255,255,255).</p> <code>(255, 255, 255)</code> Source code in <code>pyfaceimage/im.py</code> <pre><code>def addbg(self, bgcolor=(255,255,255)):\n    \"\"\"Add background to the RGBA image.\n\n    Parameters\n    ----------\n    bgcolor : list, optional\n        the background color. Defaults to (255,255,255).\n    \"\"\"\n\n    if len(bgcolor)&gt;4:\n        bgcolor = bgcolor[:4]\n\n    # make sure the image is in RGBA\n    if self._ndim&lt;4:\n        self.torgba()\n\n    # make a new image with the same size and the background color\n    bg = Image.new('RGBA', (self._w, self._h), tuple(bgcolor))\n    # paste self to the background image\n    bg.paste(self.pil, (0,0), self.pil)\n    # apply pil\n    self._repil(bg)\n</code></pre>"},{"location":"api/api/#pyfaceimage.image.adjust_pil","title":"<code>adjust_pil(lum=None, rms=None)</code>","text":"<p>Adjust the luminance and contrast of the image with <code>pillow</code>.</p> <p>Parameters:</p> Name Type Description Default <code>lum</code> <code>int</code> <p>the luminance, by default None</p> <code>None</code> <code>rms</code> <code>int</code> <p>the RMS contrast, by default None</p> <code>None</code> Source code in <code>pyfaceimage/im.py</code> <pre><code>def adjust_pil(self, lum=None, rms=None):\n    \"\"\"Adjust the luminance and contrast of the image with `pillow`.\n\n    Parameters\n    ----------\n    lum : int, optional\n        the luminance, by default None\n    rms : int, optional\n        the RMS contrast, by default None\n    \"\"\"\n    # adjust lumninance \n    enhancer = ImageEnhance.Brightness(self.pil)\n    brightness_factor = lum / ImageStat.Stat(self.pil.convert('L')).mean[0]\n    adjusted_image = enhancer.enhance(brightness_factor)\n\n    # adjust contrast of the image\n    enhancer = ImageEnhance.Contrast(adjusted_image)\n    contrast_factor = rms / ImageStat.Stat(adjusted_image.convert('L')).stddev[0]\n    adjusted_image = enhancer.enhance(contrast_factor)\n\n    self._repil(adjusted_image)\n</code></pre>"},{"location":"api/api/#pyfaceimage.image.cropoval","title":"<code>cropoval(radius=(100, 128), position=None, bgcolor=None, crop=True)</code>","text":"<p>Crop the image with an oval shape.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>tuple</code> <p>the radius of the oval. Defaults to (100,128).</p> <code>(100, 128)</code> <code>position</code> <code>tuple</code> <p>the position of the oval. Defaults to None.</p> <code>None</code> <code>bgcolor</code> <code>tuple</code> <p>the background color. Defaults to None. For instance, if bgcolor is (255, 255, 255, 255), the output image is not transparent; if bgcolor is (255, 255, 255, 0), the output image is transparent.</p> <code>None</code> <code>sigma</code> <code>float</code> <p>[Not in use] the standard deviation of the Gaussian blur. Defaults to 0, i.e., no blur.</p> required <code>crop</code> <code>bool</code> <p>whether to crop the image to the oval (true) or keep its original dimension. Defaults to True.</p> <code>True</code> Source code in <code>pyfaceimage/im.py</code> <pre><code>def cropoval(self, radius=(100,128), position=None, bgcolor=None, crop=True):\n    \"\"\"Crop the image with an oval shape.\n\n    Parameters\n    ----------\n    radius : tuple, optional\n        the radius of the oval. Defaults to (100,128).\n    position : tuple, optional\n        the position of the oval. Defaults to None.\n    bgcolor : tuple, optional\n        the background color. Defaults to None. For instance, if bgcolor is (255, 255, 255, 255), the output image is not transparent; if bgcolor is (255, 255, 255, 0), the output image is transparent.\n    sigma : float, optional\n        [Not in use] the standard deviation of the Gaussian blur. Defaults to 0, i.e., no blur.\n    crop : bool, optional\n        whether to crop the image to the oval (true) or keep its original dimension. Defaults to True.\n    \"\"\"\n\n    # duplicate the radius if only one value is given\n    if type(radius) is not tuple or len(radius) == 1:\n        radius = (radius, radius)\n\n    # by default, crop the image to the center\n    if position is None:\n        position = (self._w/2, self._h/2)\n\n    # to make circle\n    if type(radius) is not tuple:\n        radius = (radius, radius) # a and b in ellipse formula\n    bbox = (position[0]-radius[0], position[1]-radius[1], position[0]+radius[0], position[1]+radius[1])\n\n    # make a ellipse/oval mask\n    pil_a = Image.new(\"L\", self.pil.size, 0)\n    draw = ImageDraw.Draw(pil_a)\n    draw.ellipse(bbox, fill=255)\n\n    # apply Gaussian blur to the mask if needed\n    # if sigma&gt;0:\n    #     pil_a = pil_a.filter(ImageFilter.GaussianBlur(sigma))\n\n    if bgcolor is not None:\n        if type(bgcolor) is not tuple:\n            bgcolor = ((bgcolor),)*len(self.pil.mode)\n        pil_2 = Image.new(self.pil.mode, self.pil.size, bgcolor)\n        draw = ImageDraw.Draw(pil_2)\n        draw.ellipse(bbox, fill=255)\n        self.pil = Image.composite(self.pil, pil_2, pil_a)\n    else:\n        # only apply cropping to the alpha channel\n        self.pil.putalpha(pil_a)\n    # update to pil        \n    self._repil(self.pil)\n\n    # make it to a rectangle\n    if crop:\n        # make it a rectangle just containing the oval\n        self.croprect(bbox)\n    else:\n        # make it a rectangle containing the whole image\n        self.croprect((0, 0, self._w, self._h))\n</code></pre>"},{"location":"api/api/#pyfaceimage.image.croprect","title":"<code>croprect(box=None)</code>","text":"<p>Crop the image with a rectangle box.</p> <p>Parameters:</p> Name Type Description Default <code>box</code> <code>tuple</code> <p>the box to crop the image. Defaults to None.</p> <code>None</code> Source code in <code>pyfaceimage/im.py</code> <pre><code>def croprect(self, box=None):\n    \"\"\"Crop the image with a rectangle box.\n\n    Parameters\n    ----------\n    box : tuple, optional\n        the box to crop the image. Defaults to None.\n    \"\"\"\n    # crop the image with a rectangle box\n    self._repil(self.pil.crop(box))\n</code></pre>"},{"location":"api/api/#pyfaceimage.image.deepcopy","title":"<code>deepcopy()</code>","text":"<p>make a deep copy of the instance</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>def deepcopy(self):\n    \"\"\"make a deep copy of the instance\n    \"\"\"\n    return copy.deepcopy(self)\n</code></pre>"},{"location":"api/api/#pyfaceimage.image.filter","title":"<code>filter(**kwargs)</code>","text":"<p>Filter the image with low-pass or high-pass filter.</p> <p>Other Parameters:</p> Name Type Description <code>filter</code> <code>str</code> <p>the filter type. Defaults to 'low'. Other option is 'high'.</p> <code>vapi</code> <code>int</code> <p>visual angle per image. Defaults to 5.</p> <code>cutoff</code> <code>int</code> <p>cycles per image (width) or cycles per degree if vapi&gt;0. Defaults to 8.</p> <code>clip</code> <code>int</code> <p>the clip value. Defaults to 0, i.e., no clipping or normalization will be applied.</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>def filter(self, **kwargs):\n    \"\"\"Filter the image with low-pass or high-pass filter.\n\n    Other Parameters\n    ----------------\n    filter : str\n        the filter type. Defaults to 'low'. Other option is 'high'.\n    vapi : int\n        visual angle per image. Defaults to 5.\n    cutoff : int\n        cycles per image (width) or cycles per degree if vapi&gt;0. Defaults to 8.\n    clip : int\n        the clip value. Defaults to 0, i.e., no clipping or normalization will be applied.\n    \"\"\"\n    # the other possible solution is:\n    # # https://www.djmannion.net/psych_programming/vision/sf_filt/sf_filt.html\n\n    defaultKwargs = {'filter':'low',\n                     'vapi': 5,  # visual angle per image\n                     'cutoff': 8,   # cycles per image (width) or cycles per degree if vapi&gt;0\n                     'clip': 0}   \n    kwargs = {**defaultKwargs, **kwargs}\n\n    # apply filter and save all LSF, HSF, and FS\n    images, sigma = self._filter(**kwargs)\n\n    # save the filtered images according to the filter type\n    if kwargs['filter'] in ['low', 'lsf', 'l']:\n        self.remat(images['lsf'].astype(dtype=np.uint8))\n        self.mat_filter = images['lsf']\n    elif kwargs['filter'] in ['high', 'hsf', 'h']:\n        self.remat(images['hsf'].astype(dtype=np.uint8))\n        self.mat_filter = images['hsf']\n    elif kwargs['filter'] in ['all', 'fs']:\n        # for debugging and standardization purpose\n        self.remat(images['fs'].astype(dtype=np.uint8))\n        self.mat_filter = images['fs']\n\n    # save the filter information\n    self.filterinfo = f'{kwargs[\"filter\"]}_{sigma}'\n\n    # update the filename\n    self._newfilename(newfname='_'+kwargs['filter'])\n</code></pre>"},{"location":"api/api/#pyfaceimage.image.grayscale","title":"<code>grayscale()</code>","text":"<p>Convert the image to gray-scale.</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>def grayscale(self):\n    \"\"\"Convert the image to gray-scale.\n    \"\"\"\n    # convert image to gray-scale\n    self._repil(ImageOps.grayscale(self.pil))\n</code></pre>"},{"location":"api/api/#pyfaceimage.image.imsave","title":"<code>imsave(newfname='', newfolder='', addfn=True, **kwargs)</code>","text":"<p>Save the image mat.</p> <p>Parameters:</p> Name Type Description Default <code>newfname</code> <code>str</code> <p>strings to be added before the extension, by default ''</p> <code>''</code> <code>newfolder</code> <code>str</code> <p>folder name to replace the global directory or the last directory level, by default ''</p> <code>''</code> <code>addfn</code> <code>bool</code> <p>whether to add the newfname to the the original fname (instead of replacing it), by default True</p> <code>True</code> <code>kwargs</code> <code>dict</code> <p>keyword arguments for matplotlib.pyplot.imsave(), by default {}</p> <code>{}</code> Source code in <code>pyfaceimage/im.py</code> <pre><code>def imsave(self, newfname='', newfolder='', addfn=True, **kwargs):\n    \"\"\"Save the image mat.\n\n    Parameters\n    ----------\n    newfname : str, optional\n        strings to be added before the extension, by default ''\n    newfolder : str, optional\n        folder name to replace the global directory or the last directory level, by default ''\n    addfn : bool, optional\n        whether to add the newfname to the the original fname (instead of replacing it), by default True\n    kwargs : dict, optional\n        keyword arguments for matplotlib.pyplot.imsave(), by default {}\n    \"\"\"\n    # update the filename\n    self._newfilename(newfname, newfolder, addfn=addfn)\n\n    # make dir(s)\n    if not os.path.isdir(os.path.dirname(self.filename)):\n        os.makedirs(os.path.dirname(self.filename))\n    if self._nchan==1:\n        outmat = self.mat[:,:,0]\n    else:\n        outmat = self.mat\n\n    # use matplotlib.pyplot.imsave() to save .mat\n    mpimg.imsave(self.filename,outmat,**kwargs)\n    # mpimg.imsave(self.filename,outmat.copy(order='C'),**kwargs)\n    self._isfile = os.path.isfile(self.filename)\n</code></pre>"},{"location":"api/api/#pyfaceimage.image.imshow","title":"<code>imshow()</code>","text":"<p>Show the image matrix.</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>def imshow(self):\n    \"\"\"Show the image matrix.\n    \"\"\"\n    # for debugging purpose (check the mat)\n    # it seems that .show() is more useful\n    Image.fromarray(self.mat).show()\n</code></pre>"},{"location":"api/api/#pyfaceimage.image.mkboxscr","title":"<code>mkboxscr(**kwargs)</code>","text":"<p>Make box scrambled stimuli.</p> <p>Other Parameters:</p> Name Type Description <code>nBoxW</code> <code>int</code> <p>the number of boxes in width. Defaults to 10.</p> <code>nBoxH</code> <code>int</code> <p>the number of boxes in height. Defaults to 16.</p> <code>pBoxW</code> <code>int</code> <p>the width of a box. Defaults to 0.</p> <code>pBoxH</code> <code>int</code> <p>the height of a box. Defaults to 0.</p> <code>pad</code> <code>bool</code> <p>whether to add padding to the image. Defaults to False.</p> <code>padcolor</code> <code>int</code> <p>the padding color. Defaults to 0.</p> <code>padalpha</code> <code>int</code> <p>the padding alpha. Defaults to -1.</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>def mkboxscr(self, **kwargs):\n    \"\"\"Make box scrambled stimuli.\n\n    Other Parameters\n    ----------------\n    nBoxW : int\n        the number of boxes in width. Defaults to 10.\n    nBoxH : int\n        the number of boxes in height. Defaults to 16.\n    pBoxW : int\n        the width of a box. Defaults to 0.\n    pBoxH : int\n        the height of a box. Defaults to 0.\n    pad : bool\n        whether to add padding to the image. Defaults to False.\n    padcolor : int\n        the padding color. Defaults to 0.\n    padalpha : int\n        the padding alpha. Defaults to -1.\n    \"\"\"\n    defaultKwargs = {'nBoxW':10, 'nBoxH':16, \n                 'pBoxW':0, 'pBoxH':0, \n                 'pad': False, 'padcolor':0, 'padalpha': -1}\n    kwargs = {**defaultKwargs, **kwargs}\n\n    if (kwargs['pBoxW']!=0) &amp; (kwargs['pBoxH']!=0):\n\n        _nBoxW = self._w/kwargs['pBoxW']\n        _nBoxH = self._h/kwargs['pBoxH']\n\n        if not ((_nBoxW.is_integer()) &amp; (_nBoxH.is_integer())):\n            assert kwargs['pad'], 'Please input valid pBoxW and pBoxH. Or set \"pad\" to True.'\n\n            # add complementary parts to top and right\n            xnew = int(np.ceil(_nBoxW) * kwargs['pBoxW'])\n            ynew = int(np.ceil(_nBoxH) * kwargs['pBoxH'])\n\n            self.pad(trgw=xnew, trgh=ynew, padvalue=kwargs['padcolor'], padalpha=kwargs['padalpha'])\n\n        kwargs['nBoxW'] = int(self._w/kwargs['pBoxW'])\n        kwargs['nBoxH'] = int(self._h/kwargs['pBoxH'])\n\n    elif (kwargs['nBoxW']!=0) &amp; (kwargs['nBoxH']!=0):\n\n        # x and y pixels for each box\n        _pBoxW = self._w/kwargs['nBoxW']\n        _pBoxH = self._h/kwargs['nBoxH']\n\n        if not ((_pBoxW.is_integer()) &amp; (_pBoxH.is_integer())):\n            assert kwargs['pad'], 'Please input valid nBoxW and nBoxH. Or set \"pad\" to True.'\n\n            # add padding (top, right, bottom, left)\n            newW = int(np.ceil(_pBoxW) * kwargs['nBoxW'])\n            newY = int(np.ceil(_pBoxH) * kwargs['nBoxH'])\n            self.pad(trgw=newW, trgh=newY, padvalue=kwargs['padcolor'], padalpha=kwargs['padalpha'])\n\n        kwargs['pBoxW'] = int(self._w/kwargs['nBoxW'])\n        kwargs['pBoxH'] = int(self._h/kwargs['nBoxH'])\n    else:\n        raise 'Please set valid nBoxW and nBoxH (or pBoxW and pBoxH).'\n\n    assert kwargs['nBoxW']*kwargs['pBoxW']==self._w, f\"'nBoxW': {kwargs['nBoxW']}   'pBoxW': {kwargs['pBoxW']}    'self._w': {self._w}\"\n    assert kwargs['nBoxH']*kwargs['pBoxH']==self._h, f\"'nBoxH': {kwargs['nBoxH']}   'pBoxH': {kwargs['pBoxH']}    'self._h': {self._h}\"\n\n    # x and y for all boxes\n    xys = list(product(range(0,self._w,kwargs['pBoxW']), range(0,self._h,kwargs['pBoxH'])))\n    boxes = [self.mat[i[1]:(i[1]+kwargs['pBoxH']), i[0]:(i[0]+kwargs['pBoxW'])] for i in xys]\n    # randomize the boxes\n    bsboxes = np.random.permutation(boxes)\n    # save as np.array\n    bslist = [bsboxes[i:i+kwargs['nBoxW']] for i in range(0,len(bsboxes),kwargs['nBoxW'])]\n    # bsmat = np.moveaxis(np.asarray(bslist), [-1, 1], [0, -2]).reshape(-1, y, x)\n    bsmatm = np.asarray(bslist)\n    if len(bsmatm.shape)==4:\n        bsmatm = bsmatm[..., np.newaxis]\n    bsmat = np.moveaxis(bsmatm, [-1, 1], [0, -2]).reshape(-1, self._h, self._w)\n\n    # save box-scrambled images (and information)\n    self.remat(np.squeeze(np.moveaxis(bsmat,0,2)))\n    self._newfilename(newfname='_bscr')\n</code></pre>"},{"location":"api/api/#pyfaceimage.image.mkphasescr","title":"<code>mkphasescr()</code>","text":"<p>Make phase scrambled stimuli.</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>def mkphasescr(self):\n    \"\"\"Make phase scrambled stimuli.\n    \"\"\"\n    # make a random phase\n    randphase = np.angle(np.fft.fft2(np.random.rand(self._h, self._w)))\n\n    if self._nchan==0:\n        nchan = 1\n        mat = self.mat[..., np.newaxis] # add one more axis\n    else:\n        nchan = self._nchan\n        mat = self.mat\n\n    outmat = np.empty(mat.shape)\n    outmat[:] = np.NaN\n\n    for i in range(nchan):\n        thismat = self.mat[:,:,i]\n        stdmat = (thismat - np.mean(thismat))/np.std(thismat)\n        img_freq = np.fft.fft2(stdmat)\n        amp = np.abs(img_freq)\n        phase = np.angle(img_freq) + randphase\n        outimg = np.real(np.fft.ifft2(amp * np.exp(np.sqrt(-1+0j)*phase)))\n        stdout= (outimg - np.mean(outimg))/np.std(outimg)\n        outmat[:,:,i] = (stdout - np.min(stdout)) * 255 / (np.max(stdout) - np.min(stdout))\n\n    if self._nchan==0:\n        outmat = outmat[:,:,0]\n\n    self.remat(np.uint8(outmat))\n    self._newfilename(newfname='_pscr')\n</code></pre>"},{"location":"api/api/#pyfaceimage.image.pad","title":"<code>pad(**kwargs)</code>","text":"<p>Add padding to the image/stimuli.</p> <p>Other Parameters:</p> Name Type Description <code>trgw</code> <code>int</code> <p>the width of the target/desired stimuli.</p> <code>trgh</code> <code>int</code> <p>the height of the target/desired stimuli.</p> <code>padvalue</code> <code>int</code> <p>padding value. Defaults to 0 (show as transparent if alpha channel exists).</p> <code>top</code> <code>bool</code> <p>padding more to top if needed. Defaults to True.</p> <code>left</code> <code>bool</code> <p>padding more to left if needed. Defaults to True.</p> <code>padalpha</code> <code>int</code> <p>the transparent color. Defaults to -1, i.e., not to force it to transparent.</p> <code>extrafn</code> <code>str</code> <p>the string to be added to the filename. Defaults to '_pad'.</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>def pad(self, **kwargs):  \n    \"\"\"\n    Add padding to the image/stimuli.\n\n    Other Parameters\n    ----------------\n    trgw : int\n        the width of the target/desired stimuli. \n    trgh : int\n        the height of the target/desired stimuli.\n    padvalue : int\n        padding value. Defaults to 0 (show as transparent if alpha channel exists).\n    top : bool\n        padding more to top if needed. Defaults to True.\n    left : bool \n        padding more to left if needed. Defaults to True.\n    padalpha : int\n        the transparent color. Defaults to -1, i.e., not to force it to transparent.\n    extrafn : str\n        the string to be added to the filename. Defaults to '_pad'.\n    \"\"\"\n\n    defaultKwargs = {'trgw':self._w, 'trgh':self._h, 'padvalue': 0, 'top': True, 'left':True, 'padalpha':-1, 'extrafn':'_pad'}\n    kwargs = {**defaultKwargs, **kwargs}\n\n    trgw,trgh = kwargs['trgw'], kwargs['trgh']\n\n    assert(trgw&gt;=self._w)\n    assert(trgh&gt;=self._h)\n\n    x1 = int(np.ceil(trgw-self._w)/2)\n    x2 = trgw-self._w-x1\n    y1 = int(np.ceil(trgh-self._h)/2)\n    y2 = trgh-self._h-y1\n\n    if kwargs['top']:\n        htop, hbot = y1,y2\n    else:\n        htop, hbot = y2,y1\n    if kwargs['left']:\n        wleft, wright = x1,x2\n    else:\n        wleft, wright = x2,x1\n\n    if self._nchan==0:\n        nchan = 1\n        mat = self.mat[..., np.newaxis] # add one more axis\n    else:\n        nchan = self._nchan\n        mat = self.mat\n\n    if (kwargs['padalpha']&gt;=0) &amp; (nchan==1 | nchan==3):\n        mat = np.concatenate((mat, np.ones((self._h, self._w, 1), dtype=np.uint8)*kwargs['padalpha']),axis=2)\n        nchan = nchan + 1\n\n    padmat = np.hstack((\n        np.ones((trgh,wleft,nchan),dtype=np.uint8)*kwargs['padvalue'], \n        np.vstack((\n            np.ones((htop,self._w,nchan),dtype=np.uint8)*kwargs['padvalue'], \n            mat,\n            np.ones((hbot,self._w,nchan),dtype=np.uint8)*kwargs['padvalue']\n        )),\n        np.ones((trgh,wright,nchan),dtype=np.uint8)*kwargs['padvalue'], \n    ))\n\n    if (self._nchan==0) &amp; (kwargs['padalpha']&lt;0):\n        padmat = padmat[:,:,0]\n\n    self.remat(padmat)\n    if kwargs['extrafn']!='':\n        self._newfilename(newfname=kwargs['extrafn'])\n</code></pre>"},{"location":"api/api/#pyfaceimage.image.read","title":"<code>read()</code>","text":"<p>Read the image via PIL.</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>def read(self):\n    \"\"\"Read the image via PIL.\n    \"\"\"\n    self._repil(Image.open(self.filename)) # PIL.Image.open() \n</code></pre>"},{"location":"api/api/#pyfaceimage.image.remat","title":"<code>remat(mat, mode=None)</code>","text":"<p>Re-assign value to .mat and update related information.</p> <p>Parameters:</p> Name Type Description Default <code>mat</code> <code>array</code> <p>the new image matrix.</p> required Source code in <code>pyfaceimage/im.py</code> <pre><code>def remat(self, mat, mode=None):\n    \"\"\"Re-assign value to .mat and update related information.\n\n    Parameters\n    ----------\n    mat : np.array\n        the new image matrix.\n    \"\"\"\n    # re-assign value to .mat and update related information\n    self.mat = mat\n    self.pil = Image.fromarray(mat, mode=mode)\n    self._updatefrommat()\n</code></pre>"},{"location":"api/api/#pyfaceimage.image.rescale","title":"<code>rescale(range=None, matkey='mat')</code>","text":"<p>Rescale the image with the desired range. This function applies to self.</p> <p>Parameters:</p> Name Type Description Default <code>range</code> <code>list / tuple</code> <p>range to be used for standardization, by default None</p> <code>None</code> <code>matkey</code> <code>str</code> <p>the key/name of the matrix to be standardized. Default to 'mat'.</p> <code>'mat'</code> Source code in <code>pyfaceimage/im.py</code> <pre><code>def rescale(self, range=None, matkey='mat'):\n    \"\"\"Rescale the image with the desired range. This function applies to self.\n\n    Parameters\n    ----------\n    range : list/tuple, optional\n        range to be used for standardization, by default None\n    matkey : str, optional\n        the key/name of the matrix to be standardized. Default to 'mat'.\n    \"\"\"\n    mat = getattr(self, matkey)\n\n    mat_out = self._rescale(mat, range=range)\n    setattr(self, matkey, mat_out)\n\n    # update the image matrix to self\n    self.remat(mat_out.astype(dtype=np.uint8))\n</code></pre>"},{"location":"api/api/#pyfaceimage.image.resize","title":"<code>resize(**kwargs)</code>","text":"<p>Resize the image.</p> <p>Other Parameters:</p> Name Type Description <code>trgw</code> <code>int</code> <p>the width of the target/desired stimuli.</p> <code>trgh</code> <code>int</code> <p>the height of the target/desired stimuli.</p> <code>ratio</code> <code>float</code> <p>the ratio to resize the image. Defaults to 0.</p> <code>newfolder</code> <code>str</code> <p>the folder to save the resized image. Defaults to None.</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>def resize(self, **kwargs):\n    \"\"\"Resize the image.\n\n    Other Parameters\n    ----------------\n    trgw : int\n        the width of the target/desired stimuli.\n    trgh : int\n        the height of the target/desired stimuli.\n    ratio : float\n        the ratio to resize the image. Defaults to 0.\n    newfolder : str\n        the folder to save the resized image. Defaults to None.\n    \"\"\"\n    # resize the image\n    defaultKwargs = {'trgw': None, 'trgh': None, 'ratio':0, 'newfolder':None}\n    kwargs = {**defaultKwargs, **kwargs}\n\n    if (kwargs['trgw'] is not None) &amp; (kwargs['trgh'] is not None):\n        (w, h) = (kwargs['trgw'], kwargs['trgh'])\n    elif (kwargs['trgw'] is not None) &amp; (kwargs['trgh'] is None):\n        w = kwargs['trgw']\n        h = int(w*self._h/self._w)\n    elif (kwargs['trgw'] is None) &amp; (kwargs['trgh'] is not None): \n        h = kwargs['trgh']\n        w = int(h*self._w/self._h)\n    elif kwargs['ratio']&gt;0:\n        w = int(self._w*kwargs['ratio'])\n        h = int(self._h*kwargs['ratio'])\n    else:\n        raise 'Cannot determine the desired dimentions...'\n\n    kwargs['size'] = (w,h)\n    if (kwargs['newfolder'] is None):\n        newfolder = str(w)+'_'+str(h)\n    else:\n        newfolder = kwargs['newfolder']\n\n    [kwargs.pop(k) for k in defaultKwargs.keys()] # remove unused keys\n\n    # save re-sized images (information)\n    self._repil(self.pil.resize(**kwargs))\n    self._newfilename(newfolder=newfolder)\n</code></pre>"},{"location":"api/api/#pyfaceimage.image.rotate","title":"<code>rotate(angle=180)</code>","text":"<p>Rotate the image unclockwise.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>the angle to rotate the image. Defaults to 180.</p> <code>180</code> Source code in <code>pyfaceimage/im.py</code> <pre><code>def rotate(self, angle=180):\n    \"\"\"Rotate the image unclockwise.\n\n    Parameters\n    ----------\n    angle : float\n        the angle to rotate the image. Defaults to 180.\n    \"\"\"\n    # rotate the image\n    self._repil(self.pil.rotate(angle))\n</code></pre>"},{"location":"api/api/#pyfaceimage.image.save","title":"<code>save(newfname='', newfolder='', addfn=True, **kwargs)</code>","text":"<p>Save the image PIL.</p> <p>Parameters:</p> Name Type Description Default <code>newfname</code> <code>str</code> <p>strings to be added before the extension, by default ''</p> <code>''</code> <code>newfolder</code> <code>str</code> <p>folder name to replace the global directory or the last directory level, by default ''</p> <code>''</code> <code>addfn</code> <code>bool</code> <p>whether to add the newfname to the the original fname (instead of replacing it), by default True</p> <code>True</code> <code>kwargs</code> <code>dict</code> <p>keyword arguments for matplotlib.pyplot.imsave(), by default {}</p> <code>{}</code> Source code in <code>pyfaceimage/im.py</code> <pre><code>def save(self, newfname='', newfolder='', addfn=True, **kwargs):\n    \"\"\"Save the image PIL.\n\n    Parameters\n    ----------\n    newfname : str, optional\n        strings to be added before the extension, by default ''\n    newfolder : str, optional\n        folder name to replace the global directory or the last directory level, by default ''\n    addfn : bool, optional\n        whether to add the newfname to the the original fname (instead of replacing it), by default True\n    kwargs : dict, optional\n        keyword arguments for matplotlib.pyplot.imsave(), by default {}\n    \"\"\"\n    # update the filename\n    self._newfilename(newfname, newfolder, addfn=addfn)\n\n    # make dir(s)\n    if not os.path.isdir(os.path.dirname(self.filename)):\n        os.makedirs(os.path.dirname(self.filename))\n\n    # use PIL.Image.save() to save .pil    \n    self.pil.save(self.filename, format=None, **kwargs)\n    self._isfile = os.path.isfile(self.filename)\n</code></pre>"},{"location":"api/api/#pyfaceimage.image.show","title":"<code>show()</code>","text":"<p>Show the image PIL.</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>def show(self):\n    \"\"\"Show the image PIL.\n    \"\"\"\n    # for debugging purpose (check the PIL)\n    self.pil.show()\n</code></pre>"},{"location":"api/api/#pyfaceimage.image.stdmat","title":"<code>stdmat(clip=2, matkey='mat')</code>","text":"<p>Standardize the image with the desired Root-Mean-Square contrast or <code>outrange</code>. This function applies to self.</p> <p>Parameters:</p> Name Type Description Default <code>clip</code> <code>float</code> <p>the desired clip value. Defaults to 2.</p> <code>2</code> <code>matkey</code> <code>str</code> <p>the key/name of the matrix to be standardized. Default to 'mat'.</p> <code>'mat'</code> Source code in <code>pyfaceimage/im.py</code> <pre><code>def stdmat(self, clip=2, matkey='mat'):\n    \"\"\"Standardize the image with the desired Root-Mean-Square contrast or `outrange`. This function applies to self.\n\n    Parameters\n    ----------\n    clip : float, optional\n        the desired clip value. Defaults to 2.\n    matkey : str, optional\n        the key/name of the matrix to be standardized. Default to 'mat'.\n    \"\"\"\n\n    mat = getattr(self, matkey)\n    mat_out = self._stdmat(mat, clip=clip)\n    setattr(self, matkey, mat_out)\n\n    # update the image matrix to self\n    self.remat(mat_out.astype(dtype=np.uint8))\n</code></pre>"},{"location":"api/api/#pyfaceimage.image.torgba","title":"<code>torgba()</code>","text":"<p>Convert the image to RGBA.</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>def torgba(self):\n    \"\"\"Convert the image to RGBA.\n    \"\"\"\n    # convert pil to RGBA and save in .mat\n    if len(self.mat.shape)==2: # Gray\n        self.mat = self.mat[..., np.newaxis]\n    assert len(self.mat.shape)==3\n\n    nchan = self.mat.shape[2]\n    if nchan==1: # Gray 'L'\n        rgbmat = np.repeat(self.mat, 3, axis=2) # RGB\n        alphavalue = 255 if rgbmat.max()&gt;1 else 1\n        amat = np.ones_like(rgbmat[:,:,0],dtype=np.uint8)*alphavalue # alpha\n    elif nchan==2: # Gray 'LA'\n        rgbmat = np.repeat(self.mat[:,:,0:1], 3, axis=2) # RGB\n        amat = self.mat[:,:,-1] # alpha\n    elif nchan==3: # RGB\n        rgbmat = self.mat # RGB\n        alphavalue = 255 if rgbmat.max()&gt;1 else 1\n        amat = np.ones_like(rgbmat[:,:,0],dtype=np.uint8)*alphavalue # alpha\n    elif nchan==4: # RGBA\n        rgbmat = self.mat[:,:,0:3]\n        amat = self.mat[:,:,-1]\n\n    self.rgbmat = rgbmat\n    self.amat = amat\n    self.remat(np.concatenate((rgbmat, amat[..., np.newaxis]), axis=2), 'RGBA')\n</code></pre>"},{"location":"api/api/#pyfaceimage.image.touch","title":"<code>touch(touchfolder='')</code>","text":"<p>Touch a new empty file.</p> <p>Parameters:</p> Name Type Description Default <code>touchfolder</code> <code>str</code> <p>folder name to replace the global directory or the last directory level, by default ''</p> <code>''</code> Source code in <code>pyfaceimage/im.py</code> <pre><code>def touch(self, touchfolder=''):\n    \"\"\"Touch a new empty file.\n\n    Parameters\n    ----------\n    touchfolder : str, optional\n        folder name to replace the global directory or the last directory level, by default ''\n    \"\"\"\n    # update the directory\n    self._newfilename(newfolder=touchfolder)\n\n    if self.isfile:\n        # throw warnings if file exists\n        warnings.warn(\"The file named '%s' already exists...\" % self.filename)\n    else:\n        # make dir if needed\n        if not os.path.isdir(self._dirname):\n            os.makedirs(self._dirname)\n        # touch the file\n        Path(self.filename).touch()\n</code></pre>"},{"location":"api/api/#pyfaceimage.image.update_fninfo","title":"<code>update_fninfo(filename, newfn=True)</code>","text":"<p>Set the image filename.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>path and image filename.</p> required <code>newfn</code> <code>bool</code> <p>whether <code>filename</code> is a new file name, by default True. So it will not check whether the file exists.</p> <code>True</code> Source code in <code>pyfaceimage/im.py</code> <pre><code>def update_fninfo(self, filename, newfn=True):\n    \"\"\"Set the image filename.\n\n    Parameters\n    ----------\n    filename : str\n        path and image filename.\n    newfn : bool, optional\n        whether `filename` is a new file name, by default True. So it will not check whether the file exists.\n    \"\"\"\n    if newfn &amp; os.path.isfile(filename):\n        # throw warning if filename is newly created and exists\n        warnings.warn(f\"The file named '{filename}' already exists...\")\n    elif not newfn:\n        # throw error if filename is not new and does not exist\n        assert os.path.isfile(filename) | (not bool(filename)), f'Cannot find {filename}...'\n\n    self._filename = filename\n    self._fname = os.path.basename(filename)\n    self._fnonly = \".\".join(os.path.splitext(self._fname)[0:-1])\n    self._ext = os.path.splitext(self._fname)[-1]\n    self._dirname = os.path.dirname(filename)\n    self._isfile = os.path.isfile(filename)\n</code></pre>"},{"location":"api/api/#pyfaceimage.image.updateext","title":"<code>updateext(ext)</code>","text":"<p>Update the filename information.</p> <p>Parameters:</p> Name Type Description Default <code>ext</code> <code>str</code> <p>the new extension.</p> required Source code in <code>pyfaceimage/im.py</code> <pre><code>def updateext(self, ext):\n    \"\"\"Update the filename information.\n\n    Parameters\n    ----------\n    ext : str\n        the new extension.\n    \"\"\"\n    if ext[0] != '.':\n        ext = '.'+ext\n    self.update_fninfo(self._dirname + os.sep + self._fnonly + ext)\n</code></pre>"},{"location":"api/api/#pyfaceimage.addbg","title":"<code>addbg(imdict, **kwargs)</code>","text":"<p>Add background to the image.</p> <p>Parameters:</p> Name Type Description Default <code>imdict</code> <code>dict</code> <p>A dictionary of image() instances.</p> required <p>Other Parameters:</p> Name Type Description <code>bgcolor</code> <code>tuple</code> <p>the background color. Defaults to (255,255,255).</p> Source code in <code>pyfaceimage/__init__.py</code> <pre><code>def addbg(imdict, **kwargs):\n    \"\"\"Add background to the image.\n\n    Parameters\n    ----------\n    imdict : dict\n        A dictionary of image() instances.\n\n    Other Parameters\n    ----------------\n    bgcolor : tuple\n        the background color. Defaults to (255,255,255).\n    \"\"\"\n    [v.addbg(**kwargs) for v in imdict.values()]\n</code></pre>"},{"location":"api/api/#pyfaceimage.adjust","title":"<code>adjust(imdict, **kwargs)</code>","text":"<p>Adjust the luminance and contrast of the image.</p> <p>Parameters:</p> Name Type Description Default <code>imdict</code> <code>dict</code> <p>A dictionary of image() instances.</p> required <p>Other Parameters:</p> Name Type Description <code>lum</code> <code>float</code> <p>the desired mean of the image. Defaults to None.</p> <code>rms</code> <code>float</code> <p>the desired standard deviation of the image. Defaults to None.</p> <code>mask</code> <code>array</code> <p>the mask for the image. Defaults to None.</p> Source code in <code>pyfaceimage/__init__.py</code> <pre><code>def adjust(imdict, **kwargs):\n    \"\"\"Adjust the luminance and contrast of the image.\n\n    Parameters\n    ----------\n    imdict : dict\n        A dictionary of image() instances.\n\n    Other Parameters\n    ----------------\n    lum : float\n        the desired mean of the image. Defaults to None.\n    rms : float\n        the desired standard deviation of the image. Defaults to None.\n    mask : np.array\n        the mask for the image. Defaults to None.\n    \"\"\"\n    [v.adjust(**kwargs) for v in imdict.values()]\n</code></pre>"},{"location":"api/api/#pyfaceimage.concateims","title":"<code>concateims(imdict, pairstyle='perm', sep='/', **kwargs)</code>","text":"<p>Concatenate images in the dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>imdict</code> <code>dict</code> <p>A dictionary of image() instances.</p> required <code>pairstyle</code> <code>str</code> <p>the style of the pairs. Defaults to \"perm\". Options are \"perm\" (<code>itertools.permutation</code>), \"comb\" (<code>itertools.combination</code>), \"comb_repl\" (<code>itertools.combinations_with_replacement</code>), \"prod\" (<code>itertools.product</code>) and \"itself\" (concatenate itself).</p> <code>'perm'</code> <code>sep</code> <code>str</code> <p>a string to be used to concatnate the subdirectory and image name, which is used as the key for flattening the dictionary, by default '/'. If sep is None, the dictionary will not be flatten.</p> <code>'/'</code> <p>Other Parameters:</p> Name Type Description <code>axis</code> <code>int</code> <p>the axis along which the images are concatenated. Defaults to 1, i.e., horizontally.</p> <code>sep</code> <code>str</code> <p>the separator between the two images. Defaults to \"-\".</p> <code>padvalue</code> <code>int</code> <p>padding value. Defaults to 0 (show as transparent if alpha channel exists).</p> <p>Returns:</p> Type Description <code>A dictionary of im.image() instance</code> <p>the concatenated image.</p> Source code in <code>pyfaceimage/__init__.py</code> <pre><code>def concateims(imdict, pairstyle=\"perm\", sep='/', **kwargs):\n    \"\"\"Concatenate images in the dictionary.\n\n    Parameters\n    ----------\n    imdict : dict\n        A dictionary of image() instances.\n    pairstyle : str, optional\n        the style of the pairs. Defaults to \"perm\". Options are \"perm\" (`itertools.permutation`), \"comb\" (`itertools.combination`), \"comb_repl\" (`itertools.combinations_with_replacement`), \"prod\" (`itertools.product`) and \"itself\" (concatenate itself).\n    sep : str, optional\n        a string to be used to concatnate the subdirectory and image name, which is used as the key for flattening the dictionary, by default '/'. If sep is None, the dictionary will not be flatten.\n\n    Other Parameters\n    ----------------\n    axis : int\n        the axis along which the images are concatenated. Defaults to 1, i.e., horizontally.\n    sep : str\n        the separator between the two images. Defaults to \"-\".\n    padvalue : int\n        padding value. Defaults to 0 (show as transparent if alpha channel exists).\n\n    Returns\n    -------\n    A dictionary of im.image() instance\n        the concatenated image.\n    \"\"\"\n    # make sure the dictionary is flatten\n    if len(set([im.group for im in imdict.values()])) &gt; 1 and bool(sep):\n        imdict_nested = _nested(imdict, sep=sep)\n\n        concatedict_nested = {}\n        for k,v in imdict_nested.items():\n            concatedict_nested[k] = _concateims(v, pairstyle=pairstyle, **kwargs)\n\n        concatedict = _flatten(concatedict_nested, sep=sep)\n\n    else:\n        concatedict = _concateims(imdict, pairstyle=pairstyle, **kwargs)\n\n    return concatedict\n</code></pre>"},{"location":"api/api/#pyfaceimage.concatenate","title":"<code>concatenate(im1, im2, axis=1, sep='-', padval=0)</code>","text":"<p>Concatenate two images along the specified axis.</p> <p>Parameters:</p> Name Type Description Default <code>im1</code> <code>im.image() instance</code> <p>the first image.</p> required <code>im2</code> <code>im.image() instance</code> <p>the second image.</p> required <p>Other Parameters:</p> Name Type Description <code>axis</code> <code>int</code> <p>the axis along which the images are concatenated. Defaults to 1, i.e. horizontally.</p> <code>sep</code> <code>str</code> <p>the separator between the two images. Defaults to \"-\".</p> <code>padval</code> <code>int</code> <p>the value to pad the images. Defaults to 0.</p> <p>Returns:</p> Type Description <code>im.image() instance</code> <p>the concatenated image.</p> Source code in <code>pyfaceimage/multim.py</code> <pre><code>def concatenate(im1, im2, axis=1, sep=\"-\", padval=0):\n    \"\"\"Concatenate two images along the specified axis.\n\n    Parameters\n    ----------\n    im1 : im.image() instance\n        the first image.\n    im2 : im.image() instance\n        the second image.\n\n    Other Parameters\n    ----------------\n    axis : int\n        the axis along which the images are concatenated. Defaults to 1, i.e. horizontally.\n    sep : str\n        the separator between the two images. Defaults to \"-\".\n    padval : int\n        the value to pad the images. Defaults to 0.\n\n    Returns\n    -------\n    im.image() instance\n        the concatenated image.\n    \"\"\"\n\n    im = im1.deepcopy()\n\n    # pad the images if necessary\n    if axis==0:\n        if im.w&gt;im2.w:\n            im2.pad(trgw=im.w, padval=padval)\n        elif im.w&lt;im2.w:\n            im.pad(trgw=im2.w, padval=padval)\n    elif axis==1:\n        if im.h&gt;im2.h:\n            im2.pad(trgh=im.h, padval=padval)\n        elif im.h&lt;im2.h:\n            im.pad(trgh=im2.h, padval=padval)\n\n    # concatenate the images\n    if axis==0:\n        im.pil = Image.fromarray(np.concatenate((im.pil, im2.pil), axis=0))\n    elif axis==1:\n        im.pil = Image.fromarray(np.concatenate((im.pil, im2.pil), axis=1))\n    im._repil(im.pil)\n\n    # update the filename\n    newfilename = im.fnonly+sep+im2.fnonly\n    im._newfilename(newfname=newfilename, addfn=False)\n\n    return (im, newfilename)\n</code></pre>"},{"location":"api/api/#pyfaceimage.cropoval","title":"<code>cropoval(imdict, **kwargs)</code>","text":"<p>Crop the image with an oval shape.</p> <p>Parameters:</p> Name Type Description Default <code>imdict</code> <code>dict</code> <p>A dictionary of image() instances.</p> required <p>Other Parameters:</p> Name Type Description <code>radius</code> <code>tuple</code> <pre><code>the radius of the oval. Defaults to (100,128).\n</code></pre> <p>position : tuple, optional     the position of the oval. Defaults to None. bgcolor : tuple, optional     the background color. Defaults to None. For instance, if bgcolor is (255, 255, 255, 255), the output image is not transparent; if bgcolor is (255, 255, 255, 0), the output image is transparent. crop : bool, optional     whether to crop the image to the oval (true) or keep its original dimension. Defaults to True.</p> Source code in <code>pyfaceimage/__init__.py</code> <pre><code>def cropoval(imdict, **kwargs):\n    \"\"\"Crop the image with an oval shape.\n\n    Parameters\n    ----------\n    imdict : dict\n        A dictionary of image() instances.\n\n    Other Parameters\n    ----------------\n    radius : tuple, optional\n            the radius of the oval. Defaults to (100,128).\n        position : tuple, optional\n            the position of the oval. Defaults to None.\n        bgcolor : tuple, optional\n            the background color. Defaults to None. For instance, if bgcolor is (255, 255, 255, 255), the output image is not transparent; if bgcolor is (255, 255, 255, 0), the output image is transparent.\n        crop : bool, optional\n            whether to crop the image to the oval (true) or keep its original dimension. Defaults to True.\n    \"\"\"\n    [v.cropoval(**kwargs) for v in imdict.values()]\n</code></pre>"},{"location":"api/api/#pyfaceimage.croprect","title":"<code>croprect(imdict, **kwargs)</code>","text":"<p>Crop the image with a rectangle box.</p> <p>Parameters:</p> Name Type Description Default <code>imdict</code> <code>dict</code> <p>A dictionary of image() instances.</p> required <p>Other Parameters:</p> Name Type Description <code>box</code> <code>tuple</code> <p>the box to crop the image. Defaults to None.</p> Source code in <code>pyfaceimage/__init__.py</code> <pre><code>def croprect(imdict, **kwargs):\n    \"\"\"Crop the image with a rectangle box.\n\n    Parameters\n    ----------\n    imdict : dict\n        A dictionary of image() instances.\n\n    Other Parameters\n    ----------------\n    box : tuple\n        the box to crop the image. Defaults to None.\n    \"\"\"\n    [v.croprect(**kwargs) for v in imdict.values()]\n</code></pre>"},{"location":"api/api/#pyfaceimage.deepcopy","title":"<code>deepcopy(imdict)</code>","text":"<p>Deep copy the dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>imdict</code> <code>dict</code> <p>A dictionary of image() instances.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A deep copied dictionary of images.</p> Source code in <code>pyfaceimage/__init__.py</code> <pre><code>def deepcopy(imdict):\n    \"\"\"Deep copy the dictionary.\n\n    Parameters\n    ----------\n    imdict : dict\n        A dictionary of image() instances.\n\n    Returns\n    -------\n    dict\n        A deep copied dictionary of images.\n    \"\"\"\n    return copy.deepcopy(imdict)\n</code></pre>"},{"location":"api/api/#pyfaceimage.dir","title":"<code>dir(path=os.getcwd(), imwc='*.png', read=True, sep='/')</code>","text":"<p>List all images in the path and subdirs. Please make sure none of the subdirectories is named as 'path'.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>path to the directory where the images are stored, by default os.getcwd()</p> <code>getcwd()</code> <code>imwc</code> <code>str</code> <p>wildcard to identify images (but not the subdirectories), by default '*.png'</p> <code>'*.png'</code> <code>read</code> <code>bool</code> <p>whether read the images (more see im.image()), by default True</p> <code>True</code> <code>sep</code> <p>a string to be used to concatnate the subdirectory and image name, which is used as the key for flattening the dictionary, by default '/'</p> <code>'/'</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of image() instances in the path and subdirs.</p> Source code in <code>pyfaceimage/__init__.py</code> <pre><code>def dir(path=os.getcwd(), imwc='*.png', read=True, sep='/'):\n    \"\"\"List all images in the path and subdirs. Please make sure none of the subdirectories is named as 'path'.\n\n    Parameters\n    ----------\n    path : str, optional\n        path to the directory where the images are stored, by default os.getcwd()\n    imwc : str, optional\n        wildcard to identify images (but not the subdirectories), by default '*.png'\n    read : bool, optional\n        whether read the images (more see im.image()), by default True\n    sep: str, optional\n        a string to be used to concatnate the subdirectory and image name, which is used as the key for flattening the dictionary, by default '/'\n\n    Returns\n    -------\n    dict\n        A dictionary of image() instances in the path and subdirs.\n    \"\"\"\n\n    # list all files in the path\n    imdict_root = _dir(path, imwc, read)\n    [im._setgroup('path') for im in imdict_root.values()] # update group info as 'path'    \n\n    # list all dirs in the subdirectories\n    subdirs = [d for d in os.listdir(path) \n               if os.path.isdir(os.path.join(path,d))] # is a dir\n    assert 'path' not in subdirs, f'\"path\" is not a valid subdir name...'\n    imdict = {sub:_dir(path=os.path.join(path, sub), imwc=imwc, read=read) \n                  for sub in subdirs}\n\n    # add images in path to the dictionary\n    if bool(imdict_root):\n        imdict['path'] = imdict_root \n\n    # flatten the dictionary\n    if bool(sep): imdict = _flatten(imdict, sep=sep)      \n\n    # set the global path\n    [im._setgpath(path) for im in imdict.values()]\n\n    return imdict\n</code></pre>"},{"location":"api/api/#pyfaceimage.exp_design_builder","title":"<code>exp_design_builder(exp_conditions, rand_block=None, sort_block=None, is_rand=True)</code>","text":"<p>Generate a full factorial design matrix based on the input conditions.</p> <pre><code>Parameters\n</code></pre> <pre><code>exp_conditions : list\n    A list of tuples, each containing a condition name and a list of levels for that condition, e.g., `[(\"IV1\", [1, 2, 3]), (\"IV2\", [1, 2, 3, 4])]`.\nrand_block : str list, optional\n    A list of condition names to randomize by block. The latter columns/blocks will be randomized within the former columns/blocks. by default None\nsort_block : str list, optional\n    A list of condition names to sort by block, by default None\nis_rand : bool, optional\n    Whether to randomize the design matrix, by default True\n</code></pre> <pre><code>Returns\n</code></pre> <pre><code>pd.DataFrame\n    A pandas DataFrame containing the full factorial design matrix. Each row represents a trial (Usage: `design.iloc[trial_index]['IV1']`).\nint\n    The number of trials in the design matrix.\nint\n    The number of blocks in the design matrix.\n</code></pre> <pre><code>Raises\n</code></pre> <pre><code>ValueError\n    `rand_block` and `sort_block` must be available in the condition names in `exp`_conditions`.\nValueError\n    `rand_block` and `sort_block` must not overlap.\n</code></pre> <pre><code>Examples\n</code></pre> <pre><code>&gt;&gt;&gt; exp_conditions = [(\"IV1\", [1, 2, 3]),\n                      (\"IV2\", [1, 2, 3, 4]),\n                      (\"IV3\", range(0,5)), # equivalent to [0, 1, 2, 3, 4]\n                      (\"blockNumber\", [1, 2])]\n&gt;&gt;&gt; rand_block = [\"IV3\", \"IV2\"]\n&gt;&gt;&gt; sort_block = [\"blockNumber\"]\n&gt;&gt;&gt; design = exp_design_builder(exp_conditions, rand_block, sort_block)\n&gt;&gt;&gt; print(design)\n&gt;&gt;&gt; print(f\"Total trials: {n_trials}\n</code></pre> <p>Total blocks: {n_blocks}\")</p> Source code in <code>pyfaceimage/utilities.py</code> <pre><code>def exp_design_builder(exp_conditions, rand_block=None, sort_block=None, is_rand=True):\n    \"\"\"Generate a full factorial design matrix based on the input conditions.\n\n    Parameters\n    ----------\n    exp_conditions : list\n        A list of tuples, each containing a condition name and a list of levels for that condition, e.g., `[(\"IV1\", [1, 2, 3]), (\"IV2\", [1, 2, 3, 4])]`.\n    rand_block : str list, optional\n        A list of condition names to randomize by block. The latter columns/blocks will be randomized within the former columns/blocks. by default None\n    sort_block : str list, optional\n        A list of condition names to sort by block, by default None\n    is_rand : bool, optional\n        Whether to randomize the design matrix, by default True\n\n    Returns\n    -------\n    pd.DataFrame\n        A pandas DataFrame containing the full factorial design matrix. Each row represents a trial (Usage: `design.iloc[trial_index]['IV1']`).\n    int\n        The number of trials in the design matrix.\n    int\n        The number of blocks in the design matrix.\n\n    Raises\n    ------\n    ValueError\n        `rand_block` and `sort_block` must be available in the condition names in `exp`_conditions`.\n    ValueError\n        `rand_block` and `sort_block` must not overlap.\n\n    Examples\n    --------\n    &gt;&gt;&gt; exp_conditions = [(\"IV1\", [1, 2, 3]),\n                          (\"IV2\", [1, 2, 3, 4]),\n                          (\"IV3\", range(0,5)), # equivalent to [0, 1, 2, 3, 4]\n                          (\"blockNumber\", [1, 2])]\n    &gt;&gt;&gt; rand_block = [\"IV3\", \"IV2\"]\n    &gt;&gt;&gt; sort_block = [\"blockNumber\"]\n    &gt;&gt;&gt; design = exp_design_builder(exp_conditions, rand_block, sort_block)\n    &gt;&gt;&gt; print(design)\n    &gt;&gt;&gt; print(f\"Total trials: {n_trials} \\nTotal blocks: {n_blocks}\")\n    \"\"\"\n    # Validate input conditions\n    cond_names = [cond[0] for cond in exp_conditions]\n    levels_per_cond = [len(cond[1]) for cond in exp_conditions]\n\n    # Ensure rand_block and sort_block are lists of indices\n    def _process_block(block, var_name):\n        if isinstance(block, list):\n            block_indices = [cond_names.index(name) for name in block]\n        elif block is None:\n            block_indices = []\n        else:\n            raise ValueError(f\"{var_name} must be a list of condition names or None.\")\n        return block_indices\n\n    rand_block_indices = _process_block(rand_block, \"rand_block\")\n    sort_block_indices = _process_block(sort_block, \"sort_block\")\n\n    if set(rand_block_indices) &amp; set(sort_block_indices):\n        raise ValueError(\"rand_block and sort_block must not overlap.\")\n\n    # Generate full factorial design\n    design_matrix = np.array(list(itertools.product(*[range(1, levels + 1) for levels in levels_per_cond])))\n    # Randomize design if requested\n    if is_rand:\n        np.random.shuffle(design_matrix)\n\n    # Randomize design by blocks (rand_block)\n    rand_block_indices = sort_block_indices + rand_block_indices\n    if rand_block_indices:\n        for bloidx in range(len(rand_block_indices),0,-1):\n\n            thisidx = rand_block_indices[0:bloidx]\n\n            # Identify unique blocks\n            tmp, block_indices = np.unique(design_matrix[:, thisidx], axis=0, return_inverse=True)\n\n            # Shuffle the block order\n            final_indices = np.argsort(np.random.permutation(np.unique(block_indices)))\n            design_matrix = design_matrix[np.concatenate([np.where(block_indices == i)[0] for i in final_indices])]    \n\n    # Sort the design matrix by sort_block\n    if sort_block_indices:\n        design_matrix = design_matrix[np.lexsort([design_matrix[:, idx] for idx in reversed(sort_block_indices)])]\n\n    # Replace indices with actual levels\n    design = pd.DataFrame({\n        cond_names[i]: [exp_conditions[i][1][level - 1] for level in design_matrix[:, i]]\n        for i in range(len(exp_conditions))\n    })\n\n    # n_trials = len(design)\n    # n_blocks = np.prod([len(exp_conditions[idx][1]) for idx in rand_block_indices])\n\n    return design\n</code></pre>"},{"location":"api/api/#pyfaceimage.filter","title":"<code>filter(imdict, **kwargs)</code>","text":"<p>Apply spatial frequency filter to the image. It is suggested to use this function to generate the filtered images and then standarize them with <code>standardize(imdict, clip=2)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>imdict</code> <code>dict</code> <p>A dictionary of image() instances.</p> required <p>Other Parameters:</p> Name Type Description <code>filter</code> <code>str</code> <pre><code>the filter type. Defaults to 'low'. Other option is 'high'.\n</code></pre> <code>vapi</code> <code>int</code> <p>visual angle per image. Defaults to 5.</p> <code>cutoff</code> <code>int</code> <p>cycles per image (width) or cycles per degree if vapi&gt;0. Defaults to 8.</p> <code>clip</code> <code>int</code> <p>the clip value. Defaults to 0, i.e., no clipping or normalization will be applied. If not 0, standardization will be applied to each image (i.e., its LSF, HSF, FS versions) separately.</p> Source code in <code>pyfaceimage/__init__.py</code> <pre><code>def filter(imdict, **kwargs):\n    \"\"\"Apply spatial frequency filter to the image. It is suggested to use this function to generate the filtered images and then standarize them with `standardize(imdict, clip=2)`.\n\n    Parameters\n    ----------\n    imdict : dict\n        A dictionary of image() instances.\n\n    Other Parameters\n    ----------------\n    filter : str\n            the filter type. Defaults to 'low'. Other option is 'high'.\n    vapi : int\n        visual angle per image. Defaults to 5.\n    cutoff : int\n        cycles per image (width) or cycles per degree if vapi&gt;0. Defaults to 8.\n    clip : int\n        the clip value. Defaults to 0, i.e., no clipping or normalization will be applied. If not 0, standardization will be applied to each image (i.e., its LSF, HSF, FS versions) separately.\n    \"\"\"\n    # apply the filter to each image (but without standardization)  \n    [v.filter(**kwargs) for v in imdict.values()]\n</code></pre>"},{"location":"api/api/#pyfaceimage.grayscale","title":"<code>grayscale(imdict, **kwargs)</code>","text":"<p>Convert the image to gray-scale.</p> <p>Parameters:</p> Name Type Description Default <code>imdict</code> <code>dict</code> <p>A dictionary of image() instances.</p> required Source code in <code>pyfaceimage/__init__.py</code> <pre><code>def grayscale(imdict, **kwargs):\n    \"\"\"Convert the image to gray-scale.\n\n    Parameters\n    ----------\n    imdict : dict\n        A dictionary of image() instances.\n    \"\"\"\n    [v.grayscale(**kwargs) for v in imdict.values()] \n</code></pre>"},{"location":"api/api/#pyfaceimage.imsave","title":"<code>imsave(imdict, **kwargs)</code>","text":"<p>Save the image mat.</p> <p>Parameters:</p> Name Type Description Default <code>newfname</code> <code>str</code> <p>strings to be added before the extension, by default ''</p> required <code>newfolder</code> <code>str</code> <p>folder name to replace the global directory or the last directory level, by default ''</p> required <code>addfn</code> <code>bool</code> <p>whether to add the newfname to the the original fname (instead of replacing it), by default True</p> required <code>kwargs</code> <code>dict</code> <p>keyword arguments for matplotlib.pyplot.imsave(), by default {}</p> <code>{}</code> Source code in <code>pyfaceimage/__init__.py</code> <pre><code>def imsave(imdict, **kwargs):\n    \"\"\"Save the image mat.\n\n    Parameters\n    ----------\n    newfname : str, optional\n        strings to be added before the extension, by default ''\n    newfolder : str, optional\n        folder name to replace the global directory or the last directory level, by default ''\n    addfn : bool, optional\n        whether to add the newfname to the the original fname (instead of replacing it), by default True\n    kwargs : dict, optional\n        keyword arguments for matplotlib.pyplot.imsave(), by default {}\n    \"\"\"\n    [v.imsave(**kwargs) for v in imdict.values()]\n</code></pre>"},{"location":"api/api/#pyfaceimage.mk_cf_design","title":"<code>mk_cf_design(cfs, **kwargs)</code>","text":"<p>Make a list, which should work in PychoPy or other software, for the composite face task.</p> <p>Parameters:</p> Name Type Description Default <code>cfs</code> <code>(int, dict, list)</code> <p>the number of composite faces (e.g., <code>4</code>), a dictionary of composite faces (e.g., <code>imdict</code>), or a list of composite face names (e.g., <code>['AB', 'CD', 'EF', 'GH']</code>).</p> required <p>Other Parameters:</p> Name Type Description <code>isTopCued</code> <code>list</code> <p>whether the top half is cued. Defaults to <code>[1]</code>.</p> <code>isCongruent</code> <code>list</code> <p>whether the top and bottom halves are congruent. Defaults to <code>[0, 1]</code>.</p> <code>isAligned</code> <code>list</code> <p>whether the top and bottom halves are aligned. Defaults to <code>[0, 1]</code>.</p> <code>isCuedSame</code> <code>list</code> <p>whether the cued half is the same as the target half. Defaults to <code>[0, 1]</code>.</p> <code>studyIsCued</code> <code>int</code> <p>whether the study faces are cued. Defaults to <code>0</code>.</p> <code>studyIsAligned</code> <code>int</code> <p>whether the study faces are always aligned. Defaults to <code>1</code>.</p> <code>faceselector</code> <code>list</code> <p>the face selector for the composite faces. Defaults to the default selector (<code>default_selector</code>).</p> <code>cue_str</code> <code>list</code> <p>the cue strings. Defaults to <code>['bot', 'top']</code>.</p> <code>con_str</code> <code>list</code> <p>the congruency strings. Defaults to <code>['inc', 'con']</code>.</p> <code>ali_str</code> <code>list</code> <p>the alignment strings. Defaults to <code>['mis', 'ali']</code>.</p> <code>ca_str</code> <code>list</code> <p>the correct answer strings. Defaults to <code>['dif', 'sam']</code>.</p> <code>task</code> <code>str</code> <p>the task name. Defaults to <code>'CF'</code>.</p> <code>cf_group</code> <code>str</code> <p>the composite face group name. Defaults to <code>''</code>.</p> <code>cf_sep</code> <code>str</code> <p>the separator within the composite face names. Defaults to <code>'_'</code>.</p> <code>cfs_sep</code> <code>str</code> <p>the separator between the study and test faces. Defaults to <code>''</code>.</p> <code>showlevels</code> <code>bool</code> <p>whether to show the levels of the independent variables. Defaults to <code>False</code>.</p> <code>is_rand</code> <code>bool</code> <p>whether to randomize the design matrix. Defaults to <code>True</code>.</p> <code>face_order</code> <code>str</code> <p>Whether to randomize or order the original face names. Defaults to <code>'sort'</code>. Other options are <code>'rand'</code>.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>a pandas DataFrame containing the composite face task design matrix.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; design = mkcflist(4)\n&gt;&gt;&gt; design = mkcflist(['AB', 'CD', 'EF', 'GH'])\n&gt;&gt;&gt; design.to_csv('cf_design.csv', index=False) # save the design matrix to a csv file\n</code></pre> Source code in <code>pyfaceimage/exps.py</code> <pre><code>def mk_cf_design(cfs, **kwargs):\n    \"\"\"Make a list, which should work in PychoPy or other software, for the composite face task.\n\n    Parameters\n    ----------\n    cfs : int, dict, list\n        the number of composite faces (e.g., `4`), a dictionary of composite faces (e.g., `imdict`), or a list of composite face names (e.g., `['AB', 'CD', 'EF', 'GH']`).\n\n    Other Parameters\n    ----------------\n    isTopCued : list\n        whether the top half is cued. Defaults to `[1]`.\n    isCongruent : list\n        whether the top and bottom halves are congruent. Defaults to `[0, 1]`.\n    isAligned : list\n        whether the top and bottom halves are aligned. Defaults to `[0, 1]`.\n    isCuedSame : list\n        whether the cued half is the same as the target half. Defaults to `[0, 1]`.\n    studyIsCued : int\n        whether the study faces are cued. Defaults to `0`.\n    studyIsAligned : int\n        whether the study faces are always aligned. Defaults to `1`.\n    faceselector : list\n        the face selector for the composite faces. Defaults to the default selector (`default_selector`).\n    cue_str : list\n        the cue strings. Defaults to `['bot', 'top']`.\n    con_str : list\n        the congruency strings. Defaults to `['inc', 'con']`.\n    ali_str : list\n        the alignment strings. Defaults to `['mis', 'ali']`.\n    ca_str : list\n        the correct answer strings. Defaults to `['dif', 'sam']`.\n    task : str\n        the task name. Defaults to `'CF'`.\n    cf_group : str\n        the composite face group name. Defaults to `''`.\n    cf_sep : str\n        the separator within the composite face names. Defaults to `'_'`.\n    cfs_sep : str\n        the separator between the study and test faces. Defaults to `''`.\n    showlevels : bool\n        whether to show the levels of the independent variables. Defaults to `False`.\n    is_rand : bool\n        whether to randomize the design matrix. Defaults to `True`.\n    face_order : str\n        Whether to randomize or order the original face names. Defaults to `'sort'`. Other options are `'rand'`.\n\n    Returns\n    -------\n    pd.DataFrame\n        a pandas DataFrame containing the composite face task design matrix.\n\n    Examples\n    --------\n    &gt;&gt;&gt; design = mkcflist(4)\n    &gt;&gt;&gt; design = mkcflist(['AB', 'CD', 'EF', 'GH'])\n    &gt;&gt;&gt; design.to_csv('cf_design.csv', index=False) # save the design matrix to a csv file\n    \"\"\"\n\n    default_selector = [\n        [0, 1, 0, 1],  # TCS\n        [0, 1, 2, 3],  # TCD\n        [0, 1, 0, 2],  # TIS\n        [0, 1, 3, 1],  # TID\n        [0, 1, 0, 1],  # BCS\n        [0, 1, 2, 3],  # BCD\n        [0, 1, 3, 1],  # BIS\n        [0, 1, 0, 2]   # BID\n    ]\n    defaultKwargs = {'isTopCued': [1], \n                     'isCongruent': [0, 1], \n                     'isAligned': [0, 1], \n                     'isCuedSame': [0, 1], \n                     'studyIsCued': 0,\n                     'studyIsAligned': 1,\n                     'faceselector': default_selector,\n                     'cue_str': ['bot', 'top'],\n                     'con_str': ['inc', 'con'],\n                     'ali_str': ['mis', 'ali'],\n                     'ca_str': ['dif', 'sam'],\n                     'task': 'CCF',\n                     'cf_group': '',\n                     'cf_sep': '_',\n                     'cfs_sep': '',\n                     'showlevels': False,\n                     'is_rand': True,\n                     'face_order': 'sort'}\n    kwargs = {**defaultKwargs, **kwargs}\n\n    # deal with input cfs\n    if isinstance(cfs, int):\n        ncfs = cfs\n        # use alphabets as the default cf names\n        alphabets = list(string.ascii_uppercase)\n        cfs = alphabets[:ncfs]\n    elif isinstance(cfs, dict):\n        ncfs = len(cfs)\n        cfs = list(cfs.keys())\n    elif isinstance(cfs, list):\n        ncfs = len(cfs)\n\n    # throw warnings if the number of cfs is less than 4\n    if ncfs &lt; 4:\n        warnings.warn(f'The number of composite faces shoul not be less than 4 (ncfs: {ncfs}).')\n\n    # whether randomize or sort the original face names\n    if kwargs['face_order'] == 'rand':\n        np.random.shuffle(cfs)\n    elif kwargs['face_order'] == 'sort':\n        cfs.sort()\n\n    # make the exp design matrix\n    exp_conditions = [(\"isTopCued\", kwargs['isTopCued']), \n                      (\"isCongruent\", kwargs['isCongruent']),\n                      (\"isCuedSame\", kwargs['isCuedSame']),\n                      (\"isAligned\", kwargs['isAligned']),\n                      (\"basefaceIndex\", list(range(ncfs)))]\n    design = exp_design_builder(exp_conditions, is_rand=kwargs['is_rand'])\n    print(f'Total trials: {len(design)}')\n\n    # generate the composite face indices\n    design['trialType'] = 4*(1-design['isTopCued']) + 2*(1-design['isCongruent']) + (1-design['isCuedSame'])\n    design['base_selector'] = design['trialType'].apply(lambda x: kwargs['faceselector'][x]) # base selector\n    design['thisFaceSet'] = design.apply(lambda row: [np.mod(x + row['basefaceIndex'], ncfs) for x in row[\"base_selector\"]], axis=1)\n\n    # make the composite face names\n    design['studyFace'] = design.apply(lambda row: cfs[row['thisFaceSet'][0]]+kwargs['cf_sep']+cfs[row['thisFaceSet'][1]]+'_'+kwargs['ali_str'][max(row['isAligned'], kwargs['studyIsAligned'])], axis=1)\n\n    design['testFace'] = design.apply(lambda row: cfs[row['thisFaceSet'][2]]+kwargs['cf_sep']+cfs[row['thisFaceSet'][3]]+'_'+kwargs['ali_str'][row['isAligned']], axis=1)\n\n    if len(kwargs['isTopCued']) &gt; 1: # add cue information to the face names\n        if kwargs['studyIsCued']:\n            design['studyFace'] += '_'+design.apply(lambda row: kwargs['cue_str'][row['isTopCued']], axis=1)\n        design['testFace'] += '_'+design.apply(lambda row: kwargs['cue_str'][row['isTopCued']], axis=1)\n\n    # add task column and move it to the front\n    design['Task'] = kwargs['task']\n    design = design[[\"Task\"] + [col for col in design.columns if col != \"Task\"]]\n\n    # combine the study and test faces\n    if kwargs['cfs_sep']:\n        design['cfPair'] = design['studyFace'] + kwargs['cfs_sep'] + design['testFace']\n\n    # add the stim/CF group information\n    if kwargs['cf_group']:\n        design['cfGroup'] = kwargs['cf_group']\n\n    # update IV levels\n    if kwargs['showlevels']:\n        design['Cue'] = design.apply(lambda row: kwargs['cue_str'][row['isTopCued']], axis=1)\n        design['Congruency'] = design.apply(lambda row: kwargs['con_str'][row['isCongruent']], axis=1)\n        design['Alignment'] = design.apply(lambda row: kwargs['ali_str'][row['isAligned']], axis=1)\n        design['CorrectAnswer'] = design.apply(lambda row: kwargs['ca_str'][row['isCuedSame']], axis=1)\n        columns_to_reorder = ['Cue', 'Congruency', 'Alignment', 'CorrectAnswer', 'studyFace', 'testFace']\n        new_order = columns_to_reorder + [col for col in design.columns if col not in columns_to_reorder]\n        design = design[new_order]\n\n    # remove unused columns\n    design = design.drop(columns=['trialType', 'base_selector', 'thisFaceSet'])\n\n    return design\n</code></pre>"},{"location":"api/api/#pyfaceimage.mk_cf_designs","title":"<code>mk_cf_designs(imdict, **kwargs)</code>","text":"<p>Make composite face task design matrix for each face group in <code>imdict</code>.</p> <p>Parameters:</p> Name Type Description Default <code>imdict</code> <code>dict</code> <p>A dictionary of image() instances.</p> required <p>Other Parameters:</p> Name Type Description <code>isTopCued</code> <code>list</code> <p>whether the top half is cued. Defaults to <code>[1]</code>.</p> <code>isCongruent</code> <code>list</code> <p>whether the top and bottom halves are congruent. Defaults to <code>[0, 1]</code>.</p> <code>isAligned</code> <code>list</code> <p>whether the top and bottom halves are aligned. Defaults to <code>[0, 1]</code>.</p> <code>isCuedSame</code> <code>list</code> <p>whether the cued half is the same as the target half. Defaults to <code>[0, 1]</code>.</p> <code>studyIsCued</code> <code>int</code> <p>whether the study faces are cued. Defaults to <code>0</code>.</p> <code>studyIsAligned</code> <code>int</code> <p>whether the study faces are always aligned. Defaults to <code>1</code>.</p> <code>faceselector</code> <code>list</code> <p>the face selector for the composite faces. Defaults to the default selector (<code>default_selector</code>).</p> <code>cue_str</code> <code>list</code> <p>the cue strings. Defaults to <code>['bot', 'top']</code>.</p> <code>con_str</code> <code>list</code> <p>the congruency strings. Defaults to <code>['inc', 'con']</code>.</p> <code>ali_str</code> <code>list</code> <p>the alignment strings. Defaults to <code>['mis', 'ali']</code>.</p> <code>ca_str</code> <code>list</code> <p>the correct answer strings. Defaults to <code>['dif', 'sam']</code>.</p> <code>task</code> <code>str</code> <p>the task name. Defaults to <code>'CCF'</code>.</p> <code>cf_sep</code> <code>str</code> <p>the separator within the composite face names. Defaults to <code>'_'</code>.</p> <code>cfs_sep</code> <code>str</code> <p>the separator between the study and test faces. Defaults to <code>''</code>.</p> <code>showlevels</code> <code>bool</code> <p>whether to show the levels of the independent variables. Defaults to <code>False</code>.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>a pandas DataFrame containing the composite face task design matrix.</p> Source code in <code>pyfaceimage/__init__.py</code> <pre><code>def mk_cf_designs(imdict, **kwargs):\n    \"\"\"Make composite face task design matrix for each face group in `imdict`.\n\n    Parameters\n    ----------\n    imdict : dict\n        A dictionary of image() instances.\n\n    Other Parameters\n    ----------------\n    isTopCued : list\n        whether the top half is cued. Defaults to `[1]`.\n    isCongruent : list\n        whether the top and bottom halves are congruent. Defaults to `[0, 1]`.\n    isAligned : list\n        whether the top and bottom halves are aligned. Defaults to `[0, 1]`.\n    isCuedSame : list\n        whether the cued half is the same as the target half. Defaults to `[0, 1]`.\n    studyIsCued : int\n        whether the study faces are cued. Defaults to `0`.\n    studyIsAligned : int\n        whether the study faces are always aligned. Defaults to `1`.\n    faceselector : list\n        the face selector for the composite faces. Defaults to the default selector (`default_selector`).\n    cue_str : list\n        the cue strings. Defaults to `['bot', 'top']`.\n    con_str : list\n        the congruency strings. Defaults to `['inc', 'con']`.\n    ali_str : list\n        the alignment strings. Defaults to `['mis', 'ali']`.\n    ca_str : list\n        the correct answer strings. Defaults to `['dif', 'sam']`.\n    task : str\n        the task name. Defaults to `'CCF'`.\n    cf_sep : str\n        the separator within the composite face names. Defaults to `'_'`.\n    cfs_sep : str\n        the separator between the study and test faces. Defaults to `''`.\n    showlevels : bool\n        whether to show the levels of the independent variables. Defaults to `False`.\n\n    Returns\n    -------\n    pd.DataFrame\n        a pandas DataFrame containing the composite face task design matrix.\n    \"\"\"\n\n    defaultKwargs = {'is_rand': False,\n                     'showlevels': True}\n    kwargs = {**defaultKwargs, **kwargs}\n\n    # make sure the dictionary is nested\n    if _isflatten(imdict):\n        imdict = _nested(imdict)\n\n    # make composite face list for each face group\n    cfdict = dict()\n    for k,v in imdict.items():\n        kwargs['cf_group'] = k\n        cfdict[k] = mk_cf_design(v, **kwargs)\n\n    # concatenate the composite face list    \n    cf_designs = pd.concat(cfdict.values(), ignore_index=True)\n\n    # randomize the design\n    if kwargs['is_rand']:\n        cf_designs = cf_designs.sample(frac=1).reset_index(drop=True)\n\n    # add trial numbers\n    cf_designs['trial'] = [x+1 for x in range(len(cf_designs))]\n    columns = ['trial'] + [col for col in cf_designs.columns if col != 'trial']\n    cf_designs = cf_designs[columns]\n\n    return cf_designs\n</code></pre>"},{"location":"api/api/#pyfaceimage.mkboxscr","title":"<code>mkboxscr(imdict, **kwargs)</code>","text":"<p>Make box scrambled stimuli.</p> <p>Parameters:</p> Name Type Description Default <code>imdict</code> <code>dict</code> <p>A dictionary of image() instances.</p> required <p>Other Parameters:</p> Name Type Description <code>nBoxW</code> <code>int</code> <p>the number of boxes in width. Defaults to 10.</p> <code>nBoxH</code> <code>int</code> <p>the number of boxes in height. Defaults to 16.</p> <code>pBoxW</code> <code>int</code> <p>the width of a box. Defaults to 0.</p> <code>pBoxH</code> <code>int</code> <p>the height of a box. Defaults to 0.</p> <code>pad</code> <code>bool</code> <p>whether to add padding to the image. Defaults to False.</p> <code>padcolor</code> <code>int</code> <p>the padding color. Defaults to 0.</p> <code>padalpha</code> <code>int</code> <p>the padding alpha. Defaults to -1.</p> Source code in <code>pyfaceimage/__init__.py</code> <pre><code>def mkboxscr(imdict, **kwargs):\n    \"\"\"Make box scrambled stimuli.\n\n    Parameters\n    ----------\n    imdict : dict\n        A dictionary of image() instances.\n\n    Other Parameters\n    ----------------\n    nBoxW : int\n        the number of boxes in width. Defaults to 10.\n    nBoxH : int\n        the number of boxes in height. Defaults to 16.\n    pBoxW : int\n        the width of a box. Defaults to 0.\n    pBoxH : int\n        the height of a box. Defaults to 0.\n    pad : bool\n        whether to add padding to the image. Defaults to False.\n    padcolor : int\n        the padding color. Defaults to 0.\n    padalpha : int\n        the padding alpha. Defaults to -1.\n    \"\"\"\n    [v.mkboxscr(**kwargs) for v in imdict.values()]\n</code></pre>"},{"location":"api/api/#pyfaceimage.mkcf","title":"<code>mkcf(im1, im2, **kwargs)</code>","text":"<p>Make composite faces (for the composite face task) with im1 and im2.</p> <p>Parameters:</p> Name Type Description Default <code>im1</code> <code>im.image() instance</code> <p>one im.image() instane for creating composite faces.</p> required <code>im2</code> <code>im.image() instance</code> <p>another im.image() instane for creating composite faces.</p> required <p>Other Parameters:</p> Name Type Description <code>misali</code> <code>(int, num)</code> <p>misalignment. Positive int will shift to the right and negative int will shift to the left. If misali is int, it refers to pixels. If misali is decimal, it misali*face width is the amount of misalignment. Defaults to 0.</p> <code>topis1</code> <code>bool</code> <p>whether im1 (or im2) is used as the top of the composite face. Defaults to True.</p> <code>cueistop</code> <code>bool</code> <p>whether the top half is cued. Defaults to True.</p> <code>lineh</code> <code>int</code> <p>the height (in pixels) of the line between the top and bottom facial havles. Defaults to 3.</p> <code>distv</code> <code>int</code> <p>the vertical distance (in pixels) between the top and bottom facial halves. Defaults to 0.</p> <code>width_cf</code> <code>int</code> <p>the width of the composite face/the line (also the width of the output composite face image). Defaults to three times of the face width.</p> <code>lineclr</code> <code>int tuple</code> <p>the color of the line. Defaults to (255,255,255), i.e., white.</p> <code>showcue</code> <code>bool</code> <p>whether to display cue in the image. Defaults to False.</p> <code>cueclr</code> <code>int tuple</code> <p>the color of the cue. Defaults to the same as lineclr.</p> <code>cuethick</code> <code>int</code> <p>the thickness (in pixels) of the cue. Defaults to 4.</p> <code>cuew</code> <code>int</code> <p>the width (in pixels) of the cue. Defaults to 110% of the face width.</p> <code>cueh</code> <code>int</code> <p>the height (in pixels) of the very left and right parts of the cue. Defaults to about 5% of the face height.</p> <code>cuedist</code> <code>int</code> <p>distance from the main part of the cue to edge of the face. Defaults to twice of cueh.</p> <p>Returns:</p> Name Type Description <code>im.image() instance</code> <p>the composite face stimuli as a im.image() instance.</p> <code>fn_cf</code> <code>str</code> <p>the filename of the composite face stimuli.</p> Source code in <code>pyfaceimage/multim.py</code> <pre><code>def mkcf(im1, im2, **kwargs):\n    \"\"\"Make composite faces (for the composite face task) with im1 and im2.\n\n    Parameters\n    ----------\n    im1 : im.image() instance\n        one im.image() instane for creating composite faces.\n    im2 : im.image() instance\n        another im.image() instane for creating composite faces.\n\n    Other Parameters\n    ----------------\n    misali : int, num\n        misalignment. Positive int will shift to the right and negative int will shift to the left. If misali is int, it refers to pixels. If misali is decimal, it misali*face width is the amount of misalignment. Defaults to 0.\n    topis1 : bool\n        whether im1 (or im2) is used as the top of the composite face. Defaults to True.\n    cueistop : bool\n        whether the top half is cued. Defaults to True.\n    lineh : int\n        the height (in pixels) of the line between the top and bottom facial havles. Defaults to 3.\n    distv : int\n        the vertical distance (in pixels) between the top and bottom facial halves. Defaults to 0.\n    width_cf : int\n        the width of the composite face/the line (also the width of the output composite face image). Defaults to three times of the face width.\n    lineclr : int tuple\n        the color of the line. Defaults to (255,255,255), i.e., white.\n    showcue : bool\n        whether to display cue in the image. Defaults to False.\n    cueclr : int tuple\n        the color of the cue. Defaults to the same as lineclr.\n    cuethick : int\n        the thickness (in pixels) of the cue. Defaults to 4.\n    cuew : int\n        the width (in pixels) of the cue. Defaults to 110% of the face width.\n    cueh : int\n        the height (in pixels) of the very left and right parts of the cue. Defaults to about 5% of the face height.\n    cuedist : int\n        distance from the main part of the cue to edge of the face. Defaults to twice of cueh.\n\n    Returns\n    -------\n    im.image() instance\n        the composite face stimuli as a im.image() instance.\n    fn_cf : str\n        the filename of the composite face stimuli.\n    \"\"\"\n\n    defaultKwargs = {'misali':0, 'topis1': True, 'cueistop': True,\n                     'lineh':3, 'distv': 0, 'width_cf': im1.w*3, 'lineclr': None,\n                     'showcue':False, 'cueclr':None,\n                     'cuethick': 4, 'cuew': int(im1.w*1.1), 'cueh': int(im1.h*.05), 'cuedist': None}\n    kwargs = {**defaultKwargs, **kwargs}\n\n    # decide the width of the output CF image\n    w_cf = kwargs['width_cf']\n    if isinstance(kwargs['misali'], int):\n        misali = kwargs['misali']\n    else:\n        misali = int(kwargs['misali']*im1.w)\n    assert (misali+im1.w/2)&lt;=w_cf/2, f'Please make sure the width of the composite face ({w_cf}) is set appropriately to fit the misalignment ({misali}).'\n\n    # generate the default color for the (white) line\n    if kwargs['lineclr'] is None: \n        kwargs['lineclr'] = (255,) * im1.nchan # white line\n    else:\n        assert len(kwargs['lineclr'])==im1.nchan, f\"The lenght of 'lineclr' should match im1.nchan({im1.nchan})\"\n\n    if kwargs['cueclr'] is None: \n        kwargs['cueclr'] = kwargs['lineclr']\n    else:\n        assert len(kwargs['cueclr'])==im1.nchan, f\"The lenght of 'cueclr' should match im1.nchan({im1.nchan})\"\n\n    alistrs = ['ali', 'mis']\n    bboxes = [(0, 0, im1.w, im1.h/2), (0, im1.h/2, im1.w, im1.h)] # top, bottom\n    dests = [((w_cf-im1.w)//2+misali*(1-kwargs['cueistop']), 0), # top position\n             ((w_cf-im1.w)//2+misali*kwargs['cueistop'], im1.h//2+np.max([kwargs['lineh'], kwargs['distv']]))] # bottom position\n    fns_12 = [im1.fnonly, im2.fnonly]\n\n    fn_cf = os.path.join(fns_12[1-kwargs['topis1']]+'_'+fns_12[kwargs['topis1']]+'_'+alistrs[misali!=0])\n\n    # top and bottom pil\n    im1_half = im1.deepcopy()\n    im2_half = im2.deepcopy()\n    im1_half.croprect(bboxes[1-kwargs['topis1']])\n    im2_half.croprect(bboxes[kwargs['topis1']])\n\n    # create a new canvas and paste the image\n    dist_cf = Image.new(im1.pil.mode, (w_cf, im1.h+np.max([kwargs['lineh'], kwargs['distv']])))\n    # white line\n    drawl = ImageDraw.Draw(dist_cf)\n    if kwargs['lineh']&gt;1: # draw a white line for top\n        drawl.rectangle((0, im1.h//2, w_cf, im1.h//2+kwargs['lineh']-1),fill=kwargs['lineclr'])\n        if kwargs['distv']&gt;kwargs['lineh']: # draw another white line for bottom\n            drawl.rectangle((0, im1.h//2+kwargs['distv']-kwargs['lineh'], w_cf, im1.h//2+kwargs['distv']-1),fill=kwargs['lineclr'])\n    # top and bottom\n    dist_cf.paste(im1_half.pil, dests[1-kwargs['topis1']])\n    dist_cf.paste(im2_half.pil, dests[kwargs['topis1']])\n\n    if kwargs['showcue']:\n        if kwargs['cuedist'] is None:\n            kwargs['cuedist']= kwargs['cueh']*2\n        # cues\n        cue1 = Image.new(im1.pil.mode, (w_cf, kwargs['cuedist']))\n        cue2 = cue1.copy()\n        drawc = ImageDraw.Draw(cue1)\n        drawc.rectangle(((w_cf-kwargs['cuew'])//2,0,(w_cf+kwargs['cuew'])//2-1,kwargs['cuethick']-1),fill=kwargs['cueclr'])\n        drawc.rectangle(((w_cf-kwargs['cuew'])//2,kwargs['cuethick'],\n                        (w_cf-kwargs['cuew'])//2+kwargs['cuethick']-1,kwargs['cueh']+kwargs['cuethick']-1),\n                        fill=kwargs['cueclr'])\n        drawc.rectangle(((w_cf+kwargs['cuew'])//2-kwargs['cuethick'],kwargs['cuethick'],\n                        (w_cf+kwargs['cuew'])//2-1,kwargs['cueh']+kwargs['cuethick']-1),\n                        fill=kwargs['cueclr'])\n        cues = [cue1, cue2]\n\n        # concatenate CF and cues\n        dist = Image.new(im1.pil.mode, (w_cf, cue1.size[1]*2+dist_cf.size[1]))\n        dist.paste(cues[1-kwargs['cueistop']], (0, 0))\n        dist.paste(dist_cf, (0, cue1.size[1]))\n        dist.paste(ImageOps.flip(cues[kwargs['cueistop']]), (0, cue1.size[1]+dist_cf.size[1]))\n\n        # add the cue str to filename\n        fn_cf = fn_cf+'_'+['top', 'bot'][1-kwargs['cueistop']]\n\n    else:\n        dist = dist_cf\n\n    # update/save the cf image information\n    im_cf = im1.deepcopy()\n    im_cf._repil(dist)\n    im_cf._newfilename(newfname=fn_cf, addfn=False)\n\n    return im_cf, fn_cf\n</code></pre>"},{"location":"api/api/#pyfaceimage.mkcf_prf","title":"<code>mkcf_prf(dict_cf, dict_bg, imsize_bg=(500, 500), opaque=0.75)</code>","text":"<p>Make composite face stimuli for the pRF experiment.</p> <p>Parameters:</p> Name Type Description Default <code>dict_cf</code> <code>dict</code> <p>a dictionary of composite faces.</p> required <code>dict_bg</code> <code>dict</code> <p>a dictionary of background images.</p> required <code>imsize_bg</code> <code>tuple</code> <p>the output image size, by default (500,500)</p> <code>(500, 500)</code> <code>opaque</code> <code>float</code> <p>ratio of the opaque region, by default .75</p> <code>0.75</code> <p>Returns:</p> Type Description <code>dict</code> <p>a dictionary of composite face stimuli to be used for the pRF experiment.</p> Source code in <code>pyfaceimage/exps.py</code> <pre><code>def mkcf_prf(dict_cf, dict_bg, imsize_bg=(500,500), opaque=.75):\n    \"\"\"Make composite face stimuli for the pRF experiment.\n\n    Parameters\n    ----------\n    dict_cf : dict\n        a dictionary of composite faces.\n    dict_bg : dict\n        a dictionary of background images.\n    imsize_bg : tuple, optional\n        the output image size, by default (500,500)\n    opaque : float, optional\n        ratio of the opaque region, by default .75\n\n    Returns\n    -------\n    dict\n        a dictionary of composite face stimuli to be used for the pRF experiment.\n    \"\"\"\n\n    # Initialize the output dict\n    imdict_out = {}\n\n    for k,im_fore in dict_cf.items():\n\n        # this fore and background images\n        k_back = k.replace('mis', 'ali').replace('_l', '').replace('_r', '')+'_pscr' # only use aligend background\n        im_back = dict_bg[k_back]\n\n        # phase scrambed background\n        im_back.resize(trgw=imsize_bg[0], trgh=imsize_bg[1])\n\n        # mask\n        mask = pyfaceimage.utilities.radial_gaussian(imsize_bg, opaque)\n\n        # add fore to back\n        im_back_tmp = im_back.deepcopy()\n        pyfaceimage.multim.composite(im_back_tmp, im_fore)\n\n        # apply mask\n        im_back_tmp.pil.putalpha(mask)\n\n        # update the filename\n        im_back_tmp.filename = im_fore.filename.replace('_pad', '')\n        im_back_tmp._updatefromfilename()\n\n        # save the output dict\n        imdict_out[k] = im_back_tmp\n        del im_back_tmp\n\n    return imdict_out\n</code></pre>"},{"location":"api/api/#pyfaceimage.mkcfs","title":"<code>mkcfs(imdict, sep='/', **kwargs)</code>","text":"<p>Make composite faces for all possible combinations of images in the dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>imdict</code> <code>dict</code> <p>A dictionary of image() instances.</p> required <code>sep</code> <code>str</code> <p>a string to be used to concatnate the subdirectory and image name, which is used as the key for flattening the dictionary, by default '/'. If sep is None, the dictionary will not be flatten.</p> <code>'/'</code> <p>Other Parameters:</p> Name Type Description <code>misali</code> <code>(int, num)</code> <p>misalignment. Positive int will shift to the right and negative int will shift to the left. If misali is int, it refers to pixels. If misali is decimal, it misali*face width is the amount of misalignment. Defaults to 0.</p> <code>topis1</code> <code>bool</code> <p>whether im1 (or im2) is used as the top of the composite face. Defaults to True.</p> <code>cueistop</code> <code>bool</code> <p>whether the top half is cued. Defaults to True.</p> <code>lineh</code> <code>int</code> <p>the height (in pixels) of the line between the top and bottom facial havles. Defaults to 3.</p> <code>distv</code> <code>int</code> <p>the vertical distance (in pixels) between the top and bottom facial halves. Defaults to 0.</p> <code>width_cf</code> <code>int</code> <p>the width of the composite face/the line (also the width of the output composite face image). Defaults to three times of the face width.</p> <code>lineclr</code> <code>int tuple</code> <p>the color of the line. Defaults to (255,255,255), i.e., white.</p> <code>showcue</code> <code>bool</code> <p>whether to display cue in the image. Defaults to False.</p> <code>cueclr</code> <code>int tuple</code> <p>the color of the cue. Defaults to the same as lineclr.</p> <code>cuethick</code> <code>int</code> <p>the thickness (in pixels) of the cue. Defaults to 4.</p> <code>cuew</code> <code>int</code> <p>the width (in pixels) of the cue. Defaults to 110% of the face width.</p> <code>cueh</code> <code>int</code> <p>the height (in pixels) of the very left and right parts of the cue. Defaults to about 5% of the face height.</p> <code>cuedist</code> <code>int</code> <p>distance from the main part of the cue to edge of the face. Defaults to twice of cueh.</p> <p>Returns:</p> Type Description <code>A dictionary of im.image() instance</code> <p>the composite face stimuli as a im.image() instance.</p> Source code in <code>pyfaceimage/__init__.py</code> <pre><code>def mkcfs(imdict, sep='/', **kwargs):\n    \"\"\"Make composite faces for all possible combinations of images in the dictionary.\n\n    Parameters\n    ----------\n    imdict : dict\n        A dictionary of image() instances.\n    sep : str, optional\n        a string to be used to concatnate the subdirectory and image name, which is used as the key for flattening the dictionary, by default '/'. If sep is None, the dictionary will not be flatten.\n\n    Other Parameters\n    ----------------\n    misali : int, num\n        misalignment. Positive int will shift to the right and negative int will shift to the left. If misali is int, it refers to pixels. If misali is decimal, it misali*face width is the amount of misalignment. Defaults to 0.\n    topis1 : bool\n        whether im1 (or im2) is used as the top of the composite face. Defaults to True.\n    cueistop : bool\n        whether the top half is cued. Defaults to True.\n    lineh : int\n        the height (in pixels) of the line between the top and bottom facial havles. Defaults to 3.\n    distv : int\n        the vertical distance (in pixels) between the top and bottom facial halves. Defaults to 0.\n    width_cf : int\n        the width of the composite face/the line (also the width of the output composite face image). Defaults to three times of the face width.\n    lineclr : int tuple\n        the color of the line. Defaults to (255,255,255), i.e., white.\n    showcue : bool\n        whether to display cue in the image. Defaults to False.\n    cueclr : int tuple\n        the color of the cue. Defaults to the same as lineclr.\n    cuethick : int\n        the thickness (in pixels) of the cue. Defaults to 4.\n    cuew : int\n        the width (in pixels) of the cue. Defaults to 110% of the face width.\n    cueh : int\n        the height (in pixels) of the very left and right parts of the cue. Defaults to about 5% of the face height.\n    cuedist : int\n        distance from the main part of the cue to edge of the face. Defaults to twice of cueh.\n\n    Returns\n    -------\n    A dictionary of im.image() instance\n        the composite face stimuli as a im.image() instance.\n    \"\"\"\n\n    # make sure the dictionary is flatten\n    if len(set([im.group for im in imdict.values()])) &gt; 1 and bool(sep):\n        imdict_nested = _nested(imdict, sep=sep)\n\n        cfdict_nested = {}\n        for k,v in imdict_nested.items():\n            cfdict_nested[k] = _mkcfs(v, **kwargs)\n\n        cfdict = _flatten(cfdict_nested, sep=sep)\n\n    else:\n        cfdict = _mkcfs(imdict, **kwargs)\n\n    return cfdict\n</code></pre>"},{"location":"api/api/#pyfaceimage.mkphasescr","title":"<code>mkphasescr(imdict, **kwargs)</code>","text":"<p>Make phase scrambled stimuli.</p> <p>Parameters:</p> Name Type Description Default <code>imdict</code> <code>dict</code> <p>A dictionary of image() instances.</p> required <p>Other Parameters:</p> Name Type Description <code>rms</code> <code>float</code> <p>the desired RMS of the image. Defaults to 0.3.</p> Source code in <code>pyfaceimage/__init__.py</code> <pre><code>def mkphasescr(imdict, **kwargs):\n    \"\"\"Make phase scrambled stimuli.\n\n    Parameters\n    ----------\n    imdict : dict\n        A dictionary of image() instances.\n\n    Other Parameters\n    ----------------\n    rms : float\n        the desired RMS of the image. Defaults to 0.3.\n    \"\"\"\n    [v.mkphasescr(**kwargs) for v in imdict.values()]\n</code></pre>"},{"location":"api/api/#pyfaceimage.pad","title":"<code>pad(imdict, **kwargs)</code>","text":"<p>Add padding to the image/stimuli.</p> <p>Parameters:</p> Name Type Description Default <code>imdict</code> <code>dict</code> <p>A dictionary of image() instances.</p> required <p>Other Parameters:</p> Name Type Description <code>trgw</code> <code>int</code> <p>the width of the target/desired stimuli.</p> <code>trgh</code> <code>int</code> <p>the height of the target/desired stimuli.</p> <code>padvalue</code> <code>int</code> <p>padding value. Defaults to 0 (show as transparent if alpha channel exists).</p> <code>top</code> <code>bool</code> <p>padding more to top if needed. Defaults to True.</p> <code>left</code> <code>bool</code> <p>padding more to left if needed. Defaults to True.</p> <code>padalpha</code> <code>int</code> <p>the transparent color. Defaults to -1, i.e., not to force it to transparent.</p> <code>extrafn</code> <code>str</code> <p>the string to be added to the filename. Defaults to '_pad'.</p> Source code in <code>pyfaceimage/__init__.py</code> <pre><code>def pad(imdict, **kwargs):\n    \"\"\"\n    Add padding to the image/stimuli.\n\n    Parameters\n    ----------\n    imdict : dict\n        A dictionary of image() instances.\n\n    Other Parameters\n    ----------------\n    trgw : int\n        the width of the target/desired stimuli. \n    trgh : int\n        the height of the target/desired stimuli.\n    padvalue : int\n        padding value. Defaults to 0 (show as transparent if alpha channel exists).\n    top : bool\n        padding more to top if needed. Defaults to True.\n    left : bool\n        padding more to left if needed. Defaults to True.\n    padalpha : int\n        the transparent color. Defaults to -1, i.e., not to force it to transparent.\n    extrafn : str\n        the string to be added to the filename. Defaults to '_pad'.\n    \"\"\"\n    [v.pad(**kwargs) for v in imdict.values()]\n</code></pre>"},{"location":"api/api/#pyfaceimage.radial_gaussian","title":"<code>radial_gaussian(imsize=256, opaque=0.5, kernal=10)</code>","text":"<p>Make a radial gaussian mask ('L') image (with some opaque region).</p> <p>Parameters:</p> Name Type Description Default <code>imsize</code> <code>int tuple, optional. </code> <p>Image size (width, height). {imsize} will be used as both width and height if only one value is given. Default to 256.</p> <code>256</code> <code>opaque</code> <code>float, optional. </code> <p>Ratio of the regions to be \"opaqued\". Larger value means larger opaque region (from center to periphery). Default to .5.</p> <code>0.5</code> <code>kernal</code> <code>int</code> <p>kernal for the gaussian filter, by default 10</p> <code>10</code> <p>Returns:</p> Type Description <code>PIL.Image instance</code> <p>A PIL.Image instance of the radial gaussian mask.</p> Source code in <code>pyfaceimage/utilities.py</code> <pre><code>def radial_gaussian(imsize=256, opaque=.5, kernal=10):\n    \"\"\"Make a radial gaussian mask ('L') image (with some opaque region).\n\n    Parameters\n    ----------\n    imsize : int tuple, optional. \n        Image size (width, height). {imsize} will be used as both width and height if only one value is given. Default to 256.\n    opaque : float, optional. \n        Ratio of the regions to be \"opaqued\". Larger value means larger opaque region (from center to periphery). Default to .5.\n    kernal : int, optional\n        kernal for the gaussian filter, by default 10\n\n    Returns\n    -------\n    PIL.Image instance\n        A PIL.Image instance of the radial gaussian mask.\n    \"\"\"    \n\n    # make circle if imsize is not tuple\n    if type(imsize) is not tuple or len(imsize) == 1:\n        imsize = (imsize, imsize) # a and b in ellipse formula\n\n    # set the opaque area (roughly)\n    if type(opaque) is not tuple or len(opaque) == 1:\n        opaque = (opaque, opaque)\n    if not isinstance(opaque, int):\n        opaque = (int(opaque[0] * imsize[0]), int(opaque[1] * imsize[1]))\n\n    # make a 'L' mask in PIL\n    mask_im = Image.new('L', imsize, 0)\n    draw = ImageDraw.Draw(mask_im)\n    centeroval = (int(imsize[0]/2-opaque[0]/2), int(imsize[1]/2-opaque[0]/2),\n                  int(imsize[0]/2+opaque[0]/2), int(imsize[1]/2+opaque[0]/2))\n    draw.ellipse(centeroval, fill=255)\n    # apply gaussian blur\n    mask_im_blur = mask_im.filter(ImageFilter.GaussianBlur(kernal))\n\n    return mask_im_blur\n</code></pre>"},{"location":"api/api/#pyfaceimage.read","title":"<code>read(imdict)</code>","text":"<p>read the images if read was False in dir()</p> <p>Parameters:</p> Name Type Description Default <code>imdict</code> <code>dict</code> <p>A dictionary of image() instances.</p> required Source code in <code>pyfaceimage/__init__.py</code> <pre><code>def read(imdict):\n    \"\"\"read the images if read was False in dir()\n\n    Parameters\n    ----------\n    imdict : dict\n        A dictionary of image() instances.\n    \"\"\"\n    [v.read() for v in imdict.values()]\n</code></pre>"},{"location":"api/api/#pyfaceimage.resize","title":"<code>resize(imdict, **kwargs)</code>","text":"<p>Resize the image.</p> <p>Parameters:</p> Name Type Description Default <code>imdict</code> <code>dict</code> <p>A dictionary of image() instances.</p> required <p>Other Parameters:</p> Name Type Description <code>trgw</code> <code>int</code> <p>the width of the target/desired stimuli.</p> <code>trgh</code> <code>int</code> <p>the height of the target/desired stimuli.</p> <code>ratio</code> <code>float</code> <p>the ratio to resize the image. Defaults to 0.</p> <code>newfolder</code> <code>str</code> <p>the folder to save the resized image. Defaults to None.</p> Source code in <code>pyfaceimage/__init__.py</code> <pre><code>def resize(imdict, **kwargs):\n    \"\"\"Resize the image.\n\n    Parameters\n    ----------\n    imdict : dict\n        A dictionary of image() instances.\n\n    Other Parameters\n    ----------------\n    trgw : int\n        the width of the target/desired stimuli.\n    trgh : int\n        the height of the target/desired stimuli.\n    ratio : float\n        the ratio to resize the image. Defaults to 0.\n    newfolder : str\n        the folder to save the resized image. Defaults to None.\n    \"\"\"\n    [v.resize(**kwargs) for v in imdict.values()]\n</code></pre>"},{"location":"api/api/#pyfaceimage.rotate","title":"<code>rotate(imdict, **kwargs)</code>","text":"<p>Rotate the image unclockwise.</p> <p>Parameters:</p> Name Type Description Default <code>imdict</code> <code>dict</code> <p>A dictionary of image() instances.</p> required <p>Other Parameters:</p> Name Type Description <code>angle</code> <code>float</code> <p>the angle to rotate the image. Defaults to 180.</p> Source code in <code>pyfaceimage/__init__.py</code> <pre><code>def rotate(imdict, **kwargs):\n    \"\"\"Rotate the image unclockwise.\n\n    Parameters\n    ----------\n    imdict : dict\n        A dictionary of image() instances.\n\n    Other Parameters\n    -----------------\n    angle : float\n        the angle to rotate the image. Defaults to 180.\n    \"\"\"\n    [v.rotate(**kwargs) for v in imdict.values()]\n</code></pre>"},{"location":"api/api/#pyfaceimage.sample","title":"<code>sample(imdict, n=1, valueonly=True)</code>","text":"<p>Randomly sample n images from the dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>imdict</code> <code>dict</code> <p>A dictionary of image() instances.</p> required <code>n</code> <code>int</code> <p>number of images to be sampled, by default 1</p> <code>1</code> <code>valueonly</code> <code>bool</code> <p>whether return the value (i.e., the image instance only), by default True. If False, the key-value pair will be returned.</p> <code>True</code> <p>Returns:</p> Type Description <code>instance or list of tuples</code> <p>randomly sampled value or key-value pair.</p> Source code in <code>pyfaceimage/__init__.py</code> <pre><code>def sample(imdict, n=1, valueonly=True):\n    \"\"\"Randomly sample n images from the dictionary.\n\n    Parameters\n    ----------\n    imdict : dict\n        A dictionary of image() instances.\n    n : int, optional\n        number of images to be sampled, by default 1\n    valueonly : bool, optional\n        whether return the value (i.e., the image instance only), by default True. If False, the key-value pair will be returned.\n\n    Returns\n    -------\n    instance or list of tuples\n        randomly sampled value or key-value pair.\n    \"\"\"\n\n    # make sure the dictionary is flatten\n    if not _isflatten(imdict):\n        imdict = _flatten(imdict)\n\n    # random select one image from dictionary to check the output\n    assert n&lt;=len(imdict)\n    samples = random.sample(sorted(imdict.items()), n)\n\n    if valueonly:\n        # return the value (i.e., the image instance only)\n        out = [v[1] for v in samples]\n        if n==1:\n            out = out[0]\n    else:\n        # return the key-value pair/tuple\n        out = samples\n\n    return out\n</code></pre>"},{"location":"api/api/#pyfaceimage.save","title":"<code>save(imdict, **kwargs)</code>","text":"<p>Save the image PIL.</p> <p>Parameters:</p> Name Type Description Default <code>imdict</code> <code>dict</code> <p>A dictionary of image() instances.</p> required <p>Other Parameters:</p> Name Type Description <code>newfname</code> <code>str</code> <pre><code>strings to be added before the extension, by default ''\n</code></pre> <code>newfolder</code> <code>str</code> <pre><code>folder name to replace the global directory or the last directory level, by default ''\n</code></pre> <code>addfn</code> <code>bool</code> <pre><code>whether to add the newfname to the the original fname (instead of replacing it), by default True\n</code></pre> Source code in <code>pyfaceimage/__init__.py</code> <pre><code>def save(imdict, **kwargs):\n    \"\"\"Save the image PIL.\n\n    Parameters\n    ----------\n    imdict : dict\n        A dictionary of image() instances.\n\n    Other Parameters\n    ----------------\n    newfname : str\n            strings to be added before the extension, by default ''\n    newfolder : str\n            folder name to replace the global directory or the last directory level, by default ''\n    addfn : bool\n            whether to add the newfname to the the original fname (instead of replacing it), by default True\n    \"\"\"\n    [v.save(**kwargs) for v in imdict.values()]\n</code></pre>"},{"location":"api/api/#pyfaceimage.standardize","title":"<code>standardize(imdict, clip=2, matkey='mat')</code>","text":"<p>Standardize the luminance of the images in the dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>imdict</code> <code>dict</code> <p>A dictionary of image() instances.</p> required <code>clip</code> <code>int</code> <p>the number of standard deviations to clip, by default 2</p> <code>2</code> <code>matkey</code> <code>str</code> <p>the key to be used for the matrix, by default 'mat'</p> <code>'mat'</code> Source code in <code>pyfaceimage/__init__.py</code> <pre><code>def standardize(imdict, clip=2, matkey='mat'):\n    \"\"\"Standardize the luminance of the images in the dictionary.\n\n    Parameters\n    ----------\n    imdict : dict\n        A dictionary of image() instances.\n    clip : int, optional\n        the number of standard deviations to clip, by default 2\n    matkey : str, optional\n        the key to be used for the matrix, by default 'mat'\n    \"\"\"\n    # standardize each image separately\n    [v.stdmat(clip=clip, matkey=matkey) for v in imdict.values()]\n\n    # grand min and max\n    grand_min = min([np.min(getattr(v, matkey)) for v in imdict.values()])\n    grand_max = max([np.max(getattr(v, matkey)) for v in imdict.values()])\n\n    # Compute the grand normalized images\n\n    [v.rescale(range=[grand_min,grand_max], matkey=matkey) for v in imdict.values()]\n</code></pre>"},{"location":"api/api/#pyfaceimage.stimlist","title":"<code>stimlist(imdict, sep='/')</code>","text":"<p>Get the list of image names (keys) in the dictionary with a randomize assigned integer key.</p> <p>Parameters:</p> Name Type Description Default <code>imdict</code> <code>dict</code> <p>A dictionary of image() instances.</p> required <code>sep</code> <code>str</code> <p>a string to be used to separate the key in flatten dictionary into the subdirectory and image name, by default '/'</p> <code>'/'</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of image names (keys) in the dictionary with a randomize assigned integer key.</p> Source code in <code>pyfaceimage/__init__.py</code> <pre><code>def stimlist(imdict, sep='/'):\n    \"\"\"Get the list of image names (keys) in the dictionary with a randomize assigned integer key.\n\n    Parameters\n    ----------\n    imdict : dict\n        A dictionary of image() instances.  \n    sep : str, optional\n        a string to be used to separate the key in flatten dictionary into the subdirectory and image name, by default '/'\n\n    Returns\n    -------\n    dict\n        A dictionary of image names (keys) in the dictionary with a randomize assigned integer key.\n    \"\"\"\n\n    # make sure the dictionary is not flatten\n    if _isflatten(imdict):\n        imdict = _nested(imdict)\n\n    imgdict = {}\n    for k0,v0 in imdict.items():\n\n        shuffled_keys = random.sample(list(range(len(v0))), len(v0))\n        thiskeydict = {shuffled_keys[i]: k for i, k in enumerate(v0.keys())}\n        imgdict.update({k0:thiskeydict})\n\n    shuffled_groups = random.sample(list(range(len(imdict))), len(imdict))\n    groupdict = {shuffled_groups[i]: k for i, k in enumerate(imdict.keys())}\n\n    return groupdict, imgdict\n</code></pre>"},{"location":"api/api/#pyfaceimage.torgba","title":"<code>torgba(imdict, **kwargs)</code>","text":"<p>Convert the image to RGBA.</p> <p>Parameters:</p> Name Type Description Default <code>imdict</code> <code>dict</code> <p>A dictionary of image() instances.</p> required Source code in <code>pyfaceimage/__init__.py</code> <pre><code>def torgba(imdict, **kwargs):\n    \"\"\"Convert the image to RGBA.\n\n    Parameters\n    ----------\n    imdict : dict\n        A dictionary of image() instances.\n    \"\"\"\n    [v.torgba(**kwargs) for v in imdict.values()]\n</code></pre>"},{"location":"api/api/#pyfaceimage.touch","title":"<code>touch(path, touchfolder='touch')</code>","text":"<p>Touch empty files for the directory.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str or dict</code> <p>path to be touched. A dictionary of image() instances.</p> required <code>touchfolder</code> <code>str</code> <p>the new folder name for saving the empty files.</p> <code>'touch'</code> Source code in <code>pyfaceimage/__init__.py</code> <pre><code>def touch(path, touchfolder=\"touch\"):\n    \"\"\"Touch empty files for the directory.\n\n    Parameters\n    ----------\n    path : str or dict\n        path to be touched.\n        A dictionary of image() instances.\n    touchfolder : str, optional\n        the new folder name for saving the empty files.\n    \"\"\"\n    # if path is not a dictionary, it will be treated as a path\n    if not isinstance(path, dict):\n        imdict = dir(path=path)\n    else:\n        imdict = path\n\n    # make sure the dictionary is flatten\n    if not _isflatten(imdict):\n        imdict = _flatten(imdict)\n\n    # touch the directory\n    [v.touch(touchfolder) for v in imdict.values()]\n</code></pre>"},{"location":"api/api/#pyfaceimage.updateext","title":"<code>updateext(imdict, **kwargs)</code>","text":"<p>Update the filename information.</p> <p>Parameters:</p> Name Type Description Default <code>imdict</code> <code>dict</code> <p>A dictionary of image() instances.</p> required <p>Other Parameters:</p> Name Type Description <code>ext</code> <code>str</code> <p>the new extension.</p> Source code in <code>pyfaceimage/__init__.py</code> <pre><code>def updateext(imdict, **kwargs):\n    \"\"\"Update the filename information.\n\n    Parameters\n    ----------\n    imdict : dict\n        A dictionary of image() instances.\n\n    Other Parameters\n    ----------------\n    ext : str\n        the new extension.\n    \"\"\"\n    [v.updateext(**kwargs) for v in imdict.values()]\n</code></pre>"},{"location":"api/api/#pyfaceimage.updatekey","title":"<code>updatekey(imdict, key='fnonly')</code>","text":"<p>Update the key of the dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>imdict</code> <code>dict</code> <p>A dictionary of image() instances.</p> required <code>key</code> <code>str</code> <p>which attributes to be used as the key, by default 'fnonly'</p> <code>'fnonly'</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of image() instances with updated key.</p> Source code in <code>pyfaceimage/__init__.py</code> <pre><code>def updatekey(imdict, key='fnonly'):\n    \"\"\"Update the key of the dictionary.\n\n    Parameters\n    ----------\n    imdict : dict\n        A dictionary of image() instances.\n    key : str, optional\n        which attributes to be used as the key, by default 'fnonly'\n\n    Returns\n    -------\n    dict\n        A dictionary of image() instances with updated key.\n    \"\"\"\n    return {getattr(v, key):v for v in imdict.values()}\n</code></pre>"},{"location":"api/class/","title":"class","text":"<p>Auto-generate API documentation using <code>mkdocstrings</code>. Add the following content:</p>"},{"location":"api/class/#api-reference","title":"API Reference","text":"<p>A class to process a single image.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>path and image filename.</p> required <code>read</code> <code>bool</code> <p>Whether to read the image via PIL, by default False.</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>filename</code> <code>str</code> <p>path and image filename.</p> <code>fname</code> <code>str</code> <p>the image filename.</p> <code>fnonly</code> <code>str</code> <p>the image filename without extension.</p> <code>ext</code> <code>str</code> <p>the image extension.</p> <code>dirname</code> <code>str</code> <p>the image directory.</p> <code>isfile</code> <code>bool</code> <p>whether the image file exists.</p> <code>group</code> <code>str</code> <p>the group name of the image.</p> <code>gpath</code> <code>str</code> <p>the global path of the image.</p> <code>pil</code> <code>Image</code> <p>the PIL image.</p> <code>mat</code> <code>array</code> <p>the image matrix.</p> <code>dims</code> <code>tuple</code> <p>the image dimensions.</p> <code>ndim</code> <code>int</code> <p>the number of dimensions.</p> <code>h</code> <code>int</code> <p>the height of the image.</p> <code>w</code> <code>int</code> <p>the width of the image.</p> <code>nchan</code> <code>int</code> <p>the number of channels.</p> <code>rgbmat</code> <code>array</code> <p>the RGB matrix.</p> <code>amat</code> <code>array</code> <p>the alpha matrix.</p> <p>Attributes:</p> Name Type Description <code>filename</code> <code>str</code> <p>Return the image filename.</p> <code>fname</code> <code>str</code> <p>Return the image filename.</p> <code>fnonly</code> <code>str</code> <p>Return the image filename without extension.</p> <code>ext</code> <code>str</code> <p>Return the image extension.</p> <code>dirname</code> <code>str</code> <p>Return the image directory.</p> <code>isfile</code> <code>bool</code> <p>Return whether the image file exists.</p> <code>dims</code> <code>tuple</code> <p>Return the image dimensions.</p> <code>ndim</code> <code>int</code> <p>Return the number of dimensions.</p> <code>h</code> <code>int</code> <p>Return the height of the image.</p> <code>w</code> <code>int</code> <p>Return the width of the image.</p> <code>nchan</code> <code>int</code> <p>Return the number of channels.</p> <code>maxlum</code> <code>float</code> <p>Return the maximum luminance of the image.</p> <code>minlum</code> <code>float</code> <p>Return the minimum luminance of the image.</p> <code>meanlum</code> <code>float</code> <p>Return the mean luminance of the image.</p> <code>rms</code> <code>float</code> <p>Return the RMS of the image.</p> <code>luminfo</code> <code>None</code> <p>Print the luminance information of the image.</p> <p>Methods:</p> Name Description <code>update_fninfor</code> <p>Update the image filename related information.</p> <code>updateext</code> <p>Update the filename information.</p> <code>read</code> <p>Read the image via PIL.</p> <code>imshow</code> <p>Show the image matrix.</p> <code>show</code> <p>Show the image PIL.</p> <code>imsave</code> <p>Save the image mat.</p> <code>save</code> <p>Save the image PIL.</p> <code>deepcopy</code> <p>Make a deep copy of the instance.</p> <code>remat</code> <p>Re-assign value to .mat and update related information.</p> <code>torgba</code> <p>Convert the image to RGBA.</p> <code>grayscale</code> <p>Convert the image to gray-scale.</p> <code>addbg</code> <p>Add background to the RGBA image.</p> <code>rotate</code> <p>Rotate the image unclockwise.</p> <code>stdmat</code> <p>Standardize the image matrix.</p> <code>adjust_pil</code> <p>Adjust the luminance and contrast of the image with <code>pillow</code>.</p> <code>cropoval</code> <p>Crop the image with an oval shape.</p> <code>croprect</code> <p>Crop the image with a rectangle box.</p> <code>resize</code> <p>Resize the image.</p> <code>pad</code> <p>Add padding to the image/stimuli.</p> <code>mkboxscr</code> <p>Make box scrambled stimuli.</p> <code>mkphasescr</code> <p>Make phase scrambled stimuli.</p> <code>filter</code> <p>Apply spatial frequency filter to the image.</p> <code>_logit</code> <p>Convert the ratio to log odds.</p> <code>_sigmoid</code> <p>Convert the log odds to the ratio.</p> <code>_repil</code> <p>Update the image PIL.</p> <code>_updatefrommat</code> <p>Update information from the image matrix.</p> <code>_newfilename</code> <p>Update the filename with newfname and newfolder.</p> <code>_setgroup</code> <p>Set the group name of the image.</p> <code>_setgpath</code> <p>Set the global path of the image.</p> <code>_filter</code> <p>Apply spatial frequency filter to the image.</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>class image:\n    \"\"\"A class to process a single image.\n\n    Parameters\n    ----------\n    filename : str\n        path and image filename.  \n    read : bool, optional\n        Whether to read the image via PIL, by default False.\n\n    Attributes\n    ----------\n    filename : str\n        path and image filename.\n    fname : str\n        the image filename.\n    fnonly : str\n        the image filename without extension.\n    ext : str\n        the image extension.\n    dirname : str\n        the image directory.\n    isfile : bool\n        whether the image file exists.\n    group : str\n        the group name of the image.\n    gpath : str\n        the global path of the image.\n    pil : PIL.Image\n        the PIL image.\n    mat : np.array\n        the image matrix.\n    dims : tuple\n        the image dimensions.\n    ndim : int\n        the number of dimensions.\n    h : int\n        the height of the image.\n    w : int\n        the width of the image.\n    nchan : int\n        the number of channels.\n    rgbmat : np.array\n        the RGB matrix.\n    amat : np.array\n        the alpha matrix.\n\n    Attributes\n    ----------\n    filename : str\n        Return the image filename.\n    fname : str\n        Return the image filename.\n    fnonly : str\n        Return the image filename without extension.\n    ext : str\n        Return the image extension.\n    dirname : str\n        Return the image directory.\n    isfile : bool\n        Return whether the image file exists.\n    dims : tuple\n        Return the image dimensions.\n    ndim : int\n        Return the number of dimensions.\n    h : int\n        Return the height of the image.\n    w : int\n        Return the width of the image.\n    nchan : int\n        Return the number of channels.\n    maxlum : float\n        Return the maximum luminance of the image.\n    minlum : float\n        Return the minimum luminance of the image.\n    meanlum : float\n        Return the mean luminance of the image.\n    rms : float\n        Return the RMS of the image.\n    luminfo : None\n        Print the luminance information of the image.\n\n    Methods\n    -------\n    update_fninfor()\n        Update the image filename related information.\n    updateext(ext)\n        Update the filename information.\n    read()\n        Read the image via PIL.\n    imshow()\n        Show the image matrix.\n    show()\n        Show the image PIL.\n    imsave(newfname='', newfolder='', addfn=True, **kwargs)\n        Save the image mat.\n    save(newfname='', newfolder='', addfn=True, **kwargs)\n        Save the image PIL.\n    deepcopy()\n        Make a deep copy of the instance.\n    remat(mat)\n        Re-assign value to .mat and update related information.\n    torgba()\n        Convert the image to RGBA.\n    grayscale()\n        Convert the image to gray-scale.\n    addbg(bgcolor=(255,255,255))\n        Add background to the RGBA image.\n    rotate(angle=180)\n        Rotate the image unclockwise.\n    stdmat(clip=2, lum=[0,255], range = None)\n        Standardize the image matrix.\n    adjust_pil(lum=None, rms=None, mask=None)\n        Adjust the luminance and contrast of the image with `pillow`.\n    cropoval(radius=(100,128), bgcolor=None)\n        Crop the image with an oval shape.\n    croprect(box=None)\n        Crop the image with a rectangle box.\n    resize(**kwargs)\n        Resize the image.\n    pad(**kwargs)\n        Add padding to the image/stimuli.\n    mkboxscr(**kwargs)\n        Make box scrambled stimuli.\n    mkphasescr(**kwargs)\n        Make phase scrambled stimuli.\n    filter(**kwargs)\n        Apply spatial frequency filter to the image.\n    _logit(ratio=None, correction=0.00001)\n        Convert the ratio to log odds.\n    _sigmoid(logodds, correction=0.00001)\n        Convert the log odds to the ratio.\n    _repil(pil)\n        Update the image PIL.\n    _updatefrommat()\n        Update information from the image matrix.\n    _newfilename(newfname='', newfolder='', addfn=True)\n        Update the filename with newfname and newfolder.\n    _setgroup(gname='')\n        Set the group name of the image.\n    _setgpath(gpath='')\n        Set the global path of the image.\n    _filter(**kwargs)\n        Apply spatial frequency filter to the image.\n    \"\"\"\n\n    def __init__(self, filename, read=False):\n        \"\"\"Create an image instance.\n\n        Parameters\n        ----------\n        filename : str\n            path and image filename.  \n        read : bool, optional\n            Whether to read the image via PIL, by default False.\n\n        Raises\n        ------\n        AssertionError\n            If the file does not exist.\n        \"\"\"\n        # make sure the file exists \n        self._filename = filename\n        self.update_fninfo(filename, newfn=False) \n        self._setgroup() \n        self._setgpath()\n        if read: self.read()\n\n    @property\n    def filename(self):\n        \"\"\"Return the image filename.\n\n        Returns\n        -------\n        str\n            the image filename.\n        \"\"\"\n        return self._filename\n\n    def update_fninfo(self, filename, newfn=True):\n        \"\"\"Set the image filename.\n\n        Parameters\n        ----------\n        filename : str\n            path and image filename.\n        newfn : bool, optional\n            whether `filename` is a new file name, by default True. So it will not check whether the file exists.\n        \"\"\"\n        if newfn &amp; os.path.isfile(filename):\n            # throw warning if filename is newly created and exists\n            warnings.warn(f\"The file named '{filename}' already exists...\")\n        elif not newfn:\n            # throw error if filename is not new and does not exist\n            assert os.path.isfile(filename) | (not bool(filename)), f'Cannot find {filename}...'\n\n        self._filename = filename\n        self._fname = os.path.basename(filename)\n        self._fnonly = \".\".join(os.path.splitext(self._fname)[0:-1])\n        self._ext = os.path.splitext(self._fname)[-1]\n        self._dirname = os.path.dirname(filename)\n        self._isfile = os.path.isfile(filename)\n\n    @property\n    def fname(self):\n        \"\"\"Return the image filename.\n\n        Returns\n        -------\n        str\n            the image filename.\n        \"\"\"\n        return self._fname\n\n    @property\n    def fnonly(self):\n        \"\"\"Return the image filename without extension.\n\n        Returns\n        -------\n        str\n            the image filename without extension.\n        \"\"\"\n        return self._fnonly\n\n    @property\n    def ext(self):\n        \"\"\"Return the image extension.\n\n        Returns\n        -------\n        str\n            the image extension.\n        \"\"\"\n        return self._ext\n\n    @property\n    def dirname(self):\n        \"\"\"Return the image directory.\n\n        Returns\n        -------\n        str\n            the image directory.\n        \"\"\"\n        return self._dirname\n\n    @property\n    def isfile(self):\n        \"\"\"Return whether the image file exists.\n\n        Returns\n        -------\n        bool\n            whether the image file exists.\n        \"\"\"\n        return self._isfile\n\n    def updateext(self, ext):\n        \"\"\"Update the filename information.\n\n        Parameters\n        ----------\n        ext : str\n            the new extension.\n        \"\"\"\n        if ext[0] != '.':\n            ext = '.'+ext\n        self.update_fninfo(self._dirname + os.sep + self._fnonly + ext)\n\n    def read(self):\n        \"\"\"Read the image via PIL.\n        \"\"\"\n        self._repil(Image.open(self.filename)) # PIL.Image.open() \n        # potential useful functions\n        # .filename .format, .mode, .split()\n\n    def _setgroup(self, gname=''):\n        \"\"\"Set the group name of the image.\n\n        Parameters\n        ----------\n        gname : str, optional\n            the group name, by default the upper directory name of the image.\n        \"\"\"\n        # update group information\n        if not bool(gname):\n            gname = os.path.split(os.path.dirname(self.filename))[1]\n        self.group = gname\n\n    def _setgpath(self, gpath=''):\n        \"\"\"Set the global path of the image (among other images). [This atribute matters only when mutiltple images are processed together. more see dir().]\n\n        Parameters\n        ----------\n        gpath : str, optional\n            global path, i.e. path in dir(), by default ''\n        \"\"\"\n        self.gpath = gpath\n\n    def imshow(self):\n        \"\"\"Show the image matrix.\n        \"\"\"\n        # for debugging purpose (check the mat)\n        # it seems that .show() is more useful\n        Image.fromarray(self.mat).show()\n\n    def show(self):\n        \"\"\"Show the image PIL.\n        \"\"\"\n        # for debugging purpose (check the PIL)\n        self.pil.show()\n\n    def imsave(self, newfname='', newfolder='', addfn=True, **kwargs):\n        \"\"\"Save the image mat.\n\n        Parameters\n        ----------\n        newfname : str, optional\n            strings to be added before the extension, by default ''\n        newfolder : str, optional\n            folder name to replace the global directory or the last directory level, by default ''\n        addfn : bool, optional\n            whether to add the newfname to the the original fname (instead of replacing it), by default True\n        kwargs : dict, optional\n            keyword arguments for matplotlib.pyplot.imsave(), by default {}\n        \"\"\"\n        # update the filename\n        self._newfilename(newfname, newfolder, addfn=addfn)\n\n        # make dir(s)\n        if not os.path.isdir(os.path.dirname(self.filename)):\n            os.makedirs(os.path.dirname(self.filename))\n        if self._nchan==1:\n            outmat = self.mat[:,:,0]\n        else:\n            outmat = self.mat\n\n        # use matplotlib.pyplot.imsave() to save .mat\n        mpimg.imsave(self.filename,outmat,**kwargs)\n        # mpimg.imsave(self.filename,outmat.copy(order='C'),**kwargs)\n        self._isfile = os.path.isfile(self.filename)\n\n\n    def save(self, newfname='', newfolder='', addfn=True, **kwargs):\n        \"\"\"Save the image PIL.\n\n        Parameters\n        ----------\n        newfname : str, optional\n            strings to be added before the extension, by default ''\n        newfolder : str, optional\n            folder name to replace the global directory or the last directory level, by default ''\n        addfn : bool, optional\n            whether to add the newfname to the the original fname (instead of replacing it), by default True\n        kwargs : dict, optional\n            keyword arguments for matplotlib.pyplot.imsave(), by default {}\n        \"\"\"\n        # update the filename\n        self._newfilename(newfname, newfolder, addfn=addfn)\n\n        # make dir(s)\n        if not os.path.isdir(os.path.dirname(self.filename)):\n            os.makedirs(os.path.dirname(self.filename))\n\n        # use PIL.Image.save() to save .pil    \n        self.pil.save(self.filename, format=None, **kwargs)\n        self._isfile = os.path.isfile(self.filename)\n\n\n    def touch(self, touchfolder=''):\n        \"\"\"Touch a new empty file.\n\n        Parameters\n        ----------\n        touchfolder : str, optional\n            folder name to replace the global directory or the last directory level, by default ''\n        \"\"\"\n        # update the directory\n        self._newfilename(newfolder=touchfolder)\n\n        if self.isfile:\n            # throw warnings if file exists\n            warnings.warn(\"The file named '%s' already exists...\" % self.filename)\n        else:\n            # make dir if needed\n            if not os.path.isdir(self._dirname):\n                os.makedirs(self._dirname)\n            # touch the file\n            Path(self.filename).touch()\n\n\n    def _newfilename(self, newfname='', newfolder='', addfn=True):\n        \"\"\"Update the filename with newfname and newfolder.\n\n        Parameters\n        ----------\n        newfname : str, optional\n            strings to be added before the extension, by default ''\n        newfolder : str, optional\n            folder name to replace the global directory or the last directory level, by default ''\n        addfn : bool, optional\n            whether to add the newfname to the the original fname (instead of replacing it), by default True\n        \"\"\"\n        # apply newfname to the old one\n        oldfname = os.path.splitext(self._fname)[0] if addfn else ''\n        fname = oldfname+newfname+os.path.splitext(self._fname)[1]\n\n        # replace the path folder with newfolder\n        if bool(self.gpath):\n            # rename the global path and filename\n            foldername = newfolder if bool(newfolder) else os.path.basename(self.gpath) # apply newfolder to the old one if needed\n            group = self.group if self.group != 'path' else ''\n            self.update_fninfo(os.path.join(os.path.dirname(self.gpath), foldername, group, fname))\n            self.gpath = os.path.join(os.path.dirname(self.gpath), foldername)\n        else:\n            foldername = newfolder if bool(newfolder) else os.path.basename(self._dirname) # apply newfolder to the old one if needed\n            self.update_fninfo(os.path.join(os.path.dirname(self.filename), foldername, fname))\n\n    def deepcopy(self):\n        \"\"\"make a deep copy of the instance\n        \"\"\"\n        return copy.deepcopy(self)\n\n\n    def remat(self, mat, mode=None):\n        \"\"\"Re-assign value to .mat and update related information.\n\n        Parameters\n        ----------\n        mat : np.array\n            the new image matrix.\n        \"\"\"\n        # re-assign value to .mat and update related information\n        self.mat = mat\n        self.pil = Image.fromarray(mat, mode=mode)\n        self._updatefrommat()\n\n\n    def _repil(self, pil):\n        self.pil = pil\n        self.mat = np.asarray(self.pil)\n        self._updatefrommat()\n\n    def _updatefrommat(self):\n        self._dims = self.mat.shape\n        self._ndim = len(self._dims)\n        self._h = self._dims[0]\n        self._w = self._dims[1]\n        self._nchan = self._dims[2] if self._ndim==3 else 0\n\n    @property\n    def dims(self):\n        \"\"\"Return the image dimensions.\n\n        Returns\n        -------\n        tuple\n            the image dimensions.\n        \"\"\"\n        return self._dims\n\n    @property\n    def ndim(self):\n        \"\"\"Return the number of dimensions.\n\n        Returns\n        -------\n        int\n            the number of dimensions.\n        \"\"\"\n        return self._ndim\n\n    @property\n    def h(self):\n        \"\"\"Return the height of the image.\n\n        Returns\n        -------\n        int\n            the height of the image.\n        \"\"\"\n        return self._h\n\n    @property\n    def w(self):\n        \"\"\"Return the width of the image.\n\n        Returns\n        -------\n        int\n            the width of the image.\n        \"\"\"\n        return self._w\n\n    @property\n    def nchan(self):\n        \"\"\"Return the number of channels.\n\n        Returns\n        -------\n        int\n            the number of channels.\n        \"\"\"\n        return self._nchan\n\n    @property\n    def maxlum(self):\n        \"\"\"Return the maximum luminance of the image.\n\n        Returns\n        -------\n        float\n            the maximum luminance of the image.\n        \"\"\"\n        return np.max(self.mat)\n\n    @property\n    def minlum(self):\n        \"\"\"Return the minimum luminance of the image.\n\n        Returns\n        -------\n        float\n            the minimum luminance of the image.\n        \"\"\"\n        return np.min(self.mat)\n\n    @property\n    def meanlum(self):\n        \"\"\"Return the mean luminance of the image.\n\n        Returns\n        -------\n        float\n            the mean luminance of the image.\n        \"\"\"\n        return np.mean(self.mat)\n\n    @property\n    def rms(self):\n        \"\"\"Return the RMS of the image.\n\n        Returns\n        -------\n        float\n            the RMS of the image.\n        \"\"\"\n        return np.std(self.mat)\n\n    @property\n    def luminfo(self):\n        \"\"\"Print the luminance information of the image.\n        \"\"\"\n        print(f'Maximum luminance: {self.maxlum}\\n'+\n              f'Minimum luminance: {self.minlum}\\n'+\n              f'Mean luminance: {self.meanlum}\\n'+\n              f'RMS: {self.rms}')\n\n\n    def torgba(self):\n        \"\"\"Convert the image to RGBA.\n        \"\"\"\n        # convert pil to RGBA and save in .mat\n        if len(self.mat.shape)==2: # Gray\n            self.mat = self.mat[..., np.newaxis]\n        assert len(self.mat.shape)==3\n\n        nchan = self.mat.shape[2]\n        if nchan==1: # Gray 'L'\n            rgbmat = np.repeat(self.mat, 3, axis=2) # RGB\n            alphavalue = 255 if rgbmat.max()&gt;1 else 1\n            amat = np.ones_like(rgbmat[:,:,0],dtype=np.uint8)*alphavalue # alpha\n        elif nchan==2: # Gray 'LA'\n            rgbmat = np.repeat(self.mat[:,:,0:1], 3, axis=2) # RGB\n            amat = self.mat[:,:,-1] # alpha\n        elif nchan==3: # RGB\n            rgbmat = self.mat # RGB\n            alphavalue = 255 if rgbmat.max()&gt;1 else 1\n            amat = np.ones_like(rgbmat[:,:,0],dtype=np.uint8)*alphavalue # alpha\n        elif nchan==4: # RGBA\n            rgbmat = self.mat[:,:,0:3]\n            amat = self.mat[:,:,-1]\n\n        self.rgbmat = rgbmat\n        self.amat = amat\n        self.remat(np.concatenate((rgbmat, amat[..., np.newaxis]), axis=2), 'RGBA')\n\n\n    def grayscale(self):\n        \"\"\"Convert the image to gray-scale.\n        \"\"\"\n        # convert image to gray-scale\n        self._repil(ImageOps.grayscale(self.pil))\n\n\n    def addbg(self, bgcolor=(255,255,255)):\n        \"\"\"Add background to the RGBA image.\n\n        Parameters\n        ----------\n        bgcolor : list, optional\n            the background color. Defaults to (255,255,255).\n        \"\"\"\n\n        if len(bgcolor)&gt;4:\n            bgcolor = bgcolor[:4]\n\n        # make sure the image is in RGBA\n        if self._ndim&lt;4:\n            self.torgba()\n\n        # make a new image with the same size and the background color\n        bg = Image.new('RGBA', (self._w, self._h), tuple(bgcolor))\n        # paste self to the background image\n        bg.paste(self.pil, (0,0), self.pil)\n        # apply pil\n        self._repil(bg)\n\n\n    def _logit(self, ratio=None, correction=0.00001):\n        \"\"\"Convert the ratio to log odds.\n\n        Parameters\n        ----------\n        ratio : np.array, optional\n            the ratio of the image. Defaults to None.\n        correction : float, optional\n            the correction value. Defaults to 0.00001.\n\n        Returns\n        -------\n        np.array\n            the log odds of the image.\n        \"\"\"\n\n        if ratio is None:\n            self.grayscale()\n            ratio = self.mat/255\n        elif type(ratio) is not np.ndarray:\n            ratio = np.array(ratio)\n\n        ratio[ratio==1] = (255-correction)/255\n        ratio[ratio==0] = correction/255\n\n        return np.log(ratio/(1-ratio))\n\n\n    def _sigmoid(self, logodds, correction=0.00001):\n        \"\"\"Convert the log odds to the ratio.\n\n        Parameters\n        ----------\n        logodds : np.array\n            the log odds of the image.\n        correction : float, optional\n            the correction value. Defaults to 0.00001.\n\n        Returns\n        -------\n        np.array\n            the ratio of the image.\n        \"\"\"\n\n        ratio = np.exp(logodds)/(np.exp(logodds)+1)\n        ratio[ratio&gt;=(1-correction)] = 1\n        ratio[ratio&lt;=(correction)] = 0\n\n        gray = ratio * 255\n\n        return gray.astype(dtype=np.uint8)\n\n\n    def rotate(self, angle=180):\n        \"\"\"Rotate the image unclockwise.\n\n        Parameters\n        ----------\n        angle : float\n            the angle to rotate the image. Defaults to 180.\n        \"\"\"\n        # rotate the image\n        self._repil(self.pil.rotate(angle))\n\n\n    def stdmat(self, clip=2, matkey='mat'):\n        \"\"\"Standardize the image with the desired Root-Mean-Square contrast or `outrange`. This function applies to self.\n\n        Parameters\n        ----------\n        clip : float, optional\n            the desired clip value. Defaults to 2.\n        matkey : str, optional\n            the key/name of the matrix to be standardized. Default to 'mat'.\n        \"\"\"\n\n        mat = getattr(self, matkey)\n        mat_out = self._stdmat(mat, clip=clip)\n        setattr(self, matkey, mat_out)\n\n        # update the image matrix to self\n        self.remat(mat_out.astype(dtype=np.uint8))\n\n\n    def _stdmat(self, mat, clip=2):\n        \"\"\"Standardize the image.\n\n        For the algorithm, see Appendix B in \n        Loschky, L. C., Sethi, A., Simons, D. J., Pydimarri, T. N., Ochs, D., &amp; Corbeille, J. L. (2007). The importance of information localization in scene gist recognition. Journal of Experimental Psychology: Human Perception and Performance, 33(6), 1431-1450. https://doi.org/10.1037/0096-1523.33.6.1431\n        Perfetto, S., Wilder, J., &amp; Walther, D. B. (2020). Effects of spatial frequency filtering choices on the perception of filtered images. Vision, 4(2), Article 2. https://doi.org/10.3390/vision4020029\n\n        Parameters\n        ----------\n        mat : np.array\n            the image matrix.\n        clip : float, optional\n            the desired clip value. Defaults to 2.\n\n        Returns\n        -------\n        np.array\n            the standardized image matrix, the range of the output is [-clip, clip].\n        \"\"\"\n        # convert the image to double\n        mat = mat.astype('double')\n\n        # standardize the image (the range of output should be -1,1)\n        mat_std = (mat - np.mean(mat))/np.std(mat)\n\n        # clip the image\n        clip = np.abs(clip)\n        if clip &gt; 0:\n            Nclipped = np.round(np.mean(np.abs(mat_std)&gt;clip) * 100, 2)\n            print(f'Clipped {Nclipped}% pixels...')\n\n            mat_std[mat_std&gt;clip] = clip\n            mat_std[mat_std&lt;-clip] = -clip\n\n            # rescale with std due to clipping\n            mat_std = mat_std / np.std(mat_std)\n\n        return mat_std\n\n\n    def rescale(self, range=None, matkey='mat'):\n        \"\"\"Rescale the image with the desired range. This function applies to self.\n\n        Parameters\n        ----------\n        range : list/tuple, optional\n            range to be used for standardization, by default None\n        matkey : str, optional\n            the key/name of the matrix to be standardized. Default to 'mat'.\n        \"\"\"\n        mat = getattr(self, matkey)\n\n        mat_out = self._rescale(mat, range=range)\n        setattr(self, matkey, mat_out)\n\n        # update the image matrix to self\n        self.remat(mat_out.astype(dtype=np.uint8))\n\n\n    def _rescale(self, mat, range=None):\n        \"\"\"Rescale the image matrix.\n\n        Parameters\n        ----------\n        mat : np.array\n            the image matrix.\n        range : list/tuple, optional\n            range to be used for standardization, by default None\n\n        Returns\n        -------\n        np.array\n            the rescaled image matrix.\n        \"\"\"\n        # rescale the image to the desired range\n        if range is None:\n            mat_min = np.min(mat)\n            mat_max = np.max(mat)\n\n        else:\n            mat_min = min(range)\n            mat_max = max(range)       \n\n        return (mat - mat_min) / (mat_max - mat_min) * 255 \n\n\n    def adjust_pil(self, lum=None, rms=None):\n        \"\"\"Adjust the luminance and contrast of the image with `pillow`.\n\n        Parameters\n        ----------\n        lum : int, optional\n            the luminance, by default None\n        rms : int, optional\n            the RMS contrast, by default None\n        \"\"\"\n        # adjust lumninance \n        enhancer = ImageEnhance.Brightness(self.pil)\n        brightness_factor = lum / ImageStat.Stat(self.pil.convert('L')).mean[0]\n        adjusted_image = enhancer.enhance(brightness_factor)\n\n        # adjust contrast of the image\n        enhancer = ImageEnhance.Contrast(adjusted_image)\n        contrast_factor = rms / ImageStat.Stat(adjusted_image.convert('L')).stddev[0]\n        adjusted_image = enhancer.enhance(contrast_factor)\n\n        self._repil(adjusted_image)\n\n\n    def cropoval(self, radius=(100,128), position=None, bgcolor=None, crop=True):\n        \"\"\"Crop the image with an oval shape.\n\n        Parameters\n        ----------\n        radius : tuple, optional\n            the radius of the oval. Defaults to (100,128).\n        position : tuple, optional\n            the position of the oval. Defaults to None.\n        bgcolor : tuple, optional\n            the background color. Defaults to None. For instance, if bgcolor is (255, 255, 255, 255), the output image is not transparent; if bgcolor is (255, 255, 255, 0), the output image is transparent.\n        sigma : float, optional\n            [Not in use] the standard deviation of the Gaussian blur. Defaults to 0, i.e., no blur.\n        crop : bool, optional\n            whether to crop the image to the oval (true) or keep its original dimension. Defaults to True.\n        \"\"\"\n\n        # duplicate the radius if only one value is given\n        if type(radius) is not tuple or len(radius) == 1:\n            radius = (radius, radius)\n\n        # by default, crop the image to the center\n        if position is None:\n            position = (self._w/2, self._h/2)\n\n        # to make circle\n        if type(radius) is not tuple:\n            radius = (radius, radius) # a and b in ellipse formula\n        bbox = (position[0]-radius[0], position[1]-radius[1], position[0]+radius[0], position[1]+radius[1])\n\n        # make a ellipse/oval mask\n        pil_a = Image.new(\"L\", self.pil.size, 0)\n        draw = ImageDraw.Draw(pil_a)\n        draw.ellipse(bbox, fill=255)\n\n        # apply Gaussian blur to the mask if needed\n        # if sigma&gt;0:\n        #     pil_a = pil_a.filter(ImageFilter.GaussianBlur(sigma))\n\n        if bgcolor is not None:\n            if type(bgcolor) is not tuple:\n                bgcolor = ((bgcolor),)*len(self.pil.mode)\n            pil_2 = Image.new(self.pil.mode, self.pil.size, bgcolor)\n            draw = ImageDraw.Draw(pil_2)\n            draw.ellipse(bbox, fill=255)\n            self.pil = Image.composite(self.pil, pil_2, pil_a)\n        else:\n            # only apply cropping to the alpha channel\n            self.pil.putalpha(pil_a)\n        # update to pil        \n        self._repil(self.pil)\n\n        # make it to a rectangle\n        if crop:\n            # make it a rectangle just containing the oval\n            self.croprect(bbox)\n        else:\n            # make it a rectangle containing the whole image\n            self.croprect((0, 0, self._w, self._h))\n\n\n    def croprect(self, box=None):\n        \"\"\"Crop the image with a rectangle box.\n\n        Parameters\n        ----------\n        box : tuple, optional\n            the box to crop the image. Defaults to None.\n        \"\"\"\n        # crop the image with a rectangle box\n        self._repil(self.pil.crop(box))\n\n\n    def resize(self, **kwargs):\n        \"\"\"Resize the image.\n\n        Other Parameters\n        ----------------\n        trgw : int\n            the width of the target/desired stimuli.\n        trgh : int\n            the height of the target/desired stimuli.\n        ratio : float\n            the ratio to resize the image. Defaults to 0.\n        newfolder : str\n            the folder to save the resized image. Defaults to None.\n        \"\"\"\n        # resize the image\n        defaultKwargs = {'trgw': None, 'trgh': None, 'ratio':0, 'newfolder':None}\n        kwargs = {**defaultKwargs, **kwargs}\n\n        if (kwargs['trgw'] is not None) &amp; (kwargs['trgh'] is not None):\n            (w, h) = (kwargs['trgw'], kwargs['trgh'])\n        elif (kwargs['trgw'] is not None) &amp; (kwargs['trgh'] is None):\n            w = kwargs['trgw']\n            h = int(w*self._h/self._w)\n        elif (kwargs['trgw'] is None) &amp; (kwargs['trgh'] is not None): \n            h = kwargs['trgh']\n            w = int(h*self._w/self._h)\n        elif kwargs['ratio']&gt;0:\n            w = int(self._w*kwargs['ratio'])\n            h = int(self._h*kwargs['ratio'])\n        else:\n            raise 'Cannot determine the desired dimentions...'\n\n        kwargs['size'] = (w,h)\n        if (kwargs['newfolder'] is None):\n            newfolder = str(w)+'_'+str(h)\n        else:\n            newfolder = kwargs['newfolder']\n\n        [kwargs.pop(k) for k in defaultKwargs.keys()] # remove unused keys\n\n        # save re-sized images (information)\n        self._repil(self.pil.resize(**kwargs))\n        self._newfilename(newfolder=newfolder)\n\n\n    def pad(self, **kwargs):  \n        \"\"\"\n        Add padding to the image/stimuli.\n\n        Other Parameters\n        ----------------\n        trgw : int\n            the width of the target/desired stimuli. \n        trgh : int\n            the height of the target/desired stimuli.\n        padvalue : int\n            padding value. Defaults to 0 (show as transparent if alpha channel exists).\n        top : bool\n            padding more to top if needed. Defaults to True.\n        left : bool \n            padding more to left if needed. Defaults to True.\n        padalpha : int\n            the transparent color. Defaults to -1, i.e., not to force it to transparent.\n        extrafn : str\n            the string to be added to the filename. Defaults to '_pad'.\n        \"\"\"\n\n        defaultKwargs = {'trgw':self._w, 'trgh':self._h, 'padvalue': 0, 'top': True, 'left':True, 'padalpha':-1, 'extrafn':'_pad'}\n        kwargs = {**defaultKwargs, **kwargs}\n\n        trgw,trgh = kwargs['trgw'], kwargs['trgh']\n\n        assert(trgw&gt;=self._w)\n        assert(trgh&gt;=self._h)\n\n        x1 = int(np.ceil(trgw-self._w)/2)\n        x2 = trgw-self._w-x1\n        y1 = int(np.ceil(trgh-self._h)/2)\n        y2 = trgh-self._h-y1\n\n        if kwargs['top']:\n            htop, hbot = y1,y2\n        else:\n            htop, hbot = y2,y1\n        if kwargs['left']:\n            wleft, wright = x1,x2\n        else:\n            wleft, wright = x2,x1\n\n        if self._nchan==0:\n            nchan = 1\n            mat = self.mat[..., np.newaxis] # add one more axis\n        else:\n            nchan = self._nchan\n            mat = self.mat\n\n        if (kwargs['padalpha']&gt;=0) &amp; (nchan==1 | nchan==3):\n            mat = np.concatenate((mat, np.ones((self._h, self._w, 1), dtype=np.uint8)*kwargs['padalpha']),axis=2)\n            nchan = nchan + 1\n\n        padmat = np.hstack((\n            np.ones((trgh,wleft,nchan),dtype=np.uint8)*kwargs['padvalue'], \n            np.vstack((\n                np.ones((htop,self._w,nchan),dtype=np.uint8)*kwargs['padvalue'], \n                mat,\n                np.ones((hbot,self._w,nchan),dtype=np.uint8)*kwargs['padvalue']\n            )),\n            np.ones((trgh,wright,nchan),dtype=np.uint8)*kwargs['padvalue'], \n        ))\n\n        if (self._nchan==0) &amp; (kwargs['padalpha']&lt;0):\n            padmat = padmat[:,:,0]\n\n        self.remat(padmat)\n        if kwargs['extrafn']!='':\n            self._newfilename(newfname=kwargs['extrafn'])\n\n\n    def mkboxscr(self, **kwargs):\n        \"\"\"Make box scrambled stimuli.\n\n        Other Parameters\n        ----------------\n        nBoxW : int\n            the number of boxes in width. Defaults to 10.\n        nBoxH : int\n            the number of boxes in height. Defaults to 16.\n        pBoxW : int\n            the width of a box. Defaults to 0.\n        pBoxH : int\n            the height of a box. Defaults to 0.\n        pad : bool\n            whether to add padding to the image. Defaults to False.\n        padcolor : int\n            the padding color. Defaults to 0.\n        padalpha : int\n            the padding alpha. Defaults to -1.\n        \"\"\"\n        defaultKwargs = {'nBoxW':10, 'nBoxH':16, \n                     'pBoxW':0, 'pBoxH':0, \n                     'pad': False, 'padcolor':0, 'padalpha': -1}\n        kwargs = {**defaultKwargs, **kwargs}\n\n        if (kwargs['pBoxW']!=0) &amp; (kwargs['pBoxH']!=0):\n\n            _nBoxW = self._w/kwargs['pBoxW']\n            _nBoxH = self._h/kwargs['pBoxH']\n\n            if not ((_nBoxW.is_integer()) &amp; (_nBoxH.is_integer())):\n                assert kwargs['pad'], 'Please input valid pBoxW and pBoxH. Or set \"pad\" to True.'\n\n                # add complementary parts to top and right\n                xnew = int(np.ceil(_nBoxW) * kwargs['pBoxW'])\n                ynew = int(np.ceil(_nBoxH) * kwargs['pBoxH'])\n\n                self.pad(trgw=xnew, trgh=ynew, padvalue=kwargs['padcolor'], padalpha=kwargs['padalpha'])\n\n            kwargs['nBoxW'] = int(self._w/kwargs['pBoxW'])\n            kwargs['nBoxH'] = int(self._h/kwargs['pBoxH'])\n\n        elif (kwargs['nBoxW']!=0) &amp; (kwargs['nBoxH']!=0):\n\n            # x and y pixels for each box\n            _pBoxW = self._w/kwargs['nBoxW']\n            _pBoxH = self._h/kwargs['nBoxH']\n\n            if not ((_pBoxW.is_integer()) &amp; (_pBoxH.is_integer())):\n                assert kwargs['pad'], 'Please input valid nBoxW and nBoxH. Or set \"pad\" to True.'\n\n                # add padding (top, right, bottom, left)\n                newW = int(np.ceil(_pBoxW) * kwargs['nBoxW'])\n                newY = int(np.ceil(_pBoxH) * kwargs['nBoxH'])\n                self.pad(trgw=newW, trgh=newY, padvalue=kwargs['padcolor'], padalpha=kwargs['padalpha'])\n\n            kwargs['pBoxW'] = int(self._w/kwargs['nBoxW'])\n            kwargs['pBoxH'] = int(self._h/kwargs['nBoxH'])\n        else:\n            raise 'Please set valid nBoxW and nBoxH (or pBoxW and pBoxH).'\n\n        assert kwargs['nBoxW']*kwargs['pBoxW']==self._w, f\"'nBoxW': {kwargs['nBoxW']}   'pBoxW': {kwargs['pBoxW']}    'self._w': {self._w}\"\n        assert kwargs['nBoxH']*kwargs['pBoxH']==self._h, f\"'nBoxH': {kwargs['nBoxH']}   'pBoxH': {kwargs['pBoxH']}    'self._h': {self._h}\"\n\n        # x and y for all boxes\n        xys = list(product(range(0,self._w,kwargs['pBoxW']), range(0,self._h,kwargs['pBoxH'])))\n        boxes = [self.mat[i[1]:(i[1]+kwargs['pBoxH']), i[0]:(i[0]+kwargs['pBoxW'])] for i in xys]\n        # randomize the boxes\n        bsboxes = np.random.permutation(boxes)\n        # save as np.array\n        bslist = [bsboxes[i:i+kwargs['nBoxW']] for i in range(0,len(bsboxes),kwargs['nBoxW'])]\n        # bsmat = np.moveaxis(np.asarray(bslist), [-1, 1], [0, -2]).reshape(-1, y, x)\n        bsmatm = np.asarray(bslist)\n        if len(bsmatm.shape)==4:\n            bsmatm = bsmatm[..., np.newaxis]\n        bsmat = np.moveaxis(bsmatm, [-1, 1], [0, -2]).reshape(-1, self._h, self._w)\n\n        # save box-scrambled images (and information)\n        self.remat(np.squeeze(np.moveaxis(bsmat,0,2)))\n        self._newfilename(newfname='_bscr')\n\n\n    def mkphasescr(self):\n        \"\"\"Make phase scrambled stimuli.\n        \"\"\"\n        # make a random phase\n        randphase = np.angle(np.fft.fft2(np.random.rand(self._h, self._w)))\n\n        if self._nchan==0:\n            nchan = 1\n            mat = self.mat[..., np.newaxis] # add one more axis\n        else:\n            nchan = self._nchan\n            mat = self.mat\n\n        outmat = np.empty(mat.shape)\n        outmat[:] = np.NaN\n\n        for i in range(nchan):\n            thismat = self.mat[:,:,i]\n            stdmat = (thismat - np.mean(thismat))/np.std(thismat)\n            img_freq = np.fft.fft2(stdmat)\n            amp = np.abs(img_freq)\n            phase = np.angle(img_freq) + randphase\n            outimg = np.real(np.fft.ifft2(amp * np.exp(np.sqrt(-1+0j)*phase)))\n            stdout= (outimg - np.mean(outimg))/np.std(outimg)\n            outmat[:,:,i] = (stdout - np.min(stdout)) * 255 / (np.max(stdout) - np.min(stdout))\n\n        if self._nchan==0:\n            outmat = outmat[:,:,0]\n\n        self.remat(np.uint8(outmat))\n        self._newfilename(newfname='_pscr')\n\n\n    def filter(self, **kwargs):\n        \"\"\"Filter the image with low-pass or high-pass filter.\n\n        Other Parameters\n        ----------------\n        filter : str\n            the filter type. Defaults to 'low'. Other option is 'high'.\n        vapi : int\n            visual angle per image. Defaults to 5.\n        cutoff : int\n            cycles per image (width) or cycles per degree if vapi&gt;0. Defaults to 8.\n        clip : int\n            the clip value. Defaults to 0, i.e., no clipping or normalization will be applied.\n        \"\"\"\n        # the other possible solution is:\n        # # https://www.djmannion.net/psych_programming/vision/sf_filt/sf_filt.html\n\n        defaultKwargs = {'filter':'low',\n                         'vapi': 5,  # visual angle per image\n                         'cutoff': 8,   # cycles per image (width) or cycles per degree if vapi&gt;0\n                         'clip': 0}   \n        kwargs = {**defaultKwargs, **kwargs}\n\n        # apply filter and save all LSF, HSF, and FS\n        images, sigma = self._filter(**kwargs)\n\n        # save the filtered images according to the filter type\n        if kwargs['filter'] in ['low', 'lsf', 'l']:\n            self.remat(images['lsf'].astype(dtype=np.uint8))\n            self.mat_filter = images['lsf']\n        elif kwargs['filter'] in ['high', 'hsf', 'h']:\n            self.remat(images['hsf'].astype(dtype=np.uint8))\n            self.mat_filter = images['hsf']\n        elif kwargs['filter'] in ['all', 'fs']:\n            # for debugging and standardization purpose\n            self.remat(images['fs'].astype(dtype=np.uint8))\n            self.mat_filter = images['fs']\n\n        # save the filter information\n        self.filterinfo = f'{kwargs[\"filter\"]}_{sigma}'\n\n        # update the filename\n        self._newfilename(newfname='_'+kwargs['filter'])\n\n\n    def _filter(self, **kwargs):\n        \"\"\"Filter the image with low-pass or high-pass filter. This function is used in filter().\n\n        Other Parameters\n        ----------------\n        vapi : int\n            visual angle per image. Defaults to 5.\n        cutoff : int\n            cycles per image (width) or cycles per degree if vapi&gt;0. Defaults to 8.\n        clip : int\n            the clip value. Defaults to 0, i.e., no clipping or normalization will be applied.\n\n        Returns\n        -------\n        dict\n            a dictionary with three keys: 'lsf', 'hsf', 'fs', corresponding to the low-pass filtered image, high-pass filtered image, and the original image, respectively.\n        \"\"\"\n\n        defaultKwargs = {'vapi': 5,  # visual angle per image\n                         'cutoff': 8,   # cutoff; cycles per image (width) or cycles per degree if vapi&gt;0\n                         'clip': 0}   \n        kwargs = {**defaultKwargs, **kwargs}\n\n        # grayscale image\n        self.grayscale()\n\n        # cycles per image (width) OR cycles per degree (along the width)\n        # FWHM = 2 * sqrt(2 * log(2)) * sigma\n        # sigma = self._w / (2 * np.pi * kwargs['cpi'] * kwargs['vapi'])\n        sigma = self._w / (kwargs['vapi'] * np.pi * np.sqrt(2 * np.log(2)) * kwargs['cutoff'])\n\n        # Apply low-pass filter\n        low_pass_image = self.pil.filter(ImageFilter.GaussianBlur(radius=sigma))\n        low_pass_mat = np.asarray(low_pass_image).astype('double')\n\n        # Create high-pass filter by subtracting low-pass image\n        # keep the negative values\n        high_pass_mat = self.mat.astype('double') - low_pass_mat.astype('double')\n        # make sure the minimum value is 0\n        high_pass_mat = high_pass_mat - np.min(high_pass_mat)\n        if np.any(high_pass_mat &gt; 255):\n            warnings.warn(\"Some values in the high-pass filtered image are above 255.\")\n            high_pass_mat = high_pass_mat / 255\n        # this does not work as expected, as it forces negative values to 0\n        # high_pass_image = ImageChops.subtract(self.pil, low_pass_image)\n        # high_pass_mat = np.asarray(high_pass_image)\n\n        # save output\n        mat_dict = {'lsf': low_pass_mat, \n                    'hsf': high_pass_mat,\n                    'fs': self.mat.astype('double')}\n\n        if kwargs['clip'] != 0:\n            # standardize across multiple images if clip is not 0\n            # similar to standardize() in __inti__.py\n\n            # standardize each image separately\n            mat_dict = {k: self._stdmat(mat=v, clip=kwargs['clip']) for k, v in mat_dict.items()}\n\n            # grand min and max\n            grand_min = min([np.min(v) for v in mat_dict.values()])\n            grand_max = max([np.max(v) for v in mat_dict.values()])\n\n            # Compute the grand normalized images\n            mat_dict = {k: self._rescale(mat=v, range=[grand_min,grand_max]) for k,v in mat_dict.items()}\n\n        return mat_dict, sigma\n</code></pre>"},{"location":"api/class/#pyfaceimage.im.image.dims","title":"<code>dims</code>  <code>property</code>","text":"<p>Return the image dimensions.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>the image dimensions.</p>"},{"location":"api/class/#pyfaceimage.im.image.dirname","title":"<code>dirname</code>  <code>property</code>","text":"<p>Return the image directory.</p> <p>Returns:</p> Type Description <code>str</code> <p>the image directory.</p>"},{"location":"api/class/#pyfaceimage.im.image.ext","title":"<code>ext</code>  <code>property</code>","text":"<p>Return the image extension.</p> <p>Returns:</p> Type Description <code>str</code> <p>the image extension.</p>"},{"location":"api/class/#pyfaceimage.im.image.filename","title":"<code>filename</code>  <code>property</code>","text":"<p>Return the image filename.</p> <p>Returns:</p> Type Description <code>str</code> <p>the image filename.</p>"},{"location":"api/class/#pyfaceimage.im.image.fname","title":"<code>fname</code>  <code>property</code>","text":"<p>Return the image filename.</p> <p>Returns:</p> Type Description <code>str</code> <p>the image filename.</p>"},{"location":"api/class/#pyfaceimage.im.image.fnonly","title":"<code>fnonly</code>  <code>property</code>","text":"<p>Return the image filename without extension.</p> <p>Returns:</p> Type Description <code>str</code> <p>the image filename without extension.</p>"},{"location":"api/class/#pyfaceimage.im.image.h","title":"<code>h</code>  <code>property</code>","text":"<p>Return the height of the image.</p> <p>Returns:</p> Type Description <code>int</code> <p>the height of the image.</p>"},{"location":"api/class/#pyfaceimage.im.image.isfile","title":"<code>isfile</code>  <code>property</code>","text":"<p>Return whether the image file exists.</p> <p>Returns:</p> Type Description <code>bool</code> <p>whether the image file exists.</p>"},{"location":"api/class/#pyfaceimage.im.image.luminfo","title":"<code>luminfo</code>  <code>property</code>","text":"<p>Print the luminance information of the image.</p>"},{"location":"api/class/#pyfaceimage.im.image.maxlum","title":"<code>maxlum</code>  <code>property</code>","text":"<p>Return the maximum luminance of the image.</p> <p>Returns:</p> Type Description <code>float</code> <p>the maximum luminance of the image.</p>"},{"location":"api/class/#pyfaceimage.im.image.meanlum","title":"<code>meanlum</code>  <code>property</code>","text":"<p>Return the mean luminance of the image.</p> <p>Returns:</p> Type Description <code>float</code> <p>the mean luminance of the image.</p>"},{"location":"api/class/#pyfaceimage.im.image.minlum","title":"<code>minlum</code>  <code>property</code>","text":"<p>Return the minimum luminance of the image.</p> <p>Returns:</p> Type Description <code>float</code> <p>the minimum luminance of the image.</p>"},{"location":"api/class/#pyfaceimage.im.image.nchan","title":"<code>nchan</code>  <code>property</code>","text":"<p>Return the number of channels.</p> <p>Returns:</p> Type Description <code>int</code> <p>the number of channels.</p>"},{"location":"api/class/#pyfaceimage.im.image.ndim","title":"<code>ndim</code>  <code>property</code>","text":"<p>Return the number of dimensions.</p> <p>Returns:</p> Type Description <code>int</code> <p>the number of dimensions.</p>"},{"location":"api/class/#pyfaceimage.im.image.rms","title":"<code>rms</code>  <code>property</code>","text":"<p>Return the RMS of the image.</p> <p>Returns:</p> Type Description <code>float</code> <p>the RMS of the image.</p>"},{"location":"api/class/#pyfaceimage.im.image.w","title":"<code>w</code>  <code>property</code>","text":"<p>Return the width of the image.</p> <p>Returns:</p> Type Description <code>int</code> <p>the width of the image.</p>"},{"location":"api/class/#pyfaceimage.im.image.__init__","title":"<code>__init__(filename, read=False)</code>","text":"<p>Create an image instance.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>path and image filename.</p> required <code>read</code> <code>bool</code> <p>Whether to read the image via PIL, by default False.</p> <code>False</code> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the file does not exist.</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>def __init__(self, filename, read=False):\n    \"\"\"Create an image instance.\n\n    Parameters\n    ----------\n    filename : str\n        path and image filename.  \n    read : bool, optional\n        Whether to read the image via PIL, by default False.\n\n    Raises\n    ------\n    AssertionError\n        If the file does not exist.\n    \"\"\"\n    # make sure the file exists \n    self._filename = filename\n    self.update_fninfo(filename, newfn=False) \n    self._setgroup() \n    self._setgpath()\n    if read: self.read()\n</code></pre>"},{"location":"api/class/#pyfaceimage.im.image.addbg","title":"<code>addbg(bgcolor=(255, 255, 255))</code>","text":"<p>Add background to the RGBA image.</p> <p>Parameters:</p> Name Type Description Default <code>bgcolor</code> <code>list</code> <p>the background color. Defaults to (255,255,255).</p> <code>(255, 255, 255)</code> Source code in <code>pyfaceimage/im.py</code> <pre><code>def addbg(self, bgcolor=(255,255,255)):\n    \"\"\"Add background to the RGBA image.\n\n    Parameters\n    ----------\n    bgcolor : list, optional\n        the background color. Defaults to (255,255,255).\n    \"\"\"\n\n    if len(bgcolor)&gt;4:\n        bgcolor = bgcolor[:4]\n\n    # make sure the image is in RGBA\n    if self._ndim&lt;4:\n        self.torgba()\n\n    # make a new image with the same size and the background color\n    bg = Image.new('RGBA', (self._w, self._h), tuple(bgcolor))\n    # paste self to the background image\n    bg.paste(self.pil, (0,0), self.pil)\n    # apply pil\n    self._repil(bg)\n</code></pre>"},{"location":"api/class/#pyfaceimage.im.image.adjust_pil","title":"<code>adjust_pil(lum=None, rms=None)</code>","text":"<p>Adjust the luminance and contrast of the image with <code>pillow</code>.</p> <p>Parameters:</p> Name Type Description Default <code>lum</code> <code>int</code> <p>the luminance, by default None</p> <code>None</code> <code>rms</code> <code>int</code> <p>the RMS contrast, by default None</p> <code>None</code> Source code in <code>pyfaceimage/im.py</code> <pre><code>def adjust_pil(self, lum=None, rms=None):\n    \"\"\"Adjust the luminance and contrast of the image with `pillow`.\n\n    Parameters\n    ----------\n    lum : int, optional\n        the luminance, by default None\n    rms : int, optional\n        the RMS contrast, by default None\n    \"\"\"\n    # adjust lumninance \n    enhancer = ImageEnhance.Brightness(self.pil)\n    brightness_factor = lum / ImageStat.Stat(self.pil.convert('L')).mean[0]\n    adjusted_image = enhancer.enhance(brightness_factor)\n\n    # adjust contrast of the image\n    enhancer = ImageEnhance.Contrast(adjusted_image)\n    contrast_factor = rms / ImageStat.Stat(adjusted_image.convert('L')).stddev[0]\n    adjusted_image = enhancer.enhance(contrast_factor)\n\n    self._repil(adjusted_image)\n</code></pre>"},{"location":"api/class/#pyfaceimage.im.image.cropoval","title":"<code>cropoval(radius=(100, 128), position=None, bgcolor=None, crop=True)</code>","text":"<p>Crop the image with an oval shape.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>tuple</code> <p>the radius of the oval. Defaults to (100,128).</p> <code>(100, 128)</code> <code>position</code> <code>tuple</code> <p>the position of the oval. Defaults to None.</p> <code>None</code> <code>bgcolor</code> <code>tuple</code> <p>the background color. Defaults to None. For instance, if bgcolor is (255, 255, 255, 255), the output image is not transparent; if bgcolor is (255, 255, 255, 0), the output image is transparent.</p> <code>None</code> <code>sigma</code> <code>float</code> <p>[Not in use] the standard deviation of the Gaussian blur. Defaults to 0, i.e., no blur.</p> required <code>crop</code> <code>bool</code> <p>whether to crop the image to the oval (true) or keep its original dimension. Defaults to True.</p> <code>True</code> Source code in <code>pyfaceimage/im.py</code> <pre><code>def cropoval(self, radius=(100,128), position=None, bgcolor=None, crop=True):\n    \"\"\"Crop the image with an oval shape.\n\n    Parameters\n    ----------\n    radius : tuple, optional\n        the radius of the oval. Defaults to (100,128).\n    position : tuple, optional\n        the position of the oval. Defaults to None.\n    bgcolor : tuple, optional\n        the background color. Defaults to None. For instance, if bgcolor is (255, 255, 255, 255), the output image is not transparent; if bgcolor is (255, 255, 255, 0), the output image is transparent.\n    sigma : float, optional\n        [Not in use] the standard deviation of the Gaussian blur. Defaults to 0, i.e., no blur.\n    crop : bool, optional\n        whether to crop the image to the oval (true) or keep its original dimension. Defaults to True.\n    \"\"\"\n\n    # duplicate the radius if only one value is given\n    if type(radius) is not tuple or len(radius) == 1:\n        radius = (radius, radius)\n\n    # by default, crop the image to the center\n    if position is None:\n        position = (self._w/2, self._h/2)\n\n    # to make circle\n    if type(radius) is not tuple:\n        radius = (radius, radius) # a and b in ellipse formula\n    bbox = (position[0]-radius[0], position[1]-radius[1], position[0]+radius[0], position[1]+radius[1])\n\n    # make a ellipse/oval mask\n    pil_a = Image.new(\"L\", self.pil.size, 0)\n    draw = ImageDraw.Draw(pil_a)\n    draw.ellipse(bbox, fill=255)\n\n    # apply Gaussian blur to the mask if needed\n    # if sigma&gt;0:\n    #     pil_a = pil_a.filter(ImageFilter.GaussianBlur(sigma))\n\n    if bgcolor is not None:\n        if type(bgcolor) is not tuple:\n            bgcolor = ((bgcolor),)*len(self.pil.mode)\n        pil_2 = Image.new(self.pil.mode, self.pil.size, bgcolor)\n        draw = ImageDraw.Draw(pil_2)\n        draw.ellipse(bbox, fill=255)\n        self.pil = Image.composite(self.pil, pil_2, pil_a)\n    else:\n        # only apply cropping to the alpha channel\n        self.pil.putalpha(pil_a)\n    # update to pil        \n    self._repil(self.pil)\n\n    # make it to a rectangle\n    if crop:\n        # make it a rectangle just containing the oval\n        self.croprect(bbox)\n    else:\n        # make it a rectangle containing the whole image\n        self.croprect((0, 0, self._w, self._h))\n</code></pre>"},{"location":"api/class/#pyfaceimage.im.image.croprect","title":"<code>croprect(box=None)</code>","text":"<p>Crop the image with a rectangle box.</p> <p>Parameters:</p> Name Type Description Default <code>box</code> <code>tuple</code> <p>the box to crop the image. Defaults to None.</p> <code>None</code> Source code in <code>pyfaceimage/im.py</code> <pre><code>def croprect(self, box=None):\n    \"\"\"Crop the image with a rectangle box.\n\n    Parameters\n    ----------\n    box : tuple, optional\n        the box to crop the image. Defaults to None.\n    \"\"\"\n    # crop the image with a rectangle box\n    self._repil(self.pil.crop(box))\n</code></pre>"},{"location":"api/class/#pyfaceimage.im.image.deepcopy","title":"<code>deepcopy()</code>","text":"<p>make a deep copy of the instance</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>def deepcopy(self):\n    \"\"\"make a deep copy of the instance\n    \"\"\"\n    return copy.deepcopy(self)\n</code></pre>"},{"location":"api/class/#pyfaceimage.im.image.filter","title":"<code>filter(**kwargs)</code>","text":"<p>Filter the image with low-pass or high-pass filter.</p> <p>Other Parameters:</p> Name Type Description <code>filter</code> <code>str</code> <p>the filter type. Defaults to 'low'. Other option is 'high'.</p> <code>vapi</code> <code>int</code> <p>visual angle per image. Defaults to 5.</p> <code>cutoff</code> <code>int</code> <p>cycles per image (width) or cycles per degree if vapi&gt;0. Defaults to 8.</p> <code>clip</code> <code>int</code> <p>the clip value. Defaults to 0, i.e., no clipping or normalization will be applied.</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>def filter(self, **kwargs):\n    \"\"\"Filter the image with low-pass or high-pass filter.\n\n    Other Parameters\n    ----------------\n    filter : str\n        the filter type. Defaults to 'low'. Other option is 'high'.\n    vapi : int\n        visual angle per image. Defaults to 5.\n    cutoff : int\n        cycles per image (width) or cycles per degree if vapi&gt;0. Defaults to 8.\n    clip : int\n        the clip value. Defaults to 0, i.e., no clipping or normalization will be applied.\n    \"\"\"\n    # the other possible solution is:\n    # # https://www.djmannion.net/psych_programming/vision/sf_filt/sf_filt.html\n\n    defaultKwargs = {'filter':'low',\n                     'vapi': 5,  # visual angle per image\n                     'cutoff': 8,   # cycles per image (width) or cycles per degree if vapi&gt;0\n                     'clip': 0}   \n    kwargs = {**defaultKwargs, **kwargs}\n\n    # apply filter and save all LSF, HSF, and FS\n    images, sigma = self._filter(**kwargs)\n\n    # save the filtered images according to the filter type\n    if kwargs['filter'] in ['low', 'lsf', 'l']:\n        self.remat(images['lsf'].astype(dtype=np.uint8))\n        self.mat_filter = images['lsf']\n    elif kwargs['filter'] in ['high', 'hsf', 'h']:\n        self.remat(images['hsf'].astype(dtype=np.uint8))\n        self.mat_filter = images['hsf']\n    elif kwargs['filter'] in ['all', 'fs']:\n        # for debugging and standardization purpose\n        self.remat(images['fs'].astype(dtype=np.uint8))\n        self.mat_filter = images['fs']\n\n    # save the filter information\n    self.filterinfo = f'{kwargs[\"filter\"]}_{sigma}'\n\n    # update the filename\n    self._newfilename(newfname='_'+kwargs['filter'])\n</code></pre>"},{"location":"api/class/#pyfaceimage.im.image.grayscale","title":"<code>grayscale()</code>","text":"<p>Convert the image to gray-scale.</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>def grayscale(self):\n    \"\"\"Convert the image to gray-scale.\n    \"\"\"\n    # convert image to gray-scale\n    self._repil(ImageOps.grayscale(self.pil))\n</code></pre>"},{"location":"api/class/#pyfaceimage.im.image.imsave","title":"<code>imsave(newfname='', newfolder='', addfn=True, **kwargs)</code>","text":"<p>Save the image mat.</p> <p>Parameters:</p> Name Type Description Default <code>newfname</code> <code>str</code> <p>strings to be added before the extension, by default ''</p> <code>''</code> <code>newfolder</code> <code>str</code> <p>folder name to replace the global directory or the last directory level, by default ''</p> <code>''</code> <code>addfn</code> <code>bool</code> <p>whether to add the newfname to the the original fname (instead of replacing it), by default True</p> <code>True</code> <code>kwargs</code> <code>dict</code> <p>keyword arguments for matplotlib.pyplot.imsave(), by default {}</p> <code>{}</code> Source code in <code>pyfaceimage/im.py</code> <pre><code>def imsave(self, newfname='', newfolder='', addfn=True, **kwargs):\n    \"\"\"Save the image mat.\n\n    Parameters\n    ----------\n    newfname : str, optional\n        strings to be added before the extension, by default ''\n    newfolder : str, optional\n        folder name to replace the global directory or the last directory level, by default ''\n    addfn : bool, optional\n        whether to add the newfname to the the original fname (instead of replacing it), by default True\n    kwargs : dict, optional\n        keyword arguments for matplotlib.pyplot.imsave(), by default {}\n    \"\"\"\n    # update the filename\n    self._newfilename(newfname, newfolder, addfn=addfn)\n\n    # make dir(s)\n    if not os.path.isdir(os.path.dirname(self.filename)):\n        os.makedirs(os.path.dirname(self.filename))\n    if self._nchan==1:\n        outmat = self.mat[:,:,0]\n    else:\n        outmat = self.mat\n\n    # use matplotlib.pyplot.imsave() to save .mat\n    mpimg.imsave(self.filename,outmat,**kwargs)\n    # mpimg.imsave(self.filename,outmat.copy(order='C'),**kwargs)\n    self._isfile = os.path.isfile(self.filename)\n</code></pre>"},{"location":"api/class/#pyfaceimage.im.image.imshow","title":"<code>imshow()</code>","text":"<p>Show the image matrix.</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>def imshow(self):\n    \"\"\"Show the image matrix.\n    \"\"\"\n    # for debugging purpose (check the mat)\n    # it seems that .show() is more useful\n    Image.fromarray(self.mat).show()\n</code></pre>"},{"location":"api/class/#pyfaceimage.im.image.mkboxscr","title":"<code>mkboxscr(**kwargs)</code>","text":"<p>Make box scrambled stimuli.</p> <p>Other Parameters:</p> Name Type Description <code>nBoxW</code> <code>int</code> <p>the number of boxes in width. Defaults to 10.</p> <code>nBoxH</code> <code>int</code> <p>the number of boxes in height. Defaults to 16.</p> <code>pBoxW</code> <code>int</code> <p>the width of a box. Defaults to 0.</p> <code>pBoxH</code> <code>int</code> <p>the height of a box. Defaults to 0.</p> <code>pad</code> <code>bool</code> <p>whether to add padding to the image. Defaults to False.</p> <code>padcolor</code> <code>int</code> <p>the padding color. Defaults to 0.</p> <code>padalpha</code> <code>int</code> <p>the padding alpha. Defaults to -1.</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>def mkboxscr(self, **kwargs):\n    \"\"\"Make box scrambled stimuli.\n\n    Other Parameters\n    ----------------\n    nBoxW : int\n        the number of boxes in width. Defaults to 10.\n    nBoxH : int\n        the number of boxes in height. Defaults to 16.\n    pBoxW : int\n        the width of a box. Defaults to 0.\n    pBoxH : int\n        the height of a box. Defaults to 0.\n    pad : bool\n        whether to add padding to the image. Defaults to False.\n    padcolor : int\n        the padding color. Defaults to 0.\n    padalpha : int\n        the padding alpha. Defaults to -1.\n    \"\"\"\n    defaultKwargs = {'nBoxW':10, 'nBoxH':16, \n                 'pBoxW':0, 'pBoxH':0, \n                 'pad': False, 'padcolor':0, 'padalpha': -1}\n    kwargs = {**defaultKwargs, **kwargs}\n\n    if (kwargs['pBoxW']!=0) &amp; (kwargs['pBoxH']!=0):\n\n        _nBoxW = self._w/kwargs['pBoxW']\n        _nBoxH = self._h/kwargs['pBoxH']\n\n        if not ((_nBoxW.is_integer()) &amp; (_nBoxH.is_integer())):\n            assert kwargs['pad'], 'Please input valid pBoxW and pBoxH. Or set \"pad\" to True.'\n\n            # add complementary parts to top and right\n            xnew = int(np.ceil(_nBoxW) * kwargs['pBoxW'])\n            ynew = int(np.ceil(_nBoxH) * kwargs['pBoxH'])\n\n            self.pad(trgw=xnew, trgh=ynew, padvalue=kwargs['padcolor'], padalpha=kwargs['padalpha'])\n\n        kwargs['nBoxW'] = int(self._w/kwargs['pBoxW'])\n        kwargs['nBoxH'] = int(self._h/kwargs['pBoxH'])\n\n    elif (kwargs['nBoxW']!=0) &amp; (kwargs['nBoxH']!=0):\n\n        # x and y pixels for each box\n        _pBoxW = self._w/kwargs['nBoxW']\n        _pBoxH = self._h/kwargs['nBoxH']\n\n        if not ((_pBoxW.is_integer()) &amp; (_pBoxH.is_integer())):\n            assert kwargs['pad'], 'Please input valid nBoxW and nBoxH. Or set \"pad\" to True.'\n\n            # add padding (top, right, bottom, left)\n            newW = int(np.ceil(_pBoxW) * kwargs['nBoxW'])\n            newY = int(np.ceil(_pBoxH) * kwargs['nBoxH'])\n            self.pad(trgw=newW, trgh=newY, padvalue=kwargs['padcolor'], padalpha=kwargs['padalpha'])\n\n        kwargs['pBoxW'] = int(self._w/kwargs['nBoxW'])\n        kwargs['pBoxH'] = int(self._h/kwargs['nBoxH'])\n    else:\n        raise 'Please set valid nBoxW and nBoxH (or pBoxW and pBoxH).'\n\n    assert kwargs['nBoxW']*kwargs['pBoxW']==self._w, f\"'nBoxW': {kwargs['nBoxW']}   'pBoxW': {kwargs['pBoxW']}    'self._w': {self._w}\"\n    assert kwargs['nBoxH']*kwargs['pBoxH']==self._h, f\"'nBoxH': {kwargs['nBoxH']}   'pBoxH': {kwargs['pBoxH']}    'self._h': {self._h}\"\n\n    # x and y for all boxes\n    xys = list(product(range(0,self._w,kwargs['pBoxW']), range(0,self._h,kwargs['pBoxH'])))\n    boxes = [self.mat[i[1]:(i[1]+kwargs['pBoxH']), i[0]:(i[0]+kwargs['pBoxW'])] for i in xys]\n    # randomize the boxes\n    bsboxes = np.random.permutation(boxes)\n    # save as np.array\n    bslist = [bsboxes[i:i+kwargs['nBoxW']] for i in range(0,len(bsboxes),kwargs['nBoxW'])]\n    # bsmat = np.moveaxis(np.asarray(bslist), [-1, 1], [0, -2]).reshape(-1, y, x)\n    bsmatm = np.asarray(bslist)\n    if len(bsmatm.shape)==4:\n        bsmatm = bsmatm[..., np.newaxis]\n    bsmat = np.moveaxis(bsmatm, [-1, 1], [0, -2]).reshape(-1, self._h, self._w)\n\n    # save box-scrambled images (and information)\n    self.remat(np.squeeze(np.moveaxis(bsmat,0,2)))\n    self._newfilename(newfname='_bscr')\n</code></pre>"},{"location":"api/class/#pyfaceimage.im.image.mkphasescr","title":"<code>mkphasescr()</code>","text":"<p>Make phase scrambled stimuli.</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>def mkphasescr(self):\n    \"\"\"Make phase scrambled stimuli.\n    \"\"\"\n    # make a random phase\n    randphase = np.angle(np.fft.fft2(np.random.rand(self._h, self._w)))\n\n    if self._nchan==0:\n        nchan = 1\n        mat = self.mat[..., np.newaxis] # add one more axis\n    else:\n        nchan = self._nchan\n        mat = self.mat\n\n    outmat = np.empty(mat.shape)\n    outmat[:] = np.NaN\n\n    for i in range(nchan):\n        thismat = self.mat[:,:,i]\n        stdmat = (thismat - np.mean(thismat))/np.std(thismat)\n        img_freq = np.fft.fft2(stdmat)\n        amp = np.abs(img_freq)\n        phase = np.angle(img_freq) + randphase\n        outimg = np.real(np.fft.ifft2(amp * np.exp(np.sqrt(-1+0j)*phase)))\n        stdout= (outimg - np.mean(outimg))/np.std(outimg)\n        outmat[:,:,i] = (stdout - np.min(stdout)) * 255 / (np.max(stdout) - np.min(stdout))\n\n    if self._nchan==0:\n        outmat = outmat[:,:,0]\n\n    self.remat(np.uint8(outmat))\n    self._newfilename(newfname='_pscr')\n</code></pre>"},{"location":"api/class/#pyfaceimage.im.image.pad","title":"<code>pad(**kwargs)</code>","text":"<p>Add padding to the image/stimuli.</p> <p>Other Parameters:</p> Name Type Description <code>trgw</code> <code>int</code> <p>the width of the target/desired stimuli.</p> <code>trgh</code> <code>int</code> <p>the height of the target/desired stimuli.</p> <code>padvalue</code> <code>int</code> <p>padding value. Defaults to 0 (show as transparent if alpha channel exists).</p> <code>top</code> <code>bool</code> <p>padding more to top if needed. Defaults to True.</p> <code>left</code> <code>bool</code> <p>padding more to left if needed. Defaults to True.</p> <code>padalpha</code> <code>int</code> <p>the transparent color. Defaults to -1, i.e., not to force it to transparent.</p> <code>extrafn</code> <code>str</code> <p>the string to be added to the filename. Defaults to '_pad'.</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>def pad(self, **kwargs):  \n    \"\"\"\n    Add padding to the image/stimuli.\n\n    Other Parameters\n    ----------------\n    trgw : int\n        the width of the target/desired stimuli. \n    trgh : int\n        the height of the target/desired stimuli.\n    padvalue : int\n        padding value. Defaults to 0 (show as transparent if alpha channel exists).\n    top : bool\n        padding more to top if needed. Defaults to True.\n    left : bool \n        padding more to left if needed. Defaults to True.\n    padalpha : int\n        the transparent color. Defaults to -1, i.e., not to force it to transparent.\n    extrafn : str\n        the string to be added to the filename. Defaults to '_pad'.\n    \"\"\"\n\n    defaultKwargs = {'trgw':self._w, 'trgh':self._h, 'padvalue': 0, 'top': True, 'left':True, 'padalpha':-1, 'extrafn':'_pad'}\n    kwargs = {**defaultKwargs, **kwargs}\n\n    trgw,trgh = kwargs['trgw'], kwargs['trgh']\n\n    assert(trgw&gt;=self._w)\n    assert(trgh&gt;=self._h)\n\n    x1 = int(np.ceil(trgw-self._w)/2)\n    x2 = trgw-self._w-x1\n    y1 = int(np.ceil(trgh-self._h)/2)\n    y2 = trgh-self._h-y1\n\n    if kwargs['top']:\n        htop, hbot = y1,y2\n    else:\n        htop, hbot = y2,y1\n    if kwargs['left']:\n        wleft, wright = x1,x2\n    else:\n        wleft, wright = x2,x1\n\n    if self._nchan==0:\n        nchan = 1\n        mat = self.mat[..., np.newaxis] # add one more axis\n    else:\n        nchan = self._nchan\n        mat = self.mat\n\n    if (kwargs['padalpha']&gt;=0) &amp; (nchan==1 | nchan==3):\n        mat = np.concatenate((mat, np.ones((self._h, self._w, 1), dtype=np.uint8)*kwargs['padalpha']),axis=2)\n        nchan = nchan + 1\n\n    padmat = np.hstack((\n        np.ones((trgh,wleft,nchan),dtype=np.uint8)*kwargs['padvalue'], \n        np.vstack((\n            np.ones((htop,self._w,nchan),dtype=np.uint8)*kwargs['padvalue'], \n            mat,\n            np.ones((hbot,self._w,nchan),dtype=np.uint8)*kwargs['padvalue']\n        )),\n        np.ones((trgh,wright,nchan),dtype=np.uint8)*kwargs['padvalue'], \n    ))\n\n    if (self._nchan==0) &amp; (kwargs['padalpha']&lt;0):\n        padmat = padmat[:,:,0]\n\n    self.remat(padmat)\n    if kwargs['extrafn']!='':\n        self._newfilename(newfname=kwargs['extrafn'])\n</code></pre>"},{"location":"api/class/#pyfaceimage.im.image.read","title":"<code>read()</code>","text":"<p>Read the image via PIL.</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>def read(self):\n    \"\"\"Read the image via PIL.\n    \"\"\"\n    self._repil(Image.open(self.filename)) # PIL.Image.open() \n</code></pre>"},{"location":"api/class/#pyfaceimage.im.image.remat","title":"<code>remat(mat, mode=None)</code>","text":"<p>Re-assign value to .mat and update related information.</p> <p>Parameters:</p> Name Type Description Default <code>mat</code> <code>array</code> <p>the new image matrix.</p> required Source code in <code>pyfaceimage/im.py</code> <pre><code>def remat(self, mat, mode=None):\n    \"\"\"Re-assign value to .mat and update related information.\n\n    Parameters\n    ----------\n    mat : np.array\n        the new image matrix.\n    \"\"\"\n    # re-assign value to .mat and update related information\n    self.mat = mat\n    self.pil = Image.fromarray(mat, mode=mode)\n    self._updatefrommat()\n</code></pre>"},{"location":"api/class/#pyfaceimage.im.image.rescale","title":"<code>rescale(range=None, matkey='mat')</code>","text":"<p>Rescale the image with the desired range. This function applies to self.</p> <p>Parameters:</p> Name Type Description Default <code>range</code> <code>list / tuple</code> <p>range to be used for standardization, by default None</p> <code>None</code> <code>matkey</code> <code>str</code> <p>the key/name of the matrix to be standardized. Default to 'mat'.</p> <code>'mat'</code> Source code in <code>pyfaceimage/im.py</code> <pre><code>def rescale(self, range=None, matkey='mat'):\n    \"\"\"Rescale the image with the desired range. This function applies to self.\n\n    Parameters\n    ----------\n    range : list/tuple, optional\n        range to be used for standardization, by default None\n    matkey : str, optional\n        the key/name of the matrix to be standardized. Default to 'mat'.\n    \"\"\"\n    mat = getattr(self, matkey)\n\n    mat_out = self._rescale(mat, range=range)\n    setattr(self, matkey, mat_out)\n\n    # update the image matrix to self\n    self.remat(mat_out.astype(dtype=np.uint8))\n</code></pre>"},{"location":"api/class/#pyfaceimage.im.image.resize","title":"<code>resize(**kwargs)</code>","text":"<p>Resize the image.</p> <p>Other Parameters:</p> Name Type Description <code>trgw</code> <code>int</code> <p>the width of the target/desired stimuli.</p> <code>trgh</code> <code>int</code> <p>the height of the target/desired stimuli.</p> <code>ratio</code> <code>float</code> <p>the ratio to resize the image. Defaults to 0.</p> <code>newfolder</code> <code>str</code> <p>the folder to save the resized image. Defaults to None.</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>def resize(self, **kwargs):\n    \"\"\"Resize the image.\n\n    Other Parameters\n    ----------------\n    trgw : int\n        the width of the target/desired stimuli.\n    trgh : int\n        the height of the target/desired stimuli.\n    ratio : float\n        the ratio to resize the image. Defaults to 0.\n    newfolder : str\n        the folder to save the resized image. Defaults to None.\n    \"\"\"\n    # resize the image\n    defaultKwargs = {'trgw': None, 'trgh': None, 'ratio':0, 'newfolder':None}\n    kwargs = {**defaultKwargs, **kwargs}\n\n    if (kwargs['trgw'] is not None) &amp; (kwargs['trgh'] is not None):\n        (w, h) = (kwargs['trgw'], kwargs['trgh'])\n    elif (kwargs['trgw'] is not None) &amp; (kwargs['trgh'] is None):\n        w = kwargs['trgw']\n        h = int(w*self._h/self._w)\n    elif (kwargs['trgw'] is None) &amp; (kwargs['trgh'] is not None): \n        h = kwargs['trgh']\n        w = int(h*self._w/self._h)\n    elif kwargs['ratio']&gt;0:\n        w = int(self._w*kwargs['ratio'])\n        h = int(self._h*kwargs['ratio'])\n    else:\n        raise 'Cannot determine the desired dimentions...'\n\n    kwargs['size'] = (w,h)\n    if (kwargs['newfolder'] is None):\n        newfolder = str(w)+'_'+str(h)\n    else:\n        newfolder = kwargs['newfolder']\n\n    [kwargs.pop(k) for k in defaultKwargs.keys()] # remove unused keys\n\n    # save re-sized images (information)\n    self._repil(self.pil.resize(**kwargs))\n    self._newfilename(newfolder=newfolder)\n</code></pre>"},{"location":"api/class/#pyfaceimage.im.image.rotate","title":"<code>rotate(angle=180)</code>","text":"<p>Rotate the image unclockwise.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>the angle to rotate the image. Defaults to 180.</p> <code>180</code> Source code in <code>pyfaceimage/im.py</code> <pre><code>def rotate(self, angle=180):\n    \"\"\"Rotate the image unclockwise.\n\n    Parameters\n    ----------\n    angle : float\n        the angle to rotate the image. Defaults to 180.\n    \"\"\"\n    # rotate the image\n    self._repil(self.pil.rotate(angle))\n</code></pre>"},{"location":"api/class/#pyfaceimage.im.image.save","title":"<code>save(newfname='', newfolder='', addfn=True, **kwargs)</code>","text":"<p>Save the image PIL.</p> <p>Parameters:</p> Name Type Description Default <code>newfname</code> <code>str</code> <p>strings to be added before the extension, by default ''</p> <code>''</code> <code>newfolder</code> <code>str</code> <p>folder name to replace the global directory or the last directory level, by default ''</p> <code>''</code> <code>addfn</code> <code>bool</code> <p>whether to add the newfname to the the original fname (instead of replacing it), by default True</p> <code>True</code> <code>kwargs</code> <code>dict</code> <p>keyword arguments for matplotlib.pyplot.imsave(), by default {}</p> <code>{}</code> Source code in <code>pyfaceimage/im.py</code> <pre><code>def save(self, newfname='', newfolder='', addfn=True, **kwargs):\n    \"\"\"Save the image PIL.\n\n    Parameters\n    ----------\n    newfname : str, optional\n        strings to be added before the extension, by default ''\n    newfolder : str, optional\n        folder name to replace the global directory or the last directory level, by default ''\n    addfn : bool, optional\n        whether to add the newfname to the the original fname (instead of replacing it), by default True\n    kwargs : dict, optional\n        keyword arguments for matplotlib.pyplot.imsave(), by default {}\n    \"\"\"\n    # update the filename\n    self._newfilename(newfname, newfolder, addfn=addfn)\n\n    # make dir(s)\n    if not os.path.isdir(os.path.dirname(self.filename)):\n        os.makedirs(os.path.dirname(self.filename))\n\n    # use PIL.Image.save() to save .pil    \n    self.pil.save(self.filename, format=None, **kwargs)\n    self._isfile = os.path.isfile(self.filename)\n</code></pre>"},{"location":"api/class/#pyfaceimage.im.image.show","title":"<code>show()</code>","text":"<p>Show the image PIL.</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>def show(self):\n    \"\"\"Show the image PIL.\n    \"\"\"\n    # for debugging purpose (check the PIL)\n    self.pil.show()\n</code></pre>"},{"location":"api/class/#pyfaceimage.im.image.stdmat","title":"<code>stdmat(clip=2, matkey='mat')</code>","text":"<p>Standardize the image with the desired Root-Mean-Square contrast or <code>outrange</code>. This function applies to self.</p> <p>Parameters:</p> Name Type Description Default <code>clip</code> <code>float</code> <p>the desired clip value. Defaults to 2.</p> <code>2</code> <code>matkey</code> <code>str</code> <p>the key/name of the matrix to be standardized. Default to 'mat'.</p> <code>'mat'</code> Source code in <code>pyfaceimage/im.py</code> <pre><code>def stdmat(self, clip=2, matkey='mat'):\n    \"\"\"Standardize the image with the desired Root-Mean-Square contrast or `outrange`. This function applies to self.\n\n    Parameters\n    ----------\n    clip : float, optional\n        the desired clip value. Defaults to 2.\n    matkey : str, optional\n        the key/name of the matrix to be standardized. Default to 'mat'.\n    \"\"\"\n\n    mat = getattr(self, matkey)\n    mat_out = self._stdmat(mat, clip=clip)\n    setattr(self, matkey, mat_out)\n\n    # update the image matrix to self\n    self.remat(mat_out.astype(dtype=np.uint8))\n</code></pre>"},{"location":"api/class/#pyfaceimage.im.image.torgba","title":"<code>torgba()</code>","text":"<p>Convert the image to RGBA.</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>def torgba(self):\n    \"\"\"Convert the image to RGBA.\n    \"\"\"\n    # convert pil to RGBA and save in .mat\n    if len(self.mat.shape)==2: # Gray\n        self.mat = self.mat[..., np.newaxis]\n    assert len(self.mat.shape)==3\n\n    nchan = self.mat.shape[2]\n    if nchan==1: # Gray 'L'\n        rgbmat = np.repeat(self.mat, 3, axis=2) # RGB\n        alphavalue = 255 if rgbmat.max()&gt;1 else 1\n        amat = np.ones_like(rgbmat[:,:,0],dtype=np.uint8)*alphavalue # alpha\n    elif nchan==2: # Gray 'LA'\n        rgbmat = np.repeat(self.mat[:,:,0:1], 3, axis=2) # RGB\n        amat = self.mat[:,:,-1] # alpha\n    elif nchan==3: # RGB\n        rgbmat = self.mat # RGB\n        alphavalue = 255 if rgbmat.max()&gt;1 else 1\n        amat = np.ones_like(rgbmat[:,:,0],dtype=np.uint8)*alphavalue # alpha\n    elif nchan==4: # RGBA\n        rgbmat = self.mat[:,:,0:3]\n        amat = self.mat[:,:,-1]\n\n    self.rgbmat = rgbmat\n    self.amat = amat\n    self.remat(np.concatenate((rgbmat, amat[..., np.newaxis]), axis=2), 'RGBA')\n</code></pre>"},{"location":"api/class/#pyfaceimage.im.image.touch","title":"<code>touch(touchfolder='')</code>","text":"<p>Touch a new empty file.</p> <p>Parameters:</p> Name Type Description Default <code>touchfolder</code> <code>str</code> <p>folder name to replace the global directory or the last directory level, by default ''</p> <code>''</code> Source code in <code>pyfaceimage/im.py</code> <pre><code>def touch(self, touchfolder=''):\n    \"\"\"Touch a new empty file.\n\n    Parameters\n    ----------\n    touchfolder : str, optional\n        folder name to replace the global directory or the last directory level, by default ''\n    \"\"\"\n    # update the directory\n    self._newfilename(newfolder=touchfolder)\n\n    if self.isfile:\n        # throw warnings if file exists\n        warnings.warn(\"The file named '%s' already exists...\" % self.filename)\n    else:\n        # make dir if needed\n        if not os.path.isdir(self._dirname):\n            os.makedirs(self._dirname)\n        # touch the file\n        Path(self.filename).touch()\n</code></pre>"},{"location":"api/class/#pyfaceimage.im.image.update_fninfo","title":"<code>update_fninfo(filename, newfn=True)</code>","text":"<p>Set the image filename.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>path and image filename.</p> required <code>newfn</code> <code>bool</code> <p>whether <code>filename</code> is a new file name, by default True. So it will not check whether the file exists.</p> <code>True</code> Source code in <code>pyfaceimage/im.py</code> <pre><code>def update_fninfo(self, filename, newfn=True):\n    \"\"\"Set the image filename.\n\n    Parameters\n    ----------\n    filename : str\n        path and image filename.\n    newfn : bool, optional\n        whether `filename` is a new file name, by default True. So it will not check whether the file exists.\n    \"\"\"\n    if newfn &amp; os.path.isfile(filename):\n        # throw warning if filename is newly created and exists\n        warnings.warn(f\"The file named '{filename}' already exists...\")\n    elif not newfn:\n        # throw error if filename is not new and does not exist\n        assert os.path.isfile(filename) | (not bool(filename)), f'Cannot find {filename}...'\n\n    self._filename = filename\n    self._fname = os.path.basename(filename)\n    self._fnonly = \".\".join(os.path.splitext(self._fname)[0:-1])\n    self._ext = os.path.splitext(self._fname)[-1]\n    self._dirname = os.path.dirname(filename)\n    self._isfile = os.path.isfile(filename)\n</code></pre>"},{"location":"api/class/#pyfaceimage.im.image.updateext","title":"<code>updateext(ext)</code>","text":"<p>Update the filename information.</p> <p>Parameters:</p> Name Type Description Default <code>ext</code> <code>str</code> <p>the new extension.</p> required Source code in <code>pyfaceimage/im.py</code> <pre><code>def updateext(self, ext):\n    \"\"\"Update the filename information.\n\n    Parameters\n    ----------\n    ext : str\n        the new extension.\n    \"\"\"\n    if ext[0] != '.':\n        ext = '.'+ext\n    self.update_fninfo(self._dirname + os.sep + self._fnonly + ext)\n</code></pre>"},{"location":"api/function/","title":"function","text":"<p>Auto-generate API documentation using <code>mkdocstrings</code>. Add the following content:</p>"},{"location":"api/function/#api-reference","title":"API Reference","text":"<p>Functions to play with multiple (more than one) images.</p>"},{"location":"api/function/#pyfaceimage.multim.composite","title":"<code>composite(im_back, im_fore)</code>","text":"<p>Paste im_fore to im_back. im_back should not be smaller than im_fore.</p> <p>Parameters:</p> Name Type Description Default <code>im_back</code> <code>im.image() instance</code> <p>the background image.</p> required <code>im_fore</code> <code>im.image() instance</code> <p>the foreground image.</p> required <p>Returns:</p> Type Description <code>im.image() instance</code> <p>the final image.</p> Source code in <code>pyfaceimage/multim.py</code> <pre><code>def composite(im_back, im_fore):\n    \"\"\"Paste im_fore to im_back. im_back should not be smaller than im_fore.\n\n    Parameters\n    ----------\n    im_back : im.image() instance\n        the background image.\n    im_fore : im.image() instance\n        the foreground image.\n\n    Returns\n    -------\n    im.image() instance\n        the final image.\n    \"\"\"\n\n    # im_back should not be smaller than im_fore\n    assert im_back.w&gt;=im_fore.w and im_back.h&gt;=im_fore.h, f'im_back (({im_back.w, im_back.h})) should not be smaller than im_fore (({im_fore.w, im_fore.h})) .'\n\n    # pad im_fore if necessary\n    if im_back.w&gt;=im_fore.w or im_back.h&gt;=im_fore.h: \n        im_fore.pad(trgw=im_back.w, trgh=im_back.h)\n\n    # paste im_fore to im_back\n    im_back.pil.paste(im_fore.pil, mask=im_fore.pil)\n    im_back._repil(im_back.pil)\n\n    return im_back\n</code></pre>"},{"location":"api/function/#pyfaceimage.multim.concatenate","title":"<code>concatenate(im1, im2, axis=1, sep='-', padval=0)</code>","text":"<p>Concatenate two images along the specified axis.</p> <p>Parameters:</p> Name Type Description Default <code>im1</code> <code>im.image() instance</code> <p>the first image.</p> required <code>im2</code> <code>im.image() instance</code> <p>the second image.</p> required <p>Other Parameters:</p> Name Type Description <code>axis</code> <code>int</code> <p>the axis along which the images are concatenated. Defaults to 1, i.e. horizontally.</p> <code>sep</code> <code>str</code> <p>the separator between the two images. Defaults to \"-\".</p> <code>padval</code> <code>int</code> <p>the value to pad the images. Defaults to 0.</p> <p>Returns:</p> Type Description <code>im.image() instance</code> <p>the concatenated image.</p> Source code in <code>pyfaceimage/multim.py</code> <pre><code>def concatenate(im1, im2, axis=1, sep=\"-\", padval=0):\n    \"\"\"Concatenate two images along the specified axis.\n\n    Parameters\n    ----------\n    im1 : im.image() instance\n        the first image.\n    im2 : im.image() instance\n        the second image.\n\n    Other Parameters\n    ----------------\n    axis : int\n        the axis along which the images are concatenated. Defaults to 1, i.e. horizontally.\n    sep : str\n        the separator between the two images. Defaults to \"-\".\n    padval : int\n        the value to pad the images. Defaults to 0.\n\n    Returns\n    -------\n    im.image() instance\n        the concatenated image.\n    \"\"\"\n\n    im = im1.deepcopy()\n\n    # pad the images if necessary\n    if axis==0:\n        if im.w&gt;im2.w:\n            im2.pad(trgw=im.w, padval=padval)\n        elif im.w&lt;im2.w:\n            im.pad(trgw=im2.w, padval=padval)\n    elif axis==1:\n        if im.h&gt;im2.h:\n            im2.pad(trgh=im.h, padval=padval)\n        elif im.h&lt;im2.h:\n            im.pad(trgh=im2.h, padval=padval)\n\n    # concatenate the images\n    if axis==0:\n        im.pil = Image.fromarray(np.concatenate((im.pil, im2.pil), axis=0))\n    elif axis==1:\n        im.pil = Image.fromarray(np.concatenate((im.pil, im2.pil), axis=1))\n    im._repil(im.pil)\n\n    # update the filename\n    newfilename = im.fnonly+sep+im2.fnonly\n    im._newfilename(newfname=newfilename, addfn=False)\n\n    return (im, newfilename)\n</code></pre>"},{"location":"api/function/#pyfaceimage.multim.mkcf","title":"<code>mkcf(im1, im2, **kwargs)</code>","text":"<p>Make composite faces (for the composite face task) with im1 and im2.</p> <p>Parameters:</p> Name Type Description Default <code>im1</code> <code>im.image() instance</code> <p>one im.image() instane for creating composite faces.</p> required <code>im2</code> <code>im.image() instance</code> <p>another im.image() instane for creating composite faces.</p> required <p>Other Parameters:</p> Name Type Description <code>misali</code> <code>(int, num)</code> <p>misalignment. Positive int will shift to the right and negative int will shift to the left. If misali is int, it refers to pixels. If misali is decimal, it misali*face width is the amount of misalignment. Defaults to 0.</p> <code>topis1</code> <code>bool</code> <p>whether im1 (or im2) is used as the top of the composite face. Defaults to True.</p> <code>cueistop</code> <code>bool</code> <p>whether the top half is cued. Defaults to True.</p> <code>lineh</code> <code>int</code> <p>the height (in pixels) of the line between the top and bottom facial havles. Defaults to 3.</p> <code>distv</code> <code>int</code> <p>the vertical distance (in pixels) between the top and bottom facial halves. Defaults to 0.</p> <code>width_cf</code> <code>int</code> <p>the width of the composite face/the line (also the width of the output composite face image). Defaults to three times of the face width.</p> <code>lineclr</code> <code>int tuple</code> <p>the color of the line. Defaults to (255,255,255), i.e., white.</p> <code>showcue</code> <code>bool</code> <p>whether to display cue in the image. Defaults to False.</p> <code>cueclr</code> <code>int tuple</code> <p>the color of the cue. Defaults to the same as lineclr.</p> <code>cuethick</code> <code>int</code> <p>the thickness (in pixels) of the cue. Defaults to 4.</p> <code>cuew</code> <code>int</code> <p>the width (in pixels) of the cue. Defaults to 110% of the face width.</p> <code>cueh</code> <code>int</code> <p>the height (in pixels) of the very left and right parts of the cue. Defaults to about 5% of the face height.</p> <code>cuedist</code> <code>int</code> <p>distance from the main part of the cue to edge of the face. Defaults to twice of cueh.</p> <p>Returns:</p> Name Type Description <code>im.image() instance</code> <p>the composite face stimuli as a im.image() instance.</p> <code>fn_cf</code> <code>str</code> <p>the filename of the composite face stimuli.</p> Source code in <code>pyfaceimage/multim.py</code> <pre><code>def mkcf(im1, im2, **kwargs):\n    \"\"\"Make composite faces (for the composite face task) with im1 and im2.\n\n    Parameters\n    ----------\n    im1 : im.image() instance\n        one im.image() instane for creating composite faces.\n    im2 : im.image() instance\n        another im.image() instane for creating composite faces.\n\n    Other Parameters\n    ----------------\n    misali : int, num\n        misalignment. Positive int will shift to the right and negative int will shift to the left. If misali is int, it refers to pixels. If misali is decimal, it misali*face width is the amount of misalignment. Defaults to 0.\n    topis1 : bool\n        whether im1 (or im2) is used as the top of the composite face. Defaults to True.\n    cueistop : bool\n        whether the top half is cued. Defaults to True.\n    lineh : int\n        the height (in pixels) of the line between the top and bottom facial havles. Defaults to 3.\n    distv : int\n        the vertical distance (in pixels) between the top and bottom facial halves. Defaults to 0.\n    width_cf : int\n        the width of the composite face/the line (also the width of the output composite face image). Defaults to three times of the face width.\n    lineclr : int tuple\n        the color of the line. Defaults to (255,255,255), i.e., white.\n    showcue : bool\n        whether to display cue in the image. Defaults to False.\n    cueclr : int tuple\n        the color of the cue. Defaults to the same as lineclr.\n    cuethick : int\n        the thickness (in pixels) of the cue. Defaults to 4.\n    cuew : int\n        the width (in pixels) of the cue. Defaults to 110% of the face width.\n    cueh : int\n        the height (in pixels) of the very left and right parts of the cue. Defaults to about 5% of the face height.\n    cuedist : int\n        distance from the main part of the cue to edge of the face. Defaults to twice of cueh.\n\n    Returns\n    -------\n    im.image() instance\n        the composite face stimuli as a im.image() instance.\n    fn_cf : str\n        the filename of the composite face stimuli.\n    \"\"\"\n\n    defaultKwargs = {'misali':0, 'topis1': True, 'cueistop': True,\n                     'lineh':3, 'distv': 0, 'width_cf': im1.w*3, 'lineclr': None,\n                     'showcue':False, 'cueclr':None,\n                     'cuethick': 4, 'cuew': int(im1.w*1.1), 'cueh': int(im1.h*.05), 'cuedist': None}\n    kwargs = {**defaultKwargs, **kwargs}\n\n    # decide the width of the output CF image\n    w_cf = kwargs['width_cf']\n    if isinstance(kwargs['misali'], int):\n        misali = kwargs['misali']\n    else:\n        misali = int(kwargs['misali']*im1.w)\n    assert (misali+im1.w/2)&lt;=w_cf/2, f'Please make sure the width of the composite face ({w_cf}) is set appropriately to fit the misalignment ({misali}).'\n\n    # generate the default color for the (white) line\n    if kwargs['lineclr'] is None: \n        kwargs['lineclr'] = (255,) * im1.nchan # white line\n    else:\n        assert len(kwargs['lineclr'])==im1.nchan, f\"The lenght of 'lineclr' should match im1.nchan({im1.nchan})\"\n\n    if kwargs['cueclr'] is None: \n        kwargs['cueclr'] = kwargs['lineclr']\n    else:\n        assert len(kwargs['cueclr'])==im1.nchan, f\"The lenght of 'cueclr' should match im1.nchan({im1.nchan})\"\n\n    alistrs = ['ali', 'mis']\n    bboxes = [(0, 0, im1.w, im1.h/2), (0, im1.h/2, im1.w, im1.h)] # top, bottom\n    dests = [((w_cf-im1.w)//2+misali*(1-kwargs['cueistop']), 0), # top position\n             ((w_cf-im1.w)//2+misali*kwargs['cueistop'], im1.h//2+np.max([kwargs['lineh'], kwargs['distv']]))] # bottom position\n    fns_12 = [im1.fnonly, im2.fnonly]\n\n    fn_cf = os.path.join(fns_12[1-kwargs['topis1']]+'_'+fns_12[kwargs['topis1']]+'_'+alistrs[misali!=0])\n\n    # top and bottom pil\n    im1_half = im1.deepcopy()\n    im2_half = im2.deepcopy()\n    im1_half.croprect(bboxes[1-kwargs['topis1']])\n    im2_half.croprect(bboxes[kwargs['topis1']])\n\n    # create a new canvas and paste the image\n    dist_cf = Image.new(im1.pil.mode, (w_cf, im1.h+np.max([kwargs['lineh'], kwargs['distv']])))\n    # white line\n    drawl = ImageDraw.Draw(dist_cf)\n    if kwargs['lineh']&gt;1: # draw a white line for top\n        drawl.rectangle((0, im1.h//2, w_cf, im1.h//2+kwargs['lineh']-1),fill=kwargs['lineclr'])\n        if kwargs['distv']&gt;kwargs['lineh']: # draw another white line for bottom\n            drawl.rectangle((0, im1.h//2+kwargs['distv']-kwargs['lineh'], w_cf, im1.h//2+kwargs['distv']-1),fill=kwargs['lineclr'])\n    # top and bottom\n    dist_cf.paste(im1_half.pil, dests[1-kwargs['topis1']])\n    dist_cf.paste(im2_half.pil, dests[kwargs['topis1']])\n\n    if kwargs['showcue']:\n        if kwargs['cuedist'] is None:\n            kwargs['cuedist']= kwargs['cueh']*2\n        # cues\n        cue1 = Image.new(im1.pil.mode, (w_cf, kwargs['cuedist']))\n        cue2 = cue1.copy()\n        drawc = ImageDraw.Draw(cue1)\n        drawc.rectangle(((w_cf-kwargs['cuew'])//2,0,(w_cf+kwargs['cuew'])//2-1,kwargs['cuethick']-1),fill=kwargs['cueclr'])\n        drawc.rectangle(((w_cf-kwargs['cuew'])//2,kwargs['cuethick'],\n                        (w_cf-kwargs['cuew'])//2+kwargs['cuethick']-1,kwargs['cueh']+kwargs['cuethick']-1),\n                        fill=kwargs['cueclr'])\n        drawc.rectangle(((w_cf+kwargs['cuew'])//2-kwargs['cuethick'],kwargs['cuethick'],\n                        (w_cf+kwargs['cuew'])//2-1,kwargs['cueh']+kwargs['cuethick']-1),\n                        fill=kwargs['cueclr'])\n        cues = [cue1, cue2]\n\n        # concatenate CF and cues\n        dist = Image.new(im1.pil.mode, (w_cf, cue1.size[1]*2+dist_cf.size[1]))\n        dist.paste(cues[1-kwargs['cueistop']], (0, 0))\n        dist.paste(dist_cf, (0, cue1.size[1]))\n        dist.paste(ImageOps.flip(cues[kwargs['cueistop']]), (0, cue1.size[1]+dist_cf.size[1]))\n\n        # add the cue str to filename\n        fn_cf = fn_cf+'_'+['top', 'bot'][1-kwargs['cueistop']]\n\n    else:\n        dist = dist_cf\n\n    # update/save the cf image information\n    im_cf = im1.deepcopy()\n    im_cf._repil(dist)\n    im_cf._newfilename(newfname=fn_cf, addfn=False)\n\n    return im_cf, fn_cf\n</code></pre>"}]}