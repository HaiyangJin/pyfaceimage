{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pyfaceimage","text":"<p>Pyfaceimage is a Python package that processes (face) images.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Feature 1</li> <li>Feature 2</li> <li>Feature 3</li> </ul> <p>Get started by reading the installation guide!</p>"},{"location":"installation/","title":"Installation","text":"<p>You can install <code>Pyfaceimage</code> using pip:</p> <pre><code>pip install git+https://github.com/HaiyangJin/pyfaceimage\n</code></pre>"},{"location":"readim/","title":"Read images","text":"<pre><code>import pyfaceimage as fim\nimport os\n</code></pre> <pre><code># Your custom path to images\nPATH_to_image = os.path.join(\"..\", \"..\", \"test\")\n</code></pre> <p><code>fim.image()</code> can read one image and load the relevant information.</p> <pre><code>im = fim.image(os.path.join(PATH_to_image, \"im\", \"color.png\"),\n               read = True)\n</code></pre> <p>To check the image, you may use the following code:</p> <pre><code>im.pil\n\n# or\n# im.show()\n</code></pre> <p></p> <p>In most cases, we probably would like to load more images at a time:</p> <pre><code>im_dict = fim.dir(os.path.join(PATH_to_image, \"multi\"))\n</code></pre> <pre>\n<code>Found 4 files in ../../test/multi...\n</code>\n</pre> <p>The code above read all images in the folder at once and creates a dictionary of <code>im.image()</code> instances. Keys are the image names and values are the <code>im.image()</code> instances.</p> <pre><code>im_dict\n</code></pre> <pre>\n<code>{'L4': &lt;pyfaceimage.im.image at 0x12848f6e0&gt;,\n 'L1': &lt;pyfaceimage.im.image at 0x12f645a90&gt;,\n 'L2': &lt;pyfaceimage.im.image at 0x128b0b590&gt;,\n 'L3': &lt;pyfaceimage.im.image at 0x12f6c1520&gt;}</code>\n</pre> <p>You may extract the value and check the image content:</p> <pre><code>im_dict['L1'].pil\n</code></pre> <p>Alternatively, you may randomly sample one image and check its content:</p> <pre><code># random sample\nfim.sample(im_dict).pil\n</code></pre>"},{"location":"readim/#read-one-image","title":"Read one image","text":""},{"location":"readim/#read-multiple-images","title":"Read multiple images","text":""},{"location":"api/api/","title":"all","text":"<p>Auto-generate API documentation using <code>mkdocstrings</code>. Add the following content:</p>"},{"location":"api/api/#api-reference","title":"API Reference","text":"<p>Tools for dealing with images in dictionary.</p>"},{"location":"api/api/#pyfaceimage.image","title":"<code>image</code>","text":"<p>A class to process a single image.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>path and image filename.</p> required <code>read</code> <code>bool</code> <p>Whether to read the image via PIL, by default False.</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>filename</code> <code>str</code> <p>path and image filename.</p> <code>fname</code> <code>str</code> <p>the image filename.</p> <code>fnonly</code> <code>str</code> <p>the image filename without extension.</p> <code>ext</code> <code>str</code> <p>the image extension.</p> <code>dirname</code> <code>str</code> <p>the image directory.</p> <code>isfile</code> <code>bool</code> <p>whether the image file exists.</p> <code>group</code> <code>str</code> <p>the group name of the image.</p> <code>gpath</code> <code>str</code> <p>the global path of the image.</p> <code>pil</code> <code>Image</code> <p>the PIL image.</p> <code>mat</code> <code>array</code> <p>the image matrix.</p> <code>dims</code> <code>tuple</code> <p>the image dimensions.</p> <code>ndim</code> <code>int</code> <p>the number of dimensions.</p> <code>h</code> <code>int</code> <p>the height of the image.</p> <code>w</code> <code>int</code> <p>the width of the image.</p> <code>nchan</code> <code>int</code> <p>the number of channels.</p> <code>rgbmat</code> <code>array</code> <p>the RGB matrix.</p> <code>amat</code> <code>array</code> <p>the alpha matrix.</p> <p>Methods:</p> Name Description <code>updateext</code> <p>Update the filename information.</p> <code>read</code> <p>Read the image via PIL.</p> <code>imshow</code> <p>Show the image matrix.</p> <code>show</code> <p>Show the image PIL.</p> <code>imsave</code> <p>Save the image mat.</p> <code>save</code> <p>Save the image PIL.</p> <code>deepcopy</code> <p>Make a deep copy of the instance.</p> <code>remat</code> <p>Re-assign value to .mat and update related information.</p> <code>torgba</code> <p>Convert the image to RGBA.</p> <code>grayscale</code> <p>Convert the image to gray-scale.</p> <code>rotate</code> <p>Rotate the image unclockwise.</p> <code>adjust</code> <p>Adjust the luminance and contrast of the image.</p> <code>cropoval</code> <p>Crop the image with an oval shape.</p> <code>croprect</code> <p>Crop the image with a rectangle box.</p> <code>resize</code> <p>Resize the image.</p> <code>pad</code> <p>Add padding to the image/stimuli.</p> <code>mkboxscr</code> <p>Make box scrambled stimuli.</p> <code>mkphasescr</code> <p>Make phase scrambled stimuli.</p> <code>sffilter</code> <p>Apply spatial frequency filter to the image.</p> <code>_logit</code> <p>Convert the ratio to log odds.</p> <code>_sigmoid</code> <p>Convert the log odds to the ratio.</p> <code>_repil</code> <p>Update the image PIL.</p> <code>_updatefrommat</code> <p>Update information from the image matrix.</p> <code>_newfilename</code> <p>Update the filename with newfname and newfolder.</p> <code>_updatefromfilename</code> <p>Update information from the filename.</p> <code>_setgroup</code> <p>Set the group name of the image.</p> <code>_setgpath</code> <p>Set the global path of the image.</p> <code>_stdim</code> <p>Standardize the image.</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>class image:\n    \"\"\"A class to process a single image.\n\n    Parameters\n    ----------\n    filename : str\n        path and image filename.  \n    read : bool, optional\n        Whether to read the image via PIL, by default False.\n\n    Attributes\n    ----------\n    filename : str\n        path and image filename.\n    fname : str\n        the image filename.\n    fnonly : str\n        the image filename without extension.\n    ext : str\n        the image extension.\n    dirname : str\n        the image directory.\n    isfile : bool\n        whether the image file exists.\n    group : str\n        the group name of the image.\n    gpath : str\n        the global path of the image.\n    pil : PIL.Image\n        the PIL image.\n    mat : np.array\n        the image matrix.\n    dims : tuple\n        the image dimensions.\n    ndim : int\n        the number of dimensions.\n    h : int\n        the height of the image.\n    w : int\n        the width of the image.\n    nchan : int\n        the number of channels.\n    rgbmat : np.array\n        the RGB matrix.\n    amat : np.array\n        the alpha matrix.\n\n    Methods\n    -------\n    updateext(ext)\n        Update the filename information.\n    read()\n        Read the image via PIL.\n    imshow()\n        Show the image matrix.\n    show()\n        Show the image PIL.\n    imsave(newfname='', newfolder='', addfn=True, **kwargs)\n        Save the image mat.\n    save(newfname='', newfolder='', addfn=True, **kwargs)\n        Save the image PIL.\n    deepcopy()\n        Make a deep copy of the instance.\n    remat(mat)\n        Re-assign value to .mat and update related information.\n    torgba()\n        Convert the image to RGBA.\n    grayscale()\n        Convert the image to gray-scale.\n    rotate(angle=180)\n        Rotate the image unclockwise.\n    adjust(lum=None, rms=None, mask=None)\n        Adjust the luminance and contrast of the image.\n    cropoval(radius=(100,128), bgcolor=None)\n        Crop the image with an oval shape.\n    croprect(box=None)\n        Crop the image with a rectangle box.\n    resize(**kwargs)\n        Resize the image.\n    pad(**kwargs)\n        Add padding to the image/stimuli.\n    mkboxscr(**kwargs)\n        Make box scrambled stimuli.\n    mkphasescr(**kwargs)\n        Make phase scrambled stimuli.\n    sffilter(**kwargs)\n        Apply spatial frequency filter to the image.\n    _logit(ratio=None, correction=0.00001)\n        Convert the ratio to log odds.\n    _sigmoid(logodds, correction=0.00001)\n        Convert the log odds to the ratio.\n    _repil(pil)\n        Update the image PIL.\n    _updatefrommat()\n        Update information from the image matrix.\n    _newfilename(newfname='', newfolder='', addfn=True)\n        Update the filename with newfname and newfolder.\n    _updatefromfilename()\n        Update information from the filename.\n    _setgroup(gname='')\n        Set the group name of the image.\n    _setgpath(gpath='')\n        Set the global path of the image.\n    _stdim(mat, rms=0.3)\n        Standardize the image.\n    \"\"\"\n    def __init__(self, filename, read=False):\n        \"\"\"Create an image instance.\n\n        Parameters\n        ----------\n        filename : str\n            path and image filename.  \n        read : bool, optional\n            Whether to read the image via PIL, by default False.\n\n        Raises\n        ------\n        AssertionError\n            If the file does not exist.\n        \"\"\"\n        # make sure the file exists \n        assert os.path.isfile(filename) | (not bool(filename)), f'Cannot find {filename}...'\n        self.filename = filename\n        self._updatefromfilename() # update filename information\n        self._setgroup() \n        self._setgpath()\n        if read: self.read()\n\n    def _updatefromfilename(self):\n        \"\"\"Update information from the filename.\n        \"\"\"\n        self.fname = os.path.basename(self.filename)\n        self.fnonly = \".\".join(os.path.splitext(self.fname)[0:-1])\n        self.ext = os.path.splitext(self.fname)[-1]\n        self.dirname = os.path.dirname(self.filename)\n        self.isfile = os.path.isfile(self.filename)\n\n    def updateext(self, ext):\n        \"\"\"Update the filename information.\n\n        Parameters\n        ----------\n        ext : str\n            the new extension.\n        \"\"\"\n        if ext[0] != '.':\n            ext = '.'+ext\n        self.filename = self.dirname + os.sep + self.fnonly + ext\n        self._updatefromfilename()\n\n    def read(self):\n        \"\"\"Read the image via PIL.\n        \"\"\"\n        self._repil(Image.open(self.filename)) # PIL.Image.open() \n        # potential useful functions\n        # .filename .format, .mode, .split()\n\n    def _setgroup(self, gname=''):\n        \"\"\"Set the group name of the image.\n\n        Parameters\n        ----------\n        gname : str, optional\n            the group name, by default the upper directory name of the image.\n        \"\"\"\n        # update group information\n        if not bool(gname):\n            gname = os.path.split(os.path.dirname(self.filename))[1]\n        self.group = gname\n\n    def _setgpath(self, gpath=''):\n        \"\"\"Set the global path of the image (among other images). [This atribute matters only when mutiltple images are processed together. more see dir().]\n\n        Parameters\n        ----------\n        gpath : str, optional\n            global path, i.e. path in dir(), by default ''\n        \"\"\"\n        self.gpath = gpath\n\n    def imshow(self):\n        \"\"\"Show the image matrix.\n        \"\"\"\n        # for debugging purpose (check the mat)\n        # it seems that .show() is more useful\n        Image.fromarray(self.mat).show()\n\n    def show(self):\n        \"\"\"Show the image PIL.\n        \"\"\"\n        # for debugging purpose (check the PIL)\n        self.pil.show()\n\n    def imsave(self, newfname='', newfolder='', addfn=True, **kwargs):\n        \"\"\"Save the image mat.\n\n        Parameters\n        ----------\n        newfname : str, optional\n            strings to be added before the extension, by default ''\n        newfolder : str, optional\n            folder name to replace the global directory or the last directory level, by default ''\n        addfn : bool, optional\n            whether to add the newfname to the the original fname (instead of replacing it), by default True\n        kwargs : dict, optional\n            keyword arguments for matplotlib.pyplot.imsave(), by default {}\n        \"\"\"\n        # update the filename\n        self._newfilename(newfname, newfolder, addfn=addfn)\n\n        # make dir(s)\n        if not os.path.isdir(os.path.dirname(self.filename)):\n            os.makedirs(os.path.dirname(self.filename))\n        if self.nchan==1:\n            outmat = self.mat[:,:,0]\n        else:\n            outmat = self.mat\n\n        # use matplotlib.pyplot.imsave() to save .mat\n        mpimg.imsave(self.filename,outmat.copy(order='C'),**kwargs)\n        self.isfile = os.path.isfile(self.filename)\n\n\n    def save(self, newfname='', newfolder='', addfn=True, **kwargs):\n        \"\"\"Save the image PIL.\n\n        Parameters\n        ----------\n        newfname : str, optional\n            strings to be added before the extension, by default ''\n        newfolder : str, optional\n            folder name to replace the global directory or the last directory level, by default ''\n        addfn : bool, optional\n            whether to add the newfname to the the original fname (instead of replacing it), by default True\n        kwargs : dict, optional\n            keyword arguments for matplotlib.pyplot.imsave(), by default {}\n        \"\"\"\n        # update the filename\n        self._newfilename(newfname, newfolder, addfn=addfn)\n\n        # make dir(s)\n        if not os.path.isdir(os.path.dirname(self.filename)):\n            os.makedirs(os.path.dirname(self.filename))\n\n        # use PIL.Image.save() to save .pil    \n        self.pil.save(self.filename, format=None, **kwargs)\n        self.isfile = os.path.isfile(self.filename)\n\n\n    def touch(self, touchfolder=''):\n        \"\"\"Touch a new empty file.\n\n        Parameters\n        ----------\n        touchfolder : str, optional\n            folder name to replace the global directory or the last directory level, by default ''\n        \"\"\"\n        # update the directory\n        self._newfilename(newfolder=touchfolder)\n\n        if self.isfile:\n            # throw warnings if file exists\n            warnings.warn(\"The file named '%s' already exists...\" % self.filename)\n        else:\n            # make dir if needed\n            if not os.path.isdir(self.dirname):\n                os.makedirs(self.dirname)\n            # touch the file\n            Path(self.filename).touch()\n\n\n    def _newfilename(self, newfname='', newfolder='', addfn=True):\n        \"\"\"Update the filename with newfname and newfolder.\n\n        Parameters\n        ----------\n        newfname : str, optional\n            strings to be added before the extension, by default ''\n        newfolder : str, optional\n            folder name to replace the global directory or the last directory level, by default ''\n        addfn : bool, optional\n            whether to add the newfname to the the original fname (instead of replacing it), by default True\n        \"\"\"\n        # apply newfname to the old one\n        oldfname = os.path.splitext(self.fname)[0] if addfn else ''\n        fname = oldfname+newfname+os.path.splitext(self.fname)[1]\n\n        # replace the path folder with newfolder\n        if bool(self.gpath):\n            # rename the global path and filename\n            foldername = newfolder if bool(newfolder) else os.path.basename(self.gpath) # apply newfolder to the old one if needed\n            group = self.group if self.group != 'path' else ''\n            self.filename = os.path.join(os.path.dirname(self.gpath), foldername, group, fname)\n            self.gpath = os.path.join(os.path.dirname(self.gpath), foldername)\n        else:\n            foldername = newfolder if bool(newfolder) else os.path.basename(self.dirname) # apply newfolder to the old one if needed\n            self.filename = os.path.join(os.path.dirname(self.filename), foldername, fname)\n\n        self._updatefromfilename()\n        if self.isfile:\n            warnings.warn(\"The file named '%s' already exists...\" % {self.filename})\n\n    def deepcopy(self):\n        \"\"\"make a deep copy of the instance\n        \"\"\"\n        return copy.deepcopy(self)\n\n    def remat(self, mat):\n        # re-assign value to .mat and update related information\n        self.mat = mat\n        self.pil = Image.fromarray(mat)\n        self._updatefrommat()\n\n    def _repil(self, pil):\n        self.pil = pil\n        self.mat = np.asarray(self.pil)\n        self._updatefrommat()\n\n    def _updatefrommat(self):\n        self.dims = self.mat.shape\n        self.ndim = len(self.dims)\n        if self.ndim==2:\n            self.h, self.w = self.dims\n            self.nchan = 0\n        elif self.ndim==3:\n            self.h, self.w, self.nchan = self.dims\n\n    def torgba(self):\n        \"\"\"Convert the image to RGBA.\n        \"\"\"\n        # convert pil to RGBA and save in .mat\n        if len(self.mat.shape)==2: # Gray\n            self.mat = self.mat[..., np.newaxis]\n        assert len(self.mat.shape)==3\n\n        nchan = self.mat.shape[2]\n        if nchan==1: # Gray 'L'\n            rgbmat = np.repeat(self.mat, 3, axis=2) # RGB\n            amat = np.ones_like(rgbmat[:,:,0],dtype=np.uint8)*rgbmat.max() # alpha\n        elif nchan==2: # Gray 'LA'\n            rgbmat = np.repeat(self.mat[:,:,0:1], 3, axis=2) # RGB\n            amat = self.mat[:,:,-1] # alpha\n        elif nchan==3: # RGB\n            rgbmat = self.mat # RGB\n            amat = np.ones_like(rgbmat[:,:,0],dtype=np.uint8)*rgbmat.max() # alpha\n        elif nchan==4: # RGBA\n            rgbmat = self.mat[:,:,0:3]\n            amat = self.mat[:,:,-1]\n\n        self.rgbmat = rgbmat\n        self.amat = amat\n        self.mat = np.concatenate((rgbmat, amat[..., np.newaxis]), axis=2) # RGBA\n        self.remat(self.mat)\n\n    def grayscale(self):\n        \"\"\"Convert the image to gray-scale.\n        \"\"\"\n        # convert image to gray-scale\n        self._repil(ImageOps.grayscale(self.pil))\n\n    def _logit(self, ratio=None, correction=0.00001):\n        \"\"\"Convert the ratio to log odds.\n\n        Parameters\n        ----------\n        ratio : np.array, optional\n            the ratio of the image. Defaults to None.\n        correction : float, optional\n            the correction value. Defaults to 0.00001.\n\n        Returns\n        -------\n        np.array\n            the log odds of the image.\n        \"\"\"\n\n        if ratio is None:\n            self.grayscale()\n            ratio = self.mat/255\n        elif type(ratio) is not np.ndarray:\n            ratio = np.array(ratio)\n\n        ratio[ratio==1] = (255-correction)/255\n        ratio[ratio==0] = correction/255\n\n        return np.log(ratio/(1-ratio))\n\n    def _sigmoid(self, logodds, correction=0.00001):\n\n        ratio = np.exp(logodds)/(np.exp(logodds)+1)\n        ratio[ratio&gt;=(1-correction)] = 1\n        ratio[ratio&lt;=(correction)] = 0\n\n        gray = ratio * 255\n\n        return gray.astype(dtype=np.uint8)\n\n    def rotate(self, angle=180):\n        \"\"\"Rotate the image unclockwise.\n\n        Parameters\n        ----------\n        angle : float\n            the angle to rotate the image. Defaults to 180.\n        \"\"\"\n        # rotate the image\n        self._repil(self.pil.rotate(angle))\n\n    def adjust(self, lum=None, rms=None, mask=None):\n        \"\"\"Adjust the luminance and contrast of the image.\n\n        Parameters\n        ----------\n        lum : float, optional\n            the desired mean of the image. Defaults to None.\n        rms : float, optional\n            the desired standard deviation of the image. Defaults to None.\n        mask : np.array, optional\n            the mask for the image. Defaults to None.\n        \"\"\"\n        # adjust the luminance (mean) or/and contrast (standard deviations) of the gray-scaled image. Default is do nothing.\n\n        # default for mask\n        if self.nchan in (2,4):\n            alpha = self.mat[...,-1]\n            isalpha = True\n        else:\n            alpha = np.ones((self.h, self.w))*255\n            isalpha = False\n        if mask is None:\n            mask = (alpha/255).astype(dtype=bool)\n\n        # force the image to be gray-scaled\n        self.grayscale()\n        ratio = self.mat/255\n        logodds = self._logit(ratio)\n\n        # in ratio\n        rmsratio = np.std(ratio[mask]-np.mean(ratio[mask]))\n\n        # in log odds\n        meanlo = np.mean(logodds[mask])\n        stdlo = np.std(logodds[mask]-meanlo)\n\n        if lum is not None:\n            lumlo = self._logit(lum)\n        else:\n            lumlo = meanlo\n\n        if rms is not None:\n            rmslo = rms * stdlo / rmsratio\n        else:\n            rmslo = stdlo\n\n        newlo = logodds\n        # apply the new luminance (in logodds)\n        newlo[mask] = (logodds[mask] - meanlo)/stdlo * rmslo + lumlo\n        newmat = self._sigmoid(newlo)\n\n        if isalpha:\n            newmat = np.concatenate((newmat[...,np.newaxis], alpha[...,np.newaxis]), axis=2)\n\n        self.remat(newmat.astype(dtype=np.uint8))\n\n\n    def cropoval(self, radius=(100,128), bgcolor=None):\n        \"\"\"Crop the image with an oval shape.\n\n        Parameters\n        ----------\n        radius : tuple, optional\n            the radius of the oval. Defaults to (100,128).\n        bgcolor : tuple, optional\n            the background color. Defaults to None.\n        \"\"\"\n\n        # for instance, if bgcolor is (255, 255, 255, 255), the output image is not transparent; if bgcolor is (255, 255, 255, 0), the output image is transparent\n\n        # to make circle\n        if type(radius) is not tuple:\n            radius = (radius, radius) # a and b in ellipse formula\n        bbox = (self.w/2-radius[0], self.h/2-radius[1], self.w/2+radius[0], self.h/2+radius[1])\n\n        # make a ellipse/oval mask\n        pil_a = Image.new(\"L\", self.pil.size, 0)\n        draw = ImageDraw.Draw(pil_a)\n        draw.ellipse(bbox, fill=255)\n\n        if bgcolor is not None:\n            if type(bgcolor) is not tuple:\n                bgcolor = ((bgcolor),)*len(self.pil.mode)\n            pil_2 = Image.new(self.pil.mode, self.pil.size, bgcolor)\n            draw = ImageDraw.Draw(pil_2)\n            draw.ellipse(bbox, fill=255)\n            self.pil = Image.composite(self.pil, pil_2, pil_a)\n        else:\n            # only apply cropping to the alpha channel\n            self.pil.putalpha(pil_a)\n        # update to pil        \n        self._repil(self.pil)\n        # crop the rectangle\n        self.croprect(bbox)\n\n    def croprect(self, box=None):\n        \"\"\"Crop the image with a rectangle box.\n\n        Parameters\n        ----------\n        box : tuple, optional\n            the box to crop the image. Defaults to None.\n        \"\"\"\n        # crop the image with a rectangle box\n        self._repil(self.pil.crop(box))\n\n    def resize(self, **kwargs):\n        \"\"\"Resize the image.\n\n        Other Parameters\n        ----------------\n        trgw : int\n            the width of the target/desired stimuli.\n        trgh : int\n            the height of the target/desired stimuli.\n        ratio : float\n            the ratio to resize the image. Defaults to 0.\n        newfolder : str\n            the folder to save the resized image. Defaults to None.\n        \"\"\"\n        # resize the image\n        defaultKwargs = {'trgw': None, 'trgh': None, 'ratio':0, 'newfolder':None}\n        kwargs = {**defaultKwargs, **kwargs}\n\n        if (kwargs['trgw'] is not None) &amp; (kwargs['trgh'] is not None):\n            (w, h) = (kwargs['trgw'], kwargs['trgh'])\n        elif (kwargs['trgw'] is not None) &amp; (kwargs['trgh'] is None):\n            w = kwargs['trgw']\n            h = int(w*self.h/self.w)\n        elif (kwargs['trgw'] is None) &amp; (kwargs['trgh'] is not None): \n            h = kwargs['trgh']\n            w = int(h*self.w/self.h)\n        elif kwargs['ratio']&gt;0:\n            w = int(self.w*kwargs['ratio'])\n            h = int(self.h*kwargs['ratio'])\n        else:\n            raise 'Cannot determine the desired dimentions...'\n\n        kwargs['size'] = (w,h)\n        if (kwargs['newfolder'] is None):\n            newfolder = str(w)+'_'+str(h)\n        else:\n            newfolder = kwargs['newfolder']\n\n        [kwargs.pop(k) for k in defaultKwargs.keys()] # remove unused keys\n\n        # save re-sized images (information)\n        self._repil(self.pil.resize(**kwargs))\n        self._newfilename(newfolder=newfolder)\n\n    def pad(self, **kwargs):  \n        \"\"\"\n        Add padding to the image/stimuli.\n\n        Other Parameters\n        ----------------\n        trgw : int\n            the width of the target/desired stimuli. \n        trgh : int\n            the height of the target/desired stimuli.\n        padvalue : int\n            padding value. Defaults to 0 (show as transparent if alpha channel exists).\n        top : bool\n            padding more to top if needed. Defaults to True.\n        left : bool \n            padding more to left if needed. Defaults to True.\n        padalpha : int\n            the transparent color. Defaults to -1, i.e., not to force it to transparent.\n        extrafn : str\n            the string to be added to the filename. Defaults to '_pad'.\n        \"\"\"\n\n        defaultKwargs = {'trgw':self.w, 'trgh':self.h, 'padvalue': 0, 'top': True, 'left':True, 'padalpha':-1, 'extrafn':'_pad'}\n        kwargs = {**defaultKwargs, **kwargs}\n\n        trgw,trgh = kwargs['trgw'], kwargs['trgh']\n\n        assert(trgw&gt;=self.w)\n        assert(trgh&gt;=self.h)\n\n        x1 = int(np.ceil(trgw-self.w)/2)\n        x2 = trgw-self.w-x1\n        y1 = int(np.ceil(trgh-self.h)/2)\n        y2 = trgh-self.h-y1\n\n        if kwargs['top']:\n            htop, hbot = y1,y2\n        else:\n            htop, hbot = y2,y1\n        if kwargs['left']:\n            wleft, wright = x1,x2\n        else:\n            wleft, wright = x2,x1\n\n        if self.nchan==0:\n            nchan = 1\n            mat = self.mat[..., np.newaxis] # add one more axis\n        else:\n            nchan = self.nchan\n            mat = self.mat\n\n        if (kwargs['padalpha']&gt;=0) &amp; (nchan==1 | nchan==3):\n            mat = np.concatenate((mat, np.ones((self.h, self.w, 1), dtype=np.uint8)*kwargs['padalpha']),axis=2)\n            nchan = nchan + 1\n\n        padmat = np.hstack((\n            np.ones((trgh,wleft,nchan),dtype=np.uint8)*kwargs['padvalue'], \n            np.vstack((\n                np.ones((htop,self.w,nchan),dtype=np.uint8)*kwargs['padvalue'], \n                mat,\n                np.ones((hbot,self.w,nchan),dtype=np.uint8)*kwargs['padvalue']\n            )),\n            np.ones((trgh,wright,nchan),dtype=np.uint8)*kwargs['padvalue'], \n        ))\n\n        if (self.nchan==0) &amp; (kwargs['padalpha']&lt;0):\n            padmat = padmat[:,:,0]\n\n        self.remat(padmat)\n        if kwargs['extrafn']!='':\n            self._newfilename(newfname=kwargs['extrafn'])\n\n    def mkboxscr(self, **kwargs):\n        \"\"\"Make box scrambled stimuli.\n\n        Other Parameters\n        ----------------\n        nBoxW : int\n            the number of boxes in width. Defaults to 10.\n        nBoxH : int\n            the number of boxes in height. Defaults to 16.\n        pBoxW : int\n            the width of a box. Defaults to 0.\n        pBoxH : int\n            the height of a box. Defaults to 0.\n        pad : bool\n            whether to add padding to the image. Defaults to False.\n        padcolor : int\n            the padding color. Defaults to 0.\n        padalpha : int\n            the padding alpha. Defaults to -1.\n        \"\"\"\n        defaultKwargs = {'nBoxW':10, 'nBoxH':16, \n                     'pBoxW':0, 'pBoxH':0, \n                     'pad': False, 'padcolor':0, 'padalpha': -1}\n        kwargs = {**defaultKwargs, **kwargs}\n\n        if (kwargs['pBoxW']!=0) &amp; (kwargs['pBoxH']!=0):\n\n            _nBoxW = self.w/kwargs['pBoxW']\n            _nBoxH = self.h/kwargs['pBoxH']\n\n            if not ((_nBoxW.is_integer()) &amp; (_nBoxH.is_integer())):\n                assert kwargs['pad'], 'Please input valid pBoxW and pBoxH. Or set \"pad\" to True.'\n\n                # add complementary parts to top and right\n                xnew = int(np.ceil(_nBoxW) * kwargs['pBoxW'])\n                ynew = int(np.ceil(_nBoxH) * kwargs['pBoxH'])\n\n                self.pad(trgw=xnew, trgh=ynew, padvalue=kwargs['padcolor'], padalpha=kwargs['padalpha'])\n\n            kwargs['nBoxW'] = int(self.w/kwargs['pBoxW'])\n            kwargs['nBoxH'] = int(self.h/kwargs['pBoxH'])\n\n        elif (kwargs['nBoxW']!=0) &amp; (kwargs['nBoxH']!=0):\n\n            # x and y pixels for each box\n            _pBoxW = self.w/kwargs['nBoxW']\n            _pBoxH = self.h/kwargs['nBoxH']\n\n            if not ((_pBoxW.is_integer()) &amp; (_pBoxH.is_integer())):\n                assert kwargs['pad'], 'Please input valid nBoxW and nBoxH. Or set \"pad\" to True.'\n\n                # add padding (top, right, bottom, left)\n                newW = int(np.ceil(_pBoxW) * kwargs['nBoxW'])\n                newY = int(np.ceil(_pBoxH) * kwargs['nBoxH'])\n                self.pad(trgw=newW, trgh=newY, padvalue=kwargs['padcolor'], padalpha=kwargs['padalpha'])\n\n            kwargs['pBoxW'] = int(self.w/kwargs['nBoxW'])\n            kwargs['pBoxH'] = int(self.h/kwargs['nBoxH'])\n        else:\n            raise 'Please set valid nBoxW and nBoxH (or pBoxW and pBoxH).'\n\n        assert kwargs['nBoxW']*kwargs['pBoxW']==self.w, f\"'nBoxW': {kwargs['nBoxW']}   'pBoxW': {kwargs['pBoxW']}    'self.w': {self.w}\"\n        assert kwargs['nBoxH']*kwargs['pBoxH']==self.h, f\"'nBoxH': {kwargs['nBoxH']}   'pBoxH': {kwargs['pBoxH']}    'self.h': {self.h}\"\n\n        # x and y for all boxes\n        xys = list(product(range(0,self.w,kwargs['pBoxW']), range(0,self.h,kwargs['pBoxH'])))\n        boxes = [self.mat[i[1]:(i[1]+kwargs['pBoxH']), i[0]:(i[0]+kwargs['pBoxW'])] for i in xys]\n        # randomize the boxes\n        bsboxes = np.random.permutation(boxes)\n        # save as np.array\n        bslist = [bsboxes[i:i+kwargs['nBoxW']] for i in range(0,len(bsboxes),kwargs['nBoxW'])]\n        # bsmat = np.moveaxis(np.asarray(bslist), [-1, 1], [0, -2]).reshape(-1, y, x)\n        bsmatm = np.asarray(bslist)\n        if len(bsmatm.shape)==4:\n            bsmatm = bsmatm[..., np.newaxis]\n        bsmat = np.moveaxis(bsmatm, [-1, 1], [0, -2]).reshape(-1, self.h, self.w)\n\n        # save box-scrambled images (and information)\n        self.remat(np.squeeze(np.moveaxis(bsmat,0,2)))\n        self._newfilename(newfname='_bscr')\n\n    def mkphasescr(self, **kwargs):\n        \"\"\"Make phase scrambled stimuli.\n\n        Other Parameters\n        ----------------\n        rms : float\n            the desired RMS of the image. Defaults to 0.3.\n        \"\"\"\n        defaultKwargs = {'rms':0.3}\n        kwargs = {**defaultKwargs, **kwargs}\n\n        # make a random phase\n        randphase = np.angle(np.fft.fft2(np.random.rand(self.h, self.w)))\n\n        if self.nchan==0:\n            nchan = 1\n            mat = self.mat[..., np.newaxis] # add one more axis\n        else:\n            nchan = self.nchan\n            mat = self.mat\n\n        outmat = np.empty(mat.shape)\n        outmat[:] = np.NaN\n\n        for i in range(nchan):\n            img_freq = np.fft.fft2(self._stdim(mat[:,:,i], kwargs['rms']))\n            amp = np.abs(img_freq)\n            phase = np.angle(img_freq) + randphase\n            outimg = np.real(np.fft.ifft2(amp * np.exp(np.sqrt(-1+0j)*phase)))\n            stdimg1= self._stdim(outimg, kwargs['rms'])\n            outmat[:,:,i] = (stdimg1+1)/2*255\n\n        if self.nchan==0:\n            outmat = outmat[:,:,0]\n\n        self.remat(np.uint8(outmat))\n        self._newfilename(newfname='_pscr')\n\n    def sffilter(self, **kwargs):\n        \"\"\"Apply spatial frequency filter to the image.\n\n        Other Parameters\n        ----------------\n        rms : float\n            the desired RMS of the image. Defaults to 0.3.\n        maxvalue : int\n            the maximum value of the image. Defaults to 255.\n        sffilter : str\n            the spatial frequency filter. Defaults to 'low'.\n        cutoff : float\n            the cutoff frequency. Defaults to 0.05.\n        n : int\n            the order of the filter. Defaults to 10.\n        \"\"\"\n        # https://www.djmannion.net/psych_programming/vision/sf_filt/sf_filt.html\n        import psychopy.filters\n\n        defaultKwargs = {'rms':0.3, 'maxvalue':255, 'sffilter':'low',\n                         'cutoff': 0.05, 'n': 10}\n        kwargs = {**defaultKwargs, **kwargs}\n\n        self.grayscale()\n        stdmat = self._stdim(self.mat, kwargs['rms'])\n        img_freq = np.fft.fft2(stdmat)\n\n        # calculate amplitude spectrum\n        # img_amp = np.fft.fftshift(np.abs(img_freq))\n\n        # # for display, take the logarithm\n        # img_amp_disp = np.log(img_amp + 0.0001)\n\n        # # rescale to -1:+1 for display\n        # img_amp_disp = (\n        #     ((img_amp_disp - np.min(img_amp_disp)) * 2) / \n        #     np.ptp(img_amp_disp)  # 'ptp' = range\n        # ) - 1\n\n        if kwargs['sffilter']=='low':\n            # for generating blury images\n            fsfilt = psychopy.filters.butter2d_lp(\n                size=(self.w, self.h),\n                cutoff=kwargs['cutoff'],\n                n=kwargs['n']\n            )\n        elif kwargs['sffilter']=='high':      \n             # for gernerating sharp images\n            fsfilt = psychopy.filters.butter2d_hp(\n                size=(self.w, self.h),\n                cutoff=kwargs['cutoff'],\n                n=kwargs['n']\n            )\n        else:\n            raise 'Cannot identify the \"sffilter\" value...'\n\n        img_filt = np.fft.fftshift(img_freq) * fsfilt.transpose()\n        # convert back to an image\n        img_new = np.real(np.fft.ifft2(np.fft.ifftshift(img_filt)))\n        # standardize the image to [-1, 1]\n        img_new = self._stdim(img_new, kwargs['rms'])\n        # convert the range to [0, 255]\n        img_new = (img_new+1)/2*kwargs['maxvalue']\n        self.remat(img_new)\n        self._newfilename(newfname='_'+kwargs['sffilter']+'_filtered')\n\n    def _stdim(self, mat, rms=0.3):\n        \"\"\"Standardize the image.\n\n        Parameters\n        ----------\n        mat : np.array\n            the image matrix.\n        rms : float, optional\n            the desired RMS of the image. Defaults to 0.3.\n\n        Returns\n        -------\n        np.array\n            the standardized image matrix.\n        \"\"\"\n        # standardize the image (the range of output should be -1,1)\n        # make the standard deviation to be the desired RMS\n        mat = (mat - np.mean(mat))/np.std(mat) * rms\n\n        # there may be some stray values outside of the presentable range; convert &lt; -1\n        # to -1 and &gt; 1 to 1\n        mat = np.clip(mat, a_min=-1.0, a_max=1.0)\n        return mat\n</code></pre>"},{"location":"api/api/#pyfaceimage.image.__init__","title":"<code>__init__(filename, read=False)</code>","text":"<p>Create an image instance.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>path and image filename.</p> required <code>read</code> <code>bool</code> <p>Whether to read the image via PIL, by default False.</p> <code>False</code> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the file does not exist.</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>def __init__(self, filename, read=False):\n    \"\"\"Create an image instance.\n\n    Parameters\n    ----------\n    filename : str\n        path and image filename.  \n    read : bool, optional\n        Whether to read the image via PIL, by default False.\n\n    Raises\n    ------\n    AssertionError\n        If the file does not exist.\n    \"\"\"\n    # make sure the file exists \n    assert os.path.isfile(filename) | (not bool(filename)), f'Cannot find {filename}...'\n    self.filename = filename\n    self._updatefromfilename() # update filename information\n    self._setgroup() \n    self._setgpath()\n    if read: self.read()\n</code></pre>"},{"location":"api/api/#pyfaceimage.image.adjust","title":"<code>adjust(lum=None, rms=None, mask=None)</code>","text":"<p>Adjust the luminance and contrast of the image.</p> <p>Parameters:</p> Name Type Description Default <code>lum</code> <code>float</code> <p>the desired mean of the image. Defaults to None.</p> <code>None</code> <code>rms</code> <code>float</code> <p>the desired standard deviation of the image. Defaults to None.</p> <code>None</code> <code>mask</code> <code>array</code> <p>the mask for the image. Defaults to None.</p> <code>None</code> Source code in <code>pyfaceimage/im.py</code> <pre><code>def adjust(self, lum=None, rms=None, mask=None):\n    \"\"\"Adjust the luminance and contrast of the image.\n\n    Parameters\n    ----------\n    lum : float, optional\n        the desired mean of the image. Defaults to None.\n    rms : float, optional\n        the desired standard deviation of the image. Defaults to None.\n    mask : np.array, optional\n        the mask for the image. Defaults to None.\n    \"\"\"\n    # adjust the luminance (mean) or/and contrast (standard deviations) of the gray-scaled image. Default is do nothing.\n\n    # default for mask\n    if self.nchan in (2,4):\n        alpha = self.mat[...,-1]\n        isalpha = True\n    else:\n        alpha = np.ones((self.h, self.w))*255\n        isalpha = False\n    if mask is None:\n        mask = (alpha/255).astype(dtype=bool)\n\n    # force the image to be gray-scaled\n    self.grayscale()\n    ratio = self.mat/255\n    logodds = self._logit(ratio)\n\n    # in ratio\n    rmsratio = np.std(ratio[mask]-np.mean(ratio[mask]))\n\n    # in log odds\n    meanlo = np.mean(logodds[mask])\n    stdlo = np.std(logodds[mask]-meanlo)\n\n    if lum is not None:\n        lumlo = self._logit(lum)\n    else:\n        lumlo = meanlo\n\n    if rms is not None:\n        rmslo = rms * stdlo / rmsratio\n    else:\n        rmslo = stdlo\n\n    newlo = logodds\n    # apply the new luminance (in logodds)\n    newlo[mask] = (logodds[mask] - meanlo)/stdlo * rmslo + lumlo\n    newmat = self._sigmoid(newlo)\n\n    if isalpha:\n        newmat = np.concatenate((newmat[...,np.newaxis], alpha[...,np.newaxis]), axis=2)\n\n    self.remat(newmat.astype(dtype=np.uint8))\n</code></pre>"},{"location":"api/api/#pyfaceimage.image.cropoval","title":"<code>cropoval(radius=(100, 128), bgcolor=None)</code>","text":"<p>Crop the image with an oval shape.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>tuple</code> <p>the radius of the oval. Defaults to (100,128).</p> <code>(100, 128)</code> <code>bgcolor</code> <code>tuple</code> <p>the background color. Defaults to None.</p> <code>None</code> Source code in <code>pyfaceimage/im.py</code> <pre><code>def cropoval(self, radius=(100,128), bgcolor=None):\n    \"\"\"Crop the image with an oval shape.\n\n    Parameters\n    ----------\n    radius : tuple, optional\n        the radius of the oval. Defaults to (100,128).\n    bgcolor : tuple, optional\n        the background color. Defaults to None.\n    \"\"\"\n\n    # for instance, if bgcolor is (255, 255, 255, 255), the output image is not transparent; if bgcolor is (255, 255, 255, 0), the output image is transparent\n\n    # to make circle\n    if type(radius) is not tuple:\n        radius = (radius, radius) # a and b in ellipse formula\n    bbox = (self.w/2-radius[0], self.h/2-radius[1], self.w/2+radius[0], self.h/2+radius[1])\n\n    # make a ellipse/oval mask\n    pil_a = Image.new(\"L\", self.pil.size, 0)\n    draw = ImageDraw.Draw(pil_a)\n    draw.ellipse(bbox, fill=255)\n\n    if bgcolor is not None:\n        if type(bgcolor) is not tuple:\n            bgcolor = ((bgcolor),)*len(self.pil.mode)\n        pil_2 = Image.new(self.pil.mode, self.pil.size, bgcolor)\n        draw = ImageDraw.Draw(pil_2)\n        draw.ellipse(bbox, fill=255)\n        self.pil = Image.composite(self.pil, pil_2, pil_a)\n    else:\n        # only apply cropping to the alpha channel\n        self.pil.putalpha(pil_a)\n    # update to pil        \n    self._repil(self.pil)\n    # crop the rectangle\n    self.croprect(bbox)\n</code></pre>"},{"location":"api/api/#pyfaceimage.image.croprect","title":"<code>croprect(box=None)</code>","text":"<p>Crop the image with a rectangle box.</p> <p>Parameters:</p> Name Type Description Default <code>box</code> <code>tuple</code> <p>the box to crop the image. Defaults to None.</p> <code>None</code> Source code in <code>pyfaceimage/im.py</code> <pre><code>def croprect(self, box=None):\n    \"\"\"Crop the image with a rectangle box.\n\n    Parameters\n    ----------\n    box : tuple, optional\n        the box to crop the image. Defaults to None.\n    \"\"\"\n    # crop the image with a rectangle box\n    self._repil(self.pil.crop(box))\n</code></pre>"},{"location":"api/api/#pyfaceimage.image.deepcopy","title":"<code>deepcopy()</code>","text":"<p>make a deep copy of the instance</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>def deepcopy(self):\n    \"\"\"make a deep copy of the instance\n    \"\"\"\n    return copy.deepcopy(self)\n</code></pre>"},{"location":"api/api/#pyfaceimage.image.grayscale","title":"<code>grayscale()</code>","text":"<p>Convert the image to gray-scale.</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>def grayscale(self):\n    \"\"\"Convert the image to gray-scale.\n    \"\"\"\n    # convert image to gray-scale\n    self._repil(ImageOps.grayscale(self.pil))\n</code></pre>"},{"location":"api/api/#pyfaceimage.image.imsave","title":"<code>imsave(newfname='', newfolder='', addfn=True, **kwargs)</code>","text":"<p>Save the image mat.</p> <p>Parameters:</p> Name Type Description Default <code>newfname</code> <code>str</code> <p>strings to be added before the extension, by default ''</p> <code>''</code> <code>newfolder</code> <code>str</code> <p>folder name to replace the global directory or the last directory level, by default ''</p> <code>''</code> <code>addfn</code> <code>bool</code> <p>whether to add the newfname to the the original fname (instead of replacing it), by default True</p> <code>True</code> <code>kwargs</code> <code>dict</code> <p>keyword arguments for matplotlib.pyplot.imsave(), by default {}</p> <code>{}</code> Source code in <code>pyfaceimage/im.py</code> <pre><code>def imsave(self, newfname='', newfolder='', addfn=True, **kwargs):\n    \"\"\"Save the image mat.\n\n    Parameters\n    ----------\n    newfname : str, optional\n        strings to be added before the extension, by default ''\n    newfolder : str, optional\n        folder name to replace the global directory or the last directory level, by default ''\n    addfn : bool, optional\n        whether to add the newfname to the the original fname (instead of replacing it), by default True\n    kwargs : dict, optional\n        keyword arguments for matplotlib.pyplot.imsave(), by default {}\n    \"\"\"\n    # update the filename\n    self._newfilename(newfname, newfolder, addfn=addfn)\n\n    # make dir(s)\n    if not os.path.isdir(os.path.dirname(self.filename)):\n        os.makedirs(os.path.dirname(self.filename))\n    if self.nchan==1:\n        outmat = self.mat[:,:,0]\n    else:\n        outmat = self.mat\n\n    # use matplotlib.pyplot.imsave() to save .mat\n    mpimg.imsave(self.filename,outmat.copy(order='C'),**kwargs)\n    self.isfile = os.path.isfile(self.filename)\n</code></pre>"},{"location":"api/api/#pyfaceimage.image.imshow","title":"<code>imshow()</code>","text":"<p>Show the image matrix.</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>def imshow(self):\n    \"\"\"Show the image matrix.\n    \"\"\"\n    # for debugging purpose (check the mat)\n    # it seems that .show() is more useful\n    Image.fromarray(self.mat).show()\n</code></pre>"},{"location":"api/api/#pyfaceimage.image.mkboxscr","title":"<code>mkboxscr(**kwargs)</code>","text":"<p>Make box scrambled stimuli.</p> <p>Other Parameters:</p> Name Type Description <code>nBoxW</code> <code>int</code> <p>the number of boxes in width. Defaults to 10.</p> <code>nBoxH</code> <code>int</code> <p>the number of boxes in height. Defaults to 16.</p> <code>pBoxW</code> <code>int</code> <p>the width of a box. Defaults to 0.</p> <code>pBoxH</code> <code>int</code> <p>the height of a box. Defaults to 0.</p> <code>pad</code> <code>bool</code> <p>whether to add padding to the image. Defaults to False.</p> <code>padcolor</code> <code>int</code> <p>the padding color. Defaults to 0.</p> <code>padalpha</code> <code>int</code> <p>the padding alpha. Defaults to -1.</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>def mkboxscr(self, **kwargs):\n    \"\"\"Make box scrambled stimuli.\n\n    Other Parameters\n    ----------------\n    nBoxW : int\n        the number of boxes in width. Defaults to 10.\n    nBoxH : int\n        the number of boxes in height. Defaults to 16.\n    pBoxW : int\n        the width of a box. Defaults to 0.\n    pBoxH : int\n        the height of a box. Defaults to 0.\n    pad : bool\n        whether to add padding to the image. Defaults to False.\n    padcolor : int\n        the padding color. Defaults to 0.\n    padalpha : int\n        the padding alpha. Defaults to -1.\n    \"\"\"\n    defaultKwargs = {'nBoxW':10, 'nBoxH':16, \n                 'pBoxW':0, 'pBoxH':0, \n                 'pad': False, 'padcolor':0, 'padalpha': -1}\n    kwargs = {**defaultKwargs, **kwargs}\n\n    if (kwargs['pBoxW']!=0) &amp; (kwargs['pBoxH']!=0):\n\n        _nBoxW = self.w/kwargs['pBoxW']\n        _nBoxH = self.h/kwargs['pBoxH']\n\n        if not ((_nBoxW.is_integer()) &amp; (_nBoxH.is_integer())):\n            assert kwargs['pad'], 'Please input valid pBoxW and pBoxH. Or set \"pad\" to True.'\n\n            # add complementary parts to top and right\n            xnew = int(np.ceil(_nBoxW) * kwargs['pBoxW'])\n            ynew = int(np.ceil(_nBoxH) * kwargs['pBoxH'])\n\n            self.pad(trgw=xnew, trgh=ynew, padvalue=kwargs['padcolor'], padalpha=kwargs['padalpha'])\n\n        kwargs['nBoxW'] = int(self.w/kwargs['pBoxW'])\n        kwargs['nBoxH'] = int(self.h/kwargs['pBoxH'])\n\n    elif (kwargs['nBoxW']!=0) &amp; (kwargs['nBoxH']!=0):\n\n        # x and y pixels for each box\n        _pBoxW = self.w/kwargs['nBoxW']\n        _pBoxH = self.h/kwargs['nBoxH']\n\n        if not ((_pBoxW.is_integer()) &amp; (_pBoxH.is_integer())):\n            assert kwargs['pad'], 'Please input valid nBoxW and nBoxH. Or set \"pad\" to True.'\n\n            # add padding (top, right, bottom, left)\n            newW = int(np.ceil(_pBoxW) * kwargs['nBoxW'])\n            newY = int(np.ceil(_pBoxH) * kwargs['nBoxH'])\n            self.pad(trgw=newW, trgh=newY, padvalue=kwargs['padcolor'], padalpha=kwargs['padalpha'])\n\n        kwargs['pBoxW'] = int(self.w/kwargs['nBoxW'])\n        kwargs['pBoxH'] = int(self.h/kwargs['nBoxH'])\n    else:\n        raise 'Please set valid nBoxW and nBoxH (or pBoxW and pBoxH).'\n\n    assert kwargs['nBoxW']*kwargs['pBoxW']==self.w, f\"'nBoxW': {kwargs['nBoxW']}   'pBoxW': {kwargs['pBoxW']}    'self.w': {self.w}\"\n    assert kwargs['nBoxH']*kwargs['pBoxH']==self.h, f\"'nBoxH': {kwargs['nBoxH']}   'pBoxH': {kwargs['pBoxH']}    'self.h': {self.h}\"\n\n    # x and y for all boxes\n    xys = list(product(range(0,self.w,kwargs['pBoxW']), range(0,self.h,kwargs['pBoxH'])))\n    boxes = [self.mat[i[1]:(i[1]+kwargs['pBoxH']), i[0]:(i[0]+kwargs['pBoxW'])] for i in xys]\n    # randomize the boxes\n    bsboxes = np.random.permutation(boxes)\n    # save as np.array\n    bslist = [bsboxes[i:i+kwargs['nBoxW']] for i in range(0,len(bsboxes),kwargs['nBoxW'])]\n    # bsmat = np.moveaxis(np.asarray(bslist), [-1, 1], [0, -2]).reshape(-1, y, x)\n    bsmatm = np.asarray(bslist)\n    if len(bsmatm.shape)==4:\n        bsmatm = bsmatm[..., np.newaxis]\n    bsmat = np.moveaxis(bsmatm, [-1, 1], [0, -2]).reshape(-1, self.h, self.w)\n\n    # save box-scrambled images (and information)\n    self.remat(np.squeeze(np.moveaxis(bsmat,0,2)))\n    self._newfilename(newfname='_bscr')\n</code></pre>"},{"location":"api/api/#pyfaceimage.image.mkphasescr","title":"<code>mkphasescr(**kwargs)</code>","text":"<p>Make phase scrambled stimuli.</p> <p>Other Parameters:</p> Name Type Description <code>rms</code> <code>float</code> <p>the desired RMS of the image. Defaults to 0.3.</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>def mkphasescr(self, **kwargs):\n    \"\"\"Make phase scrambled stimuli.\n\n    Other Parameters\n    ----------------\n    rms : float\n        the desired RMS of the image. Defaults to 0.3.\n    \"\"\"\n    defaultKwargs = {'rms':0.3}\n    kwargs = {**defaultKwargs, **kwargs}\n\n    # make a random phase\n    randphase = np.angle(np.fft.fft2(np.random.rand(self.h, self.w)))\n\n    if self.nchan==0:\n        nchan = 1\n        mat = self.mat[..., np.newaxis] # add one more axis\n    else:\n        nchan = self.nchan\n        mat = self.mat\n\n    outmat = np.empty(mat.shape)\n    outmat[:] = np.NaN\n\n    for i in range(nchan):\n        img_freq = np.fft.fft2(self._stdim(mat[:,:,i], kwargs['rms']))\n        amp = np.abs(img_freq)\n        phase = np.angle(img_freq) + randphase\n        outimg = np.real(np.fft.ifft2(amp * np.exp(np.sqrt(-1+0j)*phase)))\n        stdimg1= self._stdim(outimg, kwargs['rms'])\n        outmat[:,:,i] = (stdimg1+1)/2*255\n\n    if self.nchan==0:\n        outmat = outmat[:,:,0]\n\n    self.remat(np.uint8(outmat))\n    self._newfilename(newfname='_pscr')\n</code></pre>"},{"location":"api/api/#pyfaceimage.image.pad","title":"<code>pad(**kwargs)</code>","text":"<p>Add padding to the image/stimuli.</p> <p>Other Parameters:</p> Name Type Description <code>trgw</code> <code>int</code> <p>the width of the target/desired stimuli.</p> <code>trgh</code> <code>int</code> <p>the height of the target/desired stimuli.</p> <code>padvalue</code> <code>int</code> <p>padding value. Defaults to 0 (show as transparent if alpha channel exists).</p> <code>top</code> <code>bool</code> <p>padding more to top if needed. Defaults to True.</p> <code>left</code> <code>bool</code> <p>padding more to left if needed. Defaults to True.</p> <code>padalpha</code> <code>int</code> <p>the transparent color. Defaults to -1, i.e., not to force it to transparent.</p> <code>extrafn</code> <code>str</code> <p>the string to be added to the filename. Defaults to '_pad'.</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>def pad(self, **kwargs):  \n    \"\"\"\n    Add padding to the image/stimuli.\n\n    Other Parameters\n    ----------------\n    trgw : int\n        the width of the target/desired stimuli. \n    trgh : int\n        the height of the target/desired stimuli.\n    padvalue : int\n        padding value. Defaults to 0 (show as transparent if alpha channel exists).\n    top : bool\n        padding more to top if needed. Defaults to True.\n    left : bool \n        padding more to left if needed. Defaults to True.\n    padalpha : int\n        the transparent color. Defaults to -1, i.e., not to force it to transparent.\n    extrafn : str\n        the string to be added to the filename. Defaults to '_pad'.\n    \"\"\"\n\n    defaultKwargs = {'trgw':self.w, 'trgh':self.h, 'padvalue': 0, 'top': True, 'left':True, 'padalpha':-1, 'extrafn':'_pad'}\n    kwargs = {**defaultKwargs, **kwargs}\n\n    trgw,trgh = kwargs['trgw'], kwargs['trgh']\n\n    assert(trgw&gt;=self.w)\n    assert(trgh&gt;=self.h)\n\n    x1 = int(np.ceil(trgw-self.w)/2)\n    x2 = trgw-self.w-x1\n    y1 = int(np.ceil(trgh-self.h)/2)\n    y2 = trgh-self.h-y1\n\n    if kwargs['top']:\n        htop, hbot = y1,y2\n    else:\n        htop, hbot = y2,y1\n    if kwargs['left']:\n        wleft, wright = x1,x2\n    else:\n        wleft, wright = x2,x1\n\n    if self.nchan==0:\n        nchan = 1\n        mat = self.mat[..., np.newaxis] # add one more axis\n    else:\n        nchan = self.nchan\n        mat = self.mat\n\n    if (kwargs['padalpha']&gt;=0) &amp; (nchan==1 | nchan==3):\n        mat = np.concatenate((mat, np.ones((self.h, self.w, 1), dtype=np.uint8)*kwargs['padalpha']),axis=2)\n        nchan = nchan + 1\n\n    padmat = np.hstack((\n        np.ones((trgh,wleft,nchan),dtype=np.uint8)*kwargs['padvalue'], \n        np.vstack((\n            np.ones((htop,self.w,nchan),dtype=np.uint8)*kwargs['padvalue'], \n            mat,\n            np.ones((hbot,self.w,nchan),dtype=np.uint8)*kwargs['padvalue']\n        )),\n        np.ones((trgh,wright,nchan),dtype=np.uint8)*kwargs['padvalue'], \n    ))\n\n    if (self.nchan==0) &amp; (kwargs['padalpha']&lt;0):\n        padmat = padmat[:,:,0]\n\n    self.remat(padmat)\n    if kwargs['extrafn']!='':\n        self._newfilename(newfname=kwargs['extrafn'])\n</code></pre>"},{"location":"api/api/#pyfaceimage.image.read","title":"<code>read()</code>","text":"<p>Read the image via PIL.</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>def read(self):\n    \"\"\"Read the image via PIL.\n    \"\"\"\n    self._repil(Image.open(self.filename)) # PIL.Image.open() \n</code></pre>"},{"location":"api/api/#pyfaceimage.image.resize","title":"<code>resize(**kwargs)</code>","text":"<p>Resize the image.</p> <p>Other Parameters:</p> Name Type Description <code>trgw</code> <code>int</code> <p>the width of the target/desired stimuli.</p> <code>trgh</code> <code>int</code> <p>the height of the target/desired stimuli.</p> <code>ratio</code> <code>float</code> <p>the ratio to resize the image. Defaults to 0.</p> <code>newfolder</code> <code>str</code> <p>the folder to save the resized image. Defaults to None.</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>def resize(self, **kwargs):\n    \"\"\"Resize the image.\n\n    Other Parameters\n    ----------------\n    trgw : int\n        the width of the target/desired stimuli.\n    trgh : int\n        the height of the target/desired stimuli.\n    ratio : float\n        the ratio to resize the image. Defaults to 0.\n    newfolder : str\n        the folder to save the resized image. Defaults to None.\n    \"\"\"\n    # resize the image\n    defaultKwargs = {'trgw': None, 'trgh': None, 'ratio':0, 'newfolder':None}\n    kwargs = {**defaultKwargs, **kwargs}\n\n    if (kwargs['trgw'] is not None) &amp; (kwargs['trgh'] is not None):\n        (w, h) = (kwargs['trgw'], kwargs['trgh'])\n    elif (kwargs['trgw'] is not None) &amp; (kwargs['trgh'] is None):\n        w = kwargs['trgw']\n        h = int(w*self.h/self.w)\n    elif (kwargs['trgw'] is None) &amp; (kwargs['trgh'] is not None): \n        h = kwargs['trgh']\n        w = int(h*self.w/self.h)\n    elif kwargs['ratio']&gt;0:\n        w = int(self.w*kwargs['ratio'])\n        h = int(self.h*kwargs['ratio'])\n    else:\n        raise 'Cannot determine the desired dimentions...'\n\n    kwargs['size'] = (w,h)\n    if (kwargs['newfolder'] is None):\n        newfolder = str(w)+'_'+str(h)\n    else:\n        newfolder = kwargs['newfolder']\n\n    [kwargs.pop(k) for k in defaultKwargs.keys()] # remove unused keys\n\n    # save re-sized images (information)\n    self._repil(self.pil.resize(**kwargs))\n    self._newfilename(newfolder=newfolder)\n</code></pre>"},{"location":"api/api/#pyfaceimage.image.rotate","title":"<code>rotate(angle=180)</code>","text":"<p>Rotate the image unclockwise.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>the angle to rotate the image. Defaults to 180.</p> <code>180</code> Source code in <code>pyfaceimage/im.py</code> <pre><code>def rotate(self, angle=180):\n    \"\"\"Rotate the image unclockwise.\n\n    Parameters\n    ----------\n    angle : float\n        the angle to rotate the image. Defaults to 180.\n    \"\"\"\n    # rotate the image\n    self._repil(self.pil.rotate(angle))\n</code></pre>"},{"location":"api/api/#pyfaceimage.image.save","title":"<code>save(newfname='', newfolder='', addfn=True, **kwargs)</code>","text":"<p>Save the image PIL.</p> <p>Parameters:</p> Name Type Description Default <code>newfname</code> <code>str</code> <p>strings to be added before the extension, by default ''</p> <code>''</code> <code>newfolder</code> <code>str</code> <p>folder name to replace the global directory or the last directory level, by default ''</p> <code>''</code> <code>addfn</code> <code>bool</code> <p>whether to add the newfname to the the original fname (instead of replacing it), by default True</p> <code>True</code> <code>kwargs</code> <code>dict</code> <p>keyword arguments for matplotlib.pyplot.imsave(), by default {}</p> <code>{}</code> Source code in <code>pyfaceimage/im.py</code> <pre><code>def save(self, newfname='', newfolder='', addfn=True, **kwargs):\n    \"\"\"Save the image PIL.\n\n    Parameters\n    ----------\n    newfname : str, optional\n        strings to be added before the extension, by default ''\n    newfolder : str, optional\n        folder name to replace the global directory or the last directory level, by default ''\n    addfn : bool, optional\n        whether to add the newfname to the the original fname (instead of replacing it), by default True\n    kwargs : dict, optional\n        keyword arguments for matplotlib.pyplot.imsave(), by default {}\n    \"\"\"\n    # update the filename\n    self._newfilename(newfname, newfolder, addfn=addfn)\n\n    # make dir(s)\n    if not os.path.isdir(os.path.dirname(self.filename)):\n        os.makedirs(os.path.dirname(self.filename))\n\n    # use PIL.Image.save() to save .pil    \n    self.pil.save(self.filename, format=None, **kwargs)\n    self.isfile = os.path.isfile(self.filename)\n</code></pre>"},{"location":"api/api/#pyfaceimage.image.sffilter","title":"<code>sffilter(**kwargs)</code>","text":"<p>Apply spatial frequency filter to the image.</p> <p>Other Parameters:</p> Name Type Description <code>rms</code> <code>float</code> <p>the desired RMS of the image. Defaults to 0.3.</p> <code>maxvalue</code> <code>int</code> <p>the maximum value of the image. Defaults to 255.</p> <code>sffilter</code> <code>str</code> <p>the spatial frequency filter. Defaults to 'low'.</p> <code>cutoff</code> <code>float</code> <p>the cutoff frequency. Defaults to 0.05.</p> <code>n</code> <code>int</code> <p>the order of the filter. Defaults to 10.</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>def sffilter(self, **kwargs):\n    \"\"\"Apply spatial frequency filter to the image.\n\n    Other Parameters\n    ----------------\n    rms : float\n        the desired RMS of the image. Defaults to 0.3.\n    maxvalue : int\n        the maximum value of the image. Defaults to 255.\n    sffilter : str\n        the spatial frequency filter. Defaults to 'low'.\n    cutoff : float\n        the cutoff frequency. Defaults to 0.05.\n    n : int\n        the order of the filter. Defaults to 10.\n    \"\"\"\n    # https://www.djmannion.net/psych_programming/vision/sf_filt/sf_filt.html\n    import psychopy.filters\n\n    defaultKwargs = {'rms':0.3, 'maxvalue':255, 'sffilter':'low',\n                     'cutoff': 0.05, 'n': 10}\n    kwargs = {**defaultKwargs, **kwargs}\n\n    self.grayscale()\n    stdmat = self._stdim(self.mat, kwargs['rms'])\n    img_freq = np.fft.fft2(stdmat)\n\n    # calculate amplitude spectrum\n    # img_amp = np.fft.fftshift(np.abs(img_freq))\n\n    # # for display, take the logarithm\n    # img_amp_disp = np.log(img_amp + 0.0001)\n\n    # # rescale to -1:+1 for display\n    # img_amp_disp = (\n    #     ((img_amp_disp - np.min(img_amp_disp)) * 2) / \n    #     np.ptp(img_amp_disp)  # 'ptp' = range\n    # ) - 1\n\n    if kwargs['sffilter']=='low':\n        # for generating blury images\n        fsfilt = psychopy.filters.butter2d_lp(\n            size=(self.w, self.h),\n            cutoff=kwargs['cutoff'],\n            n=kwargs['n']\n        )\n    elif kwargs['sffilter']=='high':      \n         # for gernerating sharp images\n        fsfilt = psychopy.filters.butter2d_hp(\n            size=(self.w, self.h),\n            cutoff=kwargs['cutoff'],\n            n=kwargs['n']\n        )\n    else:\n        raise 'Cannot identify the \"sffilter\" value...'\n\n    img_filt = np.fft.fftshift(img_freq) * fsfilt.transpose()\n    # convert back to an image\n    img_new = np.real(np.fft.ifft2(np.fft.ifftshift(img_filt)))\n    # standardize the image to [-1, 1]\n    img_new = self._stdim(img_new, kwargs['rms'])\n    # convert the range to [0, 255]\n    img_new = (img_new+1)/2*kwargs['maxvalue']\n    self.remat(img_new)\n    self._newfilename(newfname='_'+kwargs['sffilter']+'_filtered')\n</code></pre>"},{"location":"api/api/#pyfaceimage.image.show","title":"<code>show()</code>","text":"<p>Show the image PIL.</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>def show(self):\n    \"\"\"Show the image PIL.\n    \"\"\"\n    # for debugging purpose (check the PIL)\n    self.pil.show()\n</code></pre>"},{"location":"api/api/#pyfaceimage.image.torgba","title":"<code>torgba()</code>","text":"<p>Convert the image to RGBA.</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>def torgba(self):\n    \"\"\"Convert the image to RGBA.\n    \"\"\"\n    # convert pil to RGBA and save in .mat\n    if len(self.mat.shape)==2: # Gray\n        self.mat = self.mat[..., np.newaxis]\n    assert len(self.mat.shape)==3\n\n    nchan = self.mat.shape[2]\n    if nchan==1: # Gray 'L'\n        rgbmat = np.repeat(self.mat, 3, axis=2) # RGB\n        amat = np.ones_like(rgbmat[:,:,0],dtype=np.uint8)*rgbmat.max() # alpha\n    elif nchan==2: # Gray 'LA'\n        rgbmat = np.repeat(self.mat[:,:,0:1], 3, axis=2) # RGB\n        amat = self.mat[:,:,-1] # alpha\n    elif nchan==3: # RGB\n        rgbmat = self.mat # RGB\n        amat = np.ones_like(rgbmat[:,:,0],dtype=np.uint8)*rgbmat.max() # alpha\n    elif nchan==4: # RGBA\n        rgbmat = self.mat[:,:,0:3]\n        amat = self.mat[:,:,-1]\n\n    self.rgbmat = rgbmat\n    self.amat = amat\n    self.mat = np.concatenate((rgbmat, amat[..., np.newaxis]), axis=2) # RGBA\n    self.remat(self.mat)\n</code></pre>"},{"location":"api/api/#pyfaceimage.image.touch","title":"<code>touch(touchfolder='')</code>","text":"<p>Touch a new empty file.</p> <p>Parameters:</p> Name Type Description Default <code>touchfolder</code> <code>str</code> <p>folder name to replace the global directory or the last directory level, by default ''</p> <code>''</code> Source code in <code>pyfaceimage/im.py</code> <pre><code>def touch(self, touchfolder=''):\n    \"\"\"Touch a new empty file.\n\n    Parameters\n    ----------\n    touchfolder : str, optional\n        folder name to replace the global directory or the last directory level, by default ''\n    \"\"\"\n    # update the directory\n    self._newfilename(newfolder=touchfolder)\n\n    if self.isfile:\n        # throw warnings if file exists\n        warnings.warn(\"The file named '%s' already exists...\" % self.filename)\n    else:\n        # make dir if needed\n        if not os.path.isdir(self.dirname):\n            os.makedirs(self.dirname)\n        # touch the file\n        Path(self.filename).touch()\n</code></pre>"},{"location":"api/api/#pyfaceimage.image.updateext","title":"<code>updateext(ext)</code>","text":"<p>Update the filename information.</p> <p>Parameters:</p> Name Type Description Default <code>ext</code> <code>str</code> <p>the new extension.</p> required Source code in <code>pyfaceimage/im.py</code> <pre><code>def updateext(self, ext):\n    \"\"\"Update the filename information.\n\n    Parameters\n    ----------\n    ext : str\n        the new extension.\n    \"\"\"\n    if ext[0] != '.':\n        ext = '.'+ext\n    self.filename = self.dirname + os.sep + self.fnonly + ext\n    self._updatefromfilename()\n</code></pre>"},{"location":"api/api/#pyfaceimage.adjust","title":"<code>adjust(imdict, **kwargs)</code>","text":"<p>Adjust the luminance and contrast of the image.</p> <p>Parameters:</p> Name Type Description Default <code>imdict</code> <code>dict</code> <p>A dictionary of image() instances.</p> required <p>Other Parameters:</p> Name Type Description <code>lum</code> <code>float</code> <p>the desired mean of the image. Defaults to None.</p> <code>rms</code> <code>float</code> <p>the desired standard deviation of the image. Defaults to None.</p> <code>mask</code> <code>array</code> <p>the mask for the image. Defaults to None.</p> Source code in <code>pyfaceimage/__init__.py</code> <pre><code>def adjust(imdict, **kwargs):\n    \"\"\"Adjust the luminance and contrast of the image.\n\n    Parameters\n    ----------\n    imdict : dict\n        A dictionary of image() instances.\n\n    Other Parameters\n    ----------------\n    lum : float\n        the desired mean of the image. Defaults to None.\n    rms : float\n        the desired standard deviation of the image. Defaults to None.\n    mask : np.array\n        the mask for the image. Defaults to None.\n    \"\"\"\n    [v.adjust(**kwargs) for v in imdict.values()]\n</code></pre>"},{"location":"api/api/#pyfaceimage.concateims","title":"<code>concateims(imdict, pairstyle='perm', **kwargs)</code>","text":"<p>Concatenate images in the dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>imdict</code> <code>dict</code> <p>A dictionary of image() instances.</p> required <code>pairstyle</code> <code>str</code> <p>the style of the pairs. Defaults to \"perm\". Options are \"perm\" (<code>itertools.permutation</code>), \"comb\" (<code>itertools.combination</code>), \"comb_repl\" (<code>itertools.combinations_with_replacement</code>), \"prod\" (<code>itertools.product</code>) and \"itself\" (concatenate itself).</p> <code>'perm'</code> <p>Other Parameters:</p> Name Type Description <code>axis</code> <code>int</code> <p>the axis along which the images are concatenated. Defaults to 1, i.e., horizontally.</p> <code>sep</code> <code>str</code> <p>the separator between the two images. Defaults to \"-\".</p> <code>padvalue</code> <code>int</code> <p>padding value. Defaults to 0 (show as transparent if alpha channel exists).</p> <p>Returns:</p> Type Description <code>im.image() instance</code> <p>the concatenated image.</p> Source code in <code>pyfaceimage/__init__.py</code> <pre><code>def concateims(imdict, pairstyle=\"perm\", **kwargs):\n    \"\"\"Concatenate images in the dictionary.\n\n    Parameters\n    ----------\n    imdict : dict\n        A dictionary of image() instances.\n    pairstyle : str\n        the style of the pairs. Defaults to \"perm\". Options are \"perm\" (`itertools.permutation`), \"comb\" (`itertools.combination`), \"comb_repl\" (`itertools.combinations_with_replacement`), \"prod\" (`itertools.product`) and \"itself\" (concatenate itself).\n\n    Other Parameters\n    ----------------\n    axis : int\n        the axis along which the images are concatenated. Defaults to 1, i.e., horizontally.\n    sep : str\n        the separator between the two images. Defaults to \"-\".\n    padvalue : int\n        padding value. Defaults to 0 (show as transparent if alpha channel exists).\n\n    Returns\n    -------\n    im.image() instance\n        the concatenated image.\n    \"\"\"\n\n    # make sure the dictionary is flatten\n    if not _isflatten(imdict):\n        imdict = _flatten(imdict)\n\n    # check the number of im\n    nim = len(imdict)\n    assert nim&gt;1, f'There should be more than one im in imdict... (Now {nim})'\n\n    # generate all possible combinations of concatenated images\n    concatedict = {}\n    for (k1, k2) in _mkpair(imdict, pairstyle=pairstyle):\n        tmpconcate, concate_fn = concatenate(imdict[k1], imdict[k2], **kwargs)\n        concatedict[concate_fn]=tmpconcate\n\n    return concatedict\n</code></pre>"},{"location":"api/api/#pyfaceimage.concatenate","title":"<code>concatenate(im1, im2, axis=1, sep='-', padval=0)</code>","text":"<p>Concatenate two images along the specified axis.</p> <p>Parameters:</p> Name Type Description Default <code>im1</code> <code>im.image() instance</code> <p>the first image.</p> required <code>im2</code> <code>im.image() instance</code> <p>the second image.</p> required <p>Other Parameters:</p> Name Type Description <code>axis</code> <code>int</code> <p>the axis along which the images are concatenated. Defaults to 1, i.e. horizontally.</p> <code>sep</code> <code>str</code> <p>the separator between the two images. Defaults to \"-\".</p> <code>padval</code> <code>int</code> <p>the value to pad the images. Defaults to 0.</p> <p>Returns:</p> Type Description <code>im.image() instance</code> <p>the concatenated image.</p> Source code in <code>pyfaceimage/multim.py</code> <pre><code>def concatenate(im1, im2, axis=1, sep=\"-\", padval=0):\n    \"\"\"Concatenate two images along the specified axis.\n\n    Parameters\n    ----------\n    im1 : im.image() instance\n        the first image.\n    im2 : im.image() instance\n        the second image.\n\n    Other Parameters\n    ----------------\n    axis : int\n        the axis along which the images are concatenated. Defaults to 1, i.e. horizontally.\n    sep : str\n        the separator between the two images. Defaults to \"-\".\n    padval : int\n        the value to pad the images. Defaults to 0.\n\n    Returns\n    -------\n    im.image() instance\n        the concatenated image.\n    \"\"\"\n\n    im = im1.deepcopy()\n\n    # pad the images if necessary\n    if axis==0:\n        if im.w&gt;im2.w:\n            im2.pad(trgw=im.w, padval=padval)\n        elif im.w&lt;im2.w:\n            im.pad(trgw=im2.w, padval=padval)\n    elif axis==1:\n        if im.h&gt;im2.h:\n            im2.pad(trgh=im.h, padval=padval)\n        elif im.h&lt;im2.h:\n            im.pad(trgh=im2.h, padval=padval)\n\n    # concatenate the images\n    if axis==0:\n        im.pil = Image.fromarray(np.concatenate((im.pil, im2.pil), axis=0))\n    elif axis==1:\n        im.pil = Image.fromarray(np.concatenate((im.pil, im2.pil), axis=1))\n    im._repil(im.pil)\n\n    # update the filename\n    newfilename = im.fnonly+sep+im2.fnonly\n    im._newfilename(newfname=newfilename, addfn=False)\n\n    return (im, newfilename)\n</code></pre>"},{"location":"api/api/#pyfaceimage.cropoval","title":"<code>cropoval(imdict, **kwargs)</code>","text":"<p>Crop the image with an oval shape.</p> <p>Parameters:</p> Name Type Description Default <code>imdict</code> <code>dict</code> <p>A dictionary of image() instances.</p> required <p>Other Parameters:</p> Name Type Description <code>radius</code> <code>tuple</code> <p>the radius of the oval. Defaults to (100,128).</p> <code>bgcolor</code> <code>tuple</code> <p>the background color. Defaults to None.</p> Source code in <code>pyfaceimage/__init__.py</code> <pre><code>def cropoval(imdict, **kwargs):\n    \"\"\"Crop the image with an oval shape.\n\n    Parameters\n    ----------\n    imdict : dict\n        A dictionary of image() instances.\n\n    Other Parameters\n    ----------------\n    radius : tuple\n        the radius of the oval. Defaults to (100,128).\n    bgcolor : tuple\n        the background color. Defaults to None.\n    \"\"\"\n    [v.cropoval(**kwargs) for v in imdict.values()]\n</code></pre>"},{"location":"api/api/#pyfaceimage.croprect","title":"<code>croprect(imdict, **kwargs)</code>","text":"<p>Crop the image with a rectangle box.</p> <p>Parameters:</p> Name Type Description Default <code>imdict</code> <code>dict</code> <p>A dictionary of image() instances.</p> required <p>Other Parameters:</p> Name Type Description <code>box</code> <code>tuple</code> <p>the box to crop the image. Defaults to None.</p> Source code in <code>pyfaceimage/__init__.py</code> <pre><code>def croprect(imdict, **kwargs):\n    \"\"\"Crop the image with a rectangle box.\n\n    Parameters\n    ----------\n    imdict : dict\n        A dictionary of image() instances.\n\n    Other Parameters\n    ----------------\n    box : tuple\n        the box to crop the image. Defaults to None.\n    \"\"\"\n    [v.croprect(**kwargs) for v in imdict.values()]\n</code></pre>"},{"location":"api/api/#pyfaceimage.deepcopy","title":"<code>deepcopy(imdict)</code>","text":"<p>Deep copy the dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>imdict</code> <code>dict</code> <p>A dictionary of image() instances.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A deep copied dictionary of images.</p> Source code in <code>pyfaceimage/__init__.py</code> <pre><code>def deepcopy(imdict):\n    \"\"\"Deep copy the dictionary.\n\n    Parameters\n    ----------\n    imdict : dict\n        A dictionary of image() instances.\n\n    Returns\n    -------\n    dict\n        A deep copied dictionary of images.\n    \"\"\"\n    return copy.deepcopy(imdict)\n</code></pre>"},{"location":"api/api/#pyfaceimage.dir","title":"<code>dir(path=os.getcwd(), imwc='*.png', read=True, sep='/')</code>","text":"<p>List all images in the path and subdirs. Please make sure none of the subdirectories is named as 'path'.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>path to the directory where the images are stored, by default os.getcwd()</p> <code>getcwd()</code> <code>imwc</code> <code>str</code> <p>wildcard to identify images (but not the subdirectories), by default '*.png'</p> <code>'*.png'</code> <code>read</code> <code>bool</code> <p>whether read the images (more see im.image()), by default True</p> <code>True</code> <code>sep</code> <p>a string to be used to concatnate the subdirectory and image name, which is used as the key for flattening the dictionary, by default '/'</p> <code>'/'</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of image() instances in the path and subdirs.</p> Source code in <code>pyfaceimage/__init__.py</code> <pre><code>def dir(path=os.getcwd(), imwc='*.png', read=True, sep='/'):\n    \"\"\"List all images in the path and subdirs. Please make sure none of the subdirectories is named as 'path'.\n\n    Parameters\n    ----------\n    path : str, optional\n        path to the directory where the images are stored, by default os.getcwd()\n    imwc : str, optional\n        wildcard to identify images (but not the subdirectories), by default '*.png'\n    read : bool, optional\n        whether read the images (more see im.image()), by default True\n    sep: str, optional\n        a string to be used to concatnate the subdirectory and image name, which is used as the key for flattening the dictionary, by default '/'\n\n    Returns\n    -------\n    dict\n        A dictionary of image() instances in the path and subdirs.\n    \"\"\"\n\n    # list all files in the path\n    imdict_root = _dir(path, imwc, read)\n    [im._setgroup('path') for im in imdict_root.values()] # update group info as 'path'    \n\n    # list all dirs in the subdirectories\n    subdirs = [d for d in os.listdir(path) \n               if os.path.isdir(os.path.join(path,d))] # is a dir\n    assert 'path' not in subdirs, f'\"path\" is not a valid subdir name...'\n    imdict = {sub:_dir(path=os.path.join(path, sub), imwc=imwc, read=read) \n                  for sub in subdirs}\n\n    # add images in path to the dictionary\n    if bool(imdict_root):\n        imdict['path'] = imdict_root \n\n    # flatten the dictionary\n    if bool(sep): imdict = _flatten(imdict, sep=sep)      \n\n    # set the global path\n    [im._setgpath(path) for im in imdict.values()]\n\n    return imdict\n</code></pre>"},{"location":"api/api/#pyfaceimage.grayscale","title":"<code>grayscale(imdict, **kwargs)</code>","text":"<p>Convert the image to gray-scale.</p> <p>Parameters:</p> Name Type Description Default <code>imdict</code> <code>dict</code> <p>A dictionary of image() instances.</p> required Source code in <code>pyfaceimage/__init__.py</code> <pre><code>def grayscale(imdict, **kwargs):\n    \"\"\"Convert the image to gray-scale.\n\n    Parameters\n    ----------\n    imdict : dict\n        A dictionary of image() instances.\n    \"\"\"\n    [v.grayscale(**kwargs) for v in imdict.values()] \n</code></pre>"},{"location":"api/api/#pyfaceimage.mkboxscr","title":"<code>mkboxscr(imdict, **kwargs)</code>","text":"<p>Make box scrambled stimuli.</p> <p>Parameters:</p> Name Type Description Default <code>imdict</code> <code>dict</code> <p>A dictionary of image() instances.</p> required <p>Other Parameters:</p> Name Type Description <code>nBoxW</code> <code>int</code> <p>the number of boxes in width. Defaults to 10.</p> <code>nBoxH</code> <code>int</code> <p>the number of boxes in height. Defaults to 16.</p> <code>pBoxW</code> <code>int</code> <p>the width of a box. Defaults to 0.</p> <code>pBoxH</code> <code>int</code> <p>the height of a box. Defaults to 0.</p> <code>pad</code> <code>bool</code> <p>whether to add padding to the image. Defaults to False.</p> <code>padcolor</code> <code>int</code> <p>the padding color. Defaults to 0.</p> <code>padalpha</code> <code>int</code> <p>the padding alpha. Defaults to -1.</p> Source code in <code>pyfaceimage/__init__.py</code> <pre><code>def mkboxscr(imdict, **kwargs):\n    \"\"\"Make box scrambled stimuli.\n\n    Parameters\n    ----------\n    imdict : dict\n        A dictionary of image() instances.\n\n    Other Parameters\n    ----------------\n    nBoxW : int\n        the number of boxes in width. Defaults to 10.\n    nBoxH : int\n        the number of boxes in height. Defaults to 16.\n    pBoxW : int\n        the width of a box. Defaults to 0.\n    pBoxH : int\n        the height of a box. Defaults to 0.\n    pad : bool\n        whether to add padding to the image. Defaults to False.\n    padcolor : int\n        the padding color. Defaults to 0.\n    padalpha : int\n        the padding alpha. Defaults to -1.\n    \"\"\"\n    [v.mkboxscr(**kwargs) for v in imdict.values()]\n</code></pre>"},{"location":"api/api/#pyfaceimage.mkcf","title":"<code>mkcf(im1, im2, **kwargs)</code>","text":"<p>Make composite faces (for the composite face task) with im1 and im2.</p> <p>Parameters:</p> Name Type Description Default <code>im1</code> <code>im.image() instance</code> <p>one im.image() instane for creating composite faces.</p> required <code>im2</code> <code>im.image() instance</code> <p>another im.image() instane for creating composite faces.</p> required <p>Other Parameters:</p> Name Type Description <code>misali</code> <code>(int, num)</code> <p>misalignment. Positive int will shift to the right and negative int will shift to the left. If misali is int, it refers to pixels. If misali is decimal, it misali*face width is the amount of misalignment. Defaults to 0.</p> <code>topis1</code> <code>bool</code> <p>whether im1 (or im2) is used as the top of the composite face. Defaults to True.</p> <code>cueistop</code> <code>bool</code> <p>whether the top half is cued. Defaults to True.</p> <code>lineh</code> <code>int</code> <p>the height (in pixels) of the line between the top and bottom facial havles. Defaults to 3.</p> <code>width_cf</code> <code>int</code> <p>the width of the composite face/the line (also the width of the output composite face image). Defaults to three times of the face width.</p> <code>lineclr</code> <code>int tuple</code> <p>the color of the line. Defaults to (255,255,255), i.e., white.</p> <code>showcue</code> <code>bool</code> <p>whether to display cue in the image. Defaults to False.</p> <code>cueclr</code> <code>int tuple</code> <p>the color of the cue. Defaults to the same as lineclr.</p> <code>cuethick</code> <code>int</code> <p>the thickness (in pixels) of the cue. Defaults to 4.</p> <code>cuew</code> <code>int</code> <p>the width (in pixels) of the cue. Defaults to 110% of the face width.</p> <code>cueh</code> <code>int</code> <p>the height (in pixels) of the very left and right parts of the cue. Defaults to about 5% of the face height.</p> <code>cuedist</code> <code>int</code> <p>distance from the main part of the cue to edge of the face. Defaults to twice of cueh.</p> <p>Returns:</p> Name Type Description <code>im.image() instance</code> <p>the composite face stimuli as a im.image() instance.</p> <code>fn_cf</code> <code>str</code> <p>the filename of the composite face stimuli.</p> Source code in <code>pyfaceimage/multim.py</code> <pre><code>def mkcf(im1, im2, **kwargs):\n    \"\"\"Make composite faces (for the composite face task) with im1 and im2.\n\n    Parameters\n    ----------\n    im1 : im.image() instance\n        one im.image() instane for creating composite faces.\n    im2 : im.image() instance\n        another im.image() instane for creating composite faces.\n\n    Other Parameters\n    ----------------\n    misali : int, num\n        misalignment. Positive int will shift to the right and negative int will shift to the left. If misali is int, it refers to pixels. If misali is decimal, it misali*face width is the amount of misalignment. Defaults to 0.\n    topis1 : bool\n        whether im1 (or im2) is used as the top of the composite face. Defaults to True.\n    cueistop : bool\n        whether the top half is cued. Defaults to True.\n    lineh : int\n        the height (in pixels) of the line between the top and bottom facial havles. Defaults to 3.\n    width_cf : int\n        the width of the composite face/the line (also the width of the output composite face image). Defaults to three times of the face width.\n    lineclr : int tuple\n        the color of the line. Defaults to (255,255,255), i.e., white.\n    showcue : bool\n        whether to display cue in the image. Defaults to False.\n    cueclr : int tuple\n        the color of the cue. Defaults to the same as lineclr.\n    cuethick : int\n        the thickness (in pixels) of the cue. Defaults to 4.\n    cuew : int\n        the width (in pixels) of the cue. Defaults to 110% of the face width.\n    cueh : int\n        the height (in pixels) of the very left and right parts of the cue. Defaults to about 5% of the face height.\n    cuedist : int\n        distance from the main part of the cue to edge of the face. Defaults to twice of cueh.\n\n    Returns\n    -------\n    im.image() instance\n        the composite face stimuli as a im.image() instance.\n    fn_cf : str\n        the filename of the composite face stimuli.\n    \"\"\"\n\n    defaultKwargs = {'misali':0, 'topis1': True, 'cueistop': True,\n                     'lineh':3, 'width_cf': im1.w*3, 'lineclr': None,\n                     'showcue':False, 'cueclr':None,\n                     'cuethick': 4, 'cuew': int(im1.w*1.1), 'cueh': int(im1.h*.05), 'cuedist': None}\n    kwargs = {**defaultKwargs, **kwargs}\n\n    # decide the width of the output CF image\n    w_cf = kwargs['width_cf']\n    if isinstance(kwargs['misali'], int):\n        misali = kwargs['misali']\n    else:\n        misali = int(kwargs['misali']*im1.w)\n    assert (misali+im1.w/2)&lt;=w_cf/2, f'Please make sure the width of the composite face ({w_cf}) is set appropriately to fit the misalignment ({misali}).'\n\n    # generate the default color for the (white) line\n    if kwargs['lineclr'] is None: \n        kwargs['lineclr'] = (255,) * im1.nchan # white line\n    else:\n        assert len(kwargs['lineclr'])==im1.nchan, f\"The lenght of 'lineclr' should match im1.nchan({im1.nchan})\"\n\n    if kwargs['cueclr'] is None: \n        kwargs['cueclr'] = kwargs['lineclr']\n    else:\n        assert len(kwargs['cueclr'])==im1.nchan, f\"The lenght of 'cueclr' should match im1.nchan({im1.nchan})\"\n\n    alistrs = ['ali', 'mis']\n    bboxes = [(0, 0, im1.w, im1.h/2), (0, im1.h/2, im1.w, im1.h)] # top, bottom\n    dests = [((w_cf-im1.w)//2+misali*(1-kwargs['cueistop']), 0), # top position\n             ((w_cf-im1.w)//2+misali*kwargs['cueistop'], im1.h//2+kwargs['lineh'])] # bottom position\n    fns_12 = [im1.fnonly, im2.fnonly]\n\n    fn_cf = os.path.join(fns_12[1-kwargs['topis1']]+'_'+fns_12[kwargs['topis1']]+'_'+alistrs[misali!=0])\n\n    # top and bottom pil\n    im1_half = im1.deepcopy()\n    im2_half = im2.deepcopy()\n    im1_half.croprect(bboxes[1-kwargs['topis1']])\n    im2_half.croprect(bboxes[kwargs['topis1']])\n\n    # create a new canvas and paste the image\n    dist_cf = Image.new(im1.pil.mode, (w_cf, im1.h+kwargs['lineh']))\n    # white line\n    drawl = ImageDraw.Draw(dist_cf)\n    drawl.rectangle((0,im1.h//2,w_cf,im1.h//2+kwargs['lineh']-1),fill=kwargs['lineclr'])\n    # top and bottom\n    dist_cf.paste(im1_half.pil, dests[1-kwargs['topis1']])\n    dist_cf.paste(im2_half.pil, dests[kwargs['topis1']])\n\n    if kwargs['showcue']:\n        if kwargs['cuedist'] is None:\n            kwargs['cuedist']= kwargs['cueh']*2\n        # cues\n        cue1 = Image.new(im1.pil.mode, (w_cf, kwargs['cuedist']))\n        cue2 = cue1.copy()\n        drawc = ImageDraw.Draw(cue1)\n        drawc.rectangle(((w_cf-kwargs['cuew'])//2,0,(w_cf+kwargs['cuew'])//2-1,kwargs['cuethick']-1),fill=kwargs['cueclr'])\n        drawc.rectangle(((w_cf-kwargs['cuew'])//2,kwargs['cuethick'],\n                        (w_cf-kwargs['cuew'])//2+kwargs['cuethick']-1,kwargs['cueh']+kwargs['cuethick']-1),\n                        fill=kwargs['cueclr'])\n        drawc.rectangle(((w_cf+kwargs['cuew'])//2-kwargs['cuethick'],kwargs['cuethick'],\n                        (w_cf+kwargs['cuew'])//2-1,kwargs['cueh']+kwargs['cuethick']-1),\n                        fill=kwargs['cueclr'])\n        cues = [cue1, cue2]\n\n        # concatenate CF and cues\n        dist = Image.new(im1.pil.mode, (w_cf, cue1.size[1]*2+dist_cf.size[1]))\n        dist.paste(cues[1-kwargs['cueistop']], (0, 0))\n        dist.paste(dist_cf, (0, cue1.size[1]))\n        dist.paste(ImageOps.flip(cues[kwargs['cueistop']]), (0, cue1.size[1]+dist_cf.size[1]))\n\n        # add the cue str to filename\n        fn_cf = fn_cf+'_'+['top', 'bot'][1-kwargs['cueistop']]\n\n    else:\n        dist = dist_cf\n\n    # update/save the cf image information\n    im_cf = im1.deepcopy()\n    im_cf._repil(dist)\n    im_cf._newfilename(newfname=fn_cf, addfn=False)\n\n    return im_cf, fn_cf\n</code></pre>"},{"location":"api/api/#pyfaceimage.mkcf_prf","title":"<code>mkcf_prf(dict_cf, dict_bg, imsize_bg=(500, 500), opaque=0.75)</code>","text":"<p>Make composite face stimuli for the pRF experiment.</p> <p>Parameters:</p> Name Type Description Default <code>dict_cf</code> <code>dict</code> <p>a dictionary of composite faces.</p> required <code>dict_bg</code> <code>dict</code> <p>a dictionary of background images.</p> required <code>imsize_bg</code> <code>tuple</code> <p>the output image size, by default (500,500)</p> <code>(500, 500)</code> <code>opaque</code> <code>float</code> <p>ratio of the opaque region, by default .75</p> <code>0.75</code> <p>Returns:</p> Type Description <code>dict</code> <p>a dictionary of composite face stimuli to be used for the pRF experiment.</p> Source code in <code>pyfaceimage/exps.py</code> <pre><code>def mkcf_prf(dict_cf, dict_bg, imsize_bg=(500,500), opaque=.75):\n    \"\"\"Make composite face stimuli for the pRF experiment.\n\n    Parameters\n    ----------\n    dict_cf : dict\n        a dictionary of composite faces.\n    dict_bg : dict\n        a dictionary of background images.\n    imsize_bg : tuple, optional\n        the output image size, by default (500,500)\n    opaque : float, optional\n        ratio of the opaque region, by default .75\n\n    Returns\n    -------\n    dict\n        a dictionary of composite face stimuli to be used for the pRF experiment.\n    \"\"\"\n\n    # Initialize the output dict\n    imdict_out = {}\n\n    for k,im_fore in dict_cf.items():\n\n        # this fore and background images\n        k_back = k.replace('mis', 'ali').replace('_l', '').replace('_r', '')+'_pscr' # only use aligend background\n        im_back = dict_bg[k_back]\n\n        # phase scrambed background\n        im_back.resize(trgw=imsize_bg[0], trgh=imsize_bg[1])\n\n        # mask\n        mask = pyfaceimage.utilities.radial_gaussian(imsize_bg, opaque)\n\n        # add fore to back\n        im_back_tmp = im_back.deepcopy()\n        pyfaceimage.multim.composite(im_back_tmp, im_fore)\n\n        # apply mask\n        im_back_tmp.pil.putalpha(mask)\n\n        # update the filename\n        im_back_tmp.filename = im_fore.filename.replace('_pad', '')\n        im_back_tmp._updatefromfilename()\n\n        # save the output dict\n        imdict_out[k] = im_back_tmp\n        del im_back_tmp\n\n    return imdict_out\n</code></pre>"},{"location":"api/api/#pyfaceimage.mkcfs","title":"<code>mkcfs(imdict, sep='/', **kwargs)</code>","text":"<p>Make composite faces for all possible combinations of images in the dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>imdict</code> <code>dict</code> <p>A dictionary of image() instances.</p> required <code>sep</code> <code>str</code> <p>a string to be used to concatnate the subdirectory and image name, which is used as the key for flattening the dictionary, by default '/'. If sep is None, the dictionary will not be flatten.</p> <code>'/'</code> <p>Other Parameters:</p> Name Type Description <code>misali</code> <code>(int, num)</code> <p>misalignment. Positive int will shift to the right and negative int will shift to the left. If misali is int, it refers to pixels. If misali is decimal, it misali*face width is the amount of misalignment. Defaults to 0.</p> <code>topis1</code> <code>bool</code> <p>whether im1 (or im2) is used as the top of the composite face. Defaults to True.</p> <code>cueistop</code> <code>bool</code> <p>whether the top half is cued. Defaults to True.</p> <code>lineh</code> <code>int</code> <p>the height (in pixels) of the line between the top and bottom facial havles. Defaults to 3.</p> <code>width_cf</code> <code>int</code> <p>the width of the composite face/the line (also the width of the output composite face image). Defaults to three times of the face width.</p> <code>lineclr</code> <code>int tuple</code> <p>the color of the line. Defaults to (255,255,255), i.e., white.</p> <code>showcue</code> <code>bool</code> <p>whether to display cue in the image. Defaults to False.</p> <code>cueclr</code> <code>int tuple</code> <p>the color of the cue. Defaults to the same as lineclr.</p> <code>cuethick</code> <code>int</code> <p>the thickness (in pixels) of the cue. Defaults to 4.</p> <code>cuew</code> <code>int</code> <p>the width (in pixels) of the cue. Defaults to 110% of the face width.</p> <code>cueh</code> <code>int</code> <p>the height (in pixels) of the very left and right parts of the cue. Defaults to about 5% of the face height.</p> <code>cuedist</code> <code>int</code> <p>distance from the main part of the cue to edge of the face. Defaults to twice of cueh.</p> <p>Returns:</p> Type Description <code>A dictionary of im.image() instance</code> <p>the composite face stimuli as a im.image() instance.</p> Source code in <code>pyfaceimage/__init__.py</code> <pre><code>def mkcfs(imdict, sep='/', **kwargs):\n    \"\"\"Make composite faces for all possible combinations of images in the dictionary.\n\n    Parameters\n    ----------\n    imdict : dict\n        A dictionary of image() instances.\n    sep : str, optional\n        a string to be used to concatnate the subdirectory and image name, which is used as the key for flattening the dictionary, by default '/'. If sep is None, the dictionary will not be flatten.\n\n    Other Parameters\n    ----------------\n    misali : int, num\n        misalignment. Positive int will shift to the right and negative int will shift to the left. If misali is int, it refers to pixels. If misali is decimal, it misali*face width is the amount of misalignment. Defaults to 0.\n    topis1 : bool\n        whether im1 (or im2) is used as the top of the composite face. Defaults to True.\n    cueistop : bool\n        whether the top half is cued. Defaults to True.\n    lineh : int\n        the height (in pixels) of the line between the top and bottom facial havles. Defaults to 3.\n    width_cf : int\n        the width of the composite face/the line (also the width of the output composite face image). Defaults to three times of the face width.\n    lineclr : int tuple\n        the color of the line. Defaults to (255,255,255), i.e., white.\n    showcue : bool\n        whether to display cue in the image. Defaults to False.\n    cueclr : int tuple\n        the color of the cue. Defaults to the same as lineclr.\n    cuethick : int\n        the thickness (in pixels) of the cue. Defaults to 4.\n    cuew : int\n        the width (in pixels) of the cue. Defaults to 110% of the face width.\n    cueh : int\n        the height (in pixels) of the very left and right parts of the cue. Defaults to about 5% of the face height.\n    cuedist : int\n        distance from the main part of the cue to edge of the face. Defaults to twice of cueh.\n\n    Returns\n    -------\n    A dictionary of im.image() instance\n        the composite face stimuli as a im.image() instance.\n    \"\"\"\n\n    # make sure the dictionary is flatten\n    if len(set([im.group for im in imdict.values()])) &gt; 1 and bool(sep):\n        imdict_nested = _nested(imdict, sep=sep)\n\n        cfdict_nested = {}\n        for k,v in imdict_nested.items():\n            cfdict_nested[k] = _mkcfs(v, **kwargs)\n\n        cfdict = _flatten(cfdict_nested, sep=sep)\n\n    else:\n        cfdict = _mkcfs(imdict, **kwargs)\n\n    return cfdict\n</code></pre>"},{"location":"api/api/#pyfaceimage.mkphasescr","title":"<code>mkphasescr(imdict, **kwargs)</code>","text":"<p>Make phase scrambled stimuli.</p> <p>Parameters:</p> Name Type Description Default <code>imdict</code> <code>dict</code> <p>A dictionary of image() instances.</p> required <p>Other Parameters:</p> Name Type Description <code>rms</code> <code>float</code> <p>the desired RMS of the image. Defaults to 0.3.</p> Source code in <code>pyfaceimage/__init__.py</code> <pre><code>def mkphasescr(imdict, **kwargs):\n    \"\"\"Make phase scrambled stimuli.\n\n    Parameters\n    ----------\n    imdict : dict\n        A dictionary of image() instances.\n\n    Other Parameters\n    ----------------\n    rms : float\n        the desired RMS of the image. Defaults to 0.3.\n    \"\"\"\n    [v.mkphasescr(**kwargs) for v in imdict.values()]\n</code></pre>"},{"location":"api/api/#pyfaceimage.pad","title":"<code>pad(imdict, **kwargs)</code>","text":"<p>Add padding to the image/stimuli.</p> <p>Parameters:</p> Name Type Description Default <code>imdict</code> <code>dict</code> <p>A dictionary of image() instances.</p> required <p>Other Parameters:</p> Name Type Description <code>trgw</code> <code>int</code> <p>the width of the target/desired stimuli.</p> <code>trgh</code> <code>int</code> <p>the height of the target/desired stimuli.</p> <code>padvalue</code> <code>int</code> <p>padding value. Defaults to 0 (show as transparent if alpha channel exists).</p> <code>top</code> <code>bool</code> <p>padding more to top if needed. Defaults to True.</p> <code>left</code> <code>bool</code> <p>padding more to left if needed. Defaults to True.</p> <code>padalpha</code> <code>int</code> <p>the transparent color. Defaults to -1, i.e., not to force it to transparent.</p> <code>extrafn</code> <code>str</code> <p>the string to be added to the filename. Defaults to '_pad'.</p> Source code in <code>pyfaceimage/__init__.py</code> <pre><code>def pad(imdict, **kwargs):\n    \"\"\"\n    Add padding to the image/stimuli.\n\n    Parameters\n    ----------\n    imdict : dict\n        A dictionary of image() instances.\n\n    Other Parameters\n    ----------------\n    trgw : int\n        the width of the target/desired stimuli. \n    trgh : int\n        the height of the target/desired stimuli.\n    padvalue : int\n        padding value. Defaults to 0 (show as transparent if alpha channel exists).\n    top : bool\n        padding more to top if needed. Defaults to True.\n    left : bool\n        padding more to left if needed. Defaults to True.\n    padalpha : int\n        the transparent color. Defaults to -1, i.e., not to force it to transparent.\n    extrafn : str\n        the string to be added to the filename. Defaults to '_pad'.\n    \"\"\"\n    [v.pad(**kwargs) for v in imdict.values()]\n</code></pre>"},{"location":"api/api/#pyfaceimage.radial_gaussian","title":"<code>radial_gaussian(imsize=256, opaque=0.5, kernal=10)</code>","text":"<p>Make a radial gaussian mask ('L') image (with some opaque region).</p> <p>Parameters:</p> Name Type Description Default <code>imsize</code> <code>int tuple, optional. </code> <p>Image size (width, height). {imsize} will be used as both width and height if only one value is given. Default to 256.</p> <code>256</code> <code>opaque</code> <code>float, optional. </code> <p>Ratio of the regions to be \"opaqued\". Larger value means larger opaque region (from center to periphery). Default to .5.</p> <code>0.5</code> <code>kernal</code> <code>int</code> <p>kernal for the gaussian filter, by default 10</p> <code>10</code> <p>Returns:</p> Type Description <code>PIL.Image instance</code> <p>A PIL.Image instance of the radial gaussian mask.</p> Source code in <code>pyfaceimage/utilities.py</code> <pre><code>def radial_gaussian(imsize=256, opaque=.5, kernal=10):\n    \"\"\"Make a radial gaussian mask ('L') image (with some opaque region).\n\n    Parameters\n    ----------\n    imsize : int tuple, optional. \n        Image size (width, height). {imsize} will be used as both width and height if only one value is given. Default to 256.\n    opaque : float, optional. \n        Ratio of the regions to be \"opaqued\". Larger value means larger opaque region (from center to periphery). Default to .5.\n    kernal : int, optional\n        kernal for the gaussian filter, by default 10\n\n    Returns\n    -------\n    PIL.Image instance\n        A PIL.Image instance of the radial gaussian mask.\n    \"\"\"    \n\n    # make circle if imsize is not tuple\n    if type(imsize) is not tuple or len(imsize) == 1:\n        imsize = (imsize, imsize) # a and b in ellipse formula\n\n    # set the opaque area (roughly)\n    if type(opaque) is not tuple or len(opaque) == 1:\n        opaque = (opaque, opaque)\n    if not isinstance(opaque, int):\n        opaque = (int(opaque[0] * imsize[0]), int(opaque[1] * imsize[1]))\n\n    # make a 'L' mask in PIL\n    mask_im = Image.new('L', imsize, 0)\n    draw = ImageDraw.Draw(mask_im)\n    centeroval = (int(imsize[0]/2-opaque[0]/2), int(imsize[1]/2-opaque[0]/2),\n                  int(imsize[0]/2+opaque[0]/2), int(imsize[1]/2+opaque[0]/2))\n    draw.ellipse(centeroval, fill=255)\n    # apply gaussian blur\n    mask_im_blur = mask_im.filter(ImageFilter.GaussianBlur(kernal))\n\n    return mask_im_blur\n</code></pre>"},{"location":"api/api/#pyfaceimage.read","title":"<code>read(imdict)</code>","text":"<p>read the images if read was False in dir()</p> <p>Parameters:</p> Name Type Description Default <code>imdict</code> <code>dict</code> <p>A dictionary of image() instances.</p> required Source code in <code>pyfaceimage/__init__.py</code> <pre><code>def read(imdict):\n    \"\"\"read the images if read was False in dir()\n\n    Parameters\n    ----------\n    imdict : dict\n        A dictionary of image() instances.\n    \"\"\"\n    [v.read() for v in imdict.values()]\n</code></pre>"},{"location":"api/api/#pyfaceimage.resize","title":"<code>resize(imdict, **kwargs)</code>","text":"<p>Resize the image.</p> <p>Parameters:</p> Name Type Description Default <code>imdict</code> <code>dict</code> <p>A dictionary of image() instances.</p> required <p>Other Parameters:</p> Name Type Description <code>trgw</code> <code>int</code> <p>the width of the target/desired stimuli.</p> <code>trgh</code> <code>int</code> <p>the height of the target/desired stimuli.</p> <code>ratio</code> <code>float</code> <p>the ratio to resize the image. Defaults to 0.</p> <code>newfolder</code> <code>str</code> <p>the folder to save the resized image. Defaults to None.</p> Source code in <code>pyfaceimage/__init__.py</code> <pre><code>def resize(imdict, **kwargs):\n    \"\"\"Resize the image.\n\n    Parameters\n    ----------\n    imdict : dict\n        A dictionary of image() instances.\n\n    Other Parameters\n    ----------------\n    trgw : int\n        the width of the target/desired stimuli.\n    trgh : int\n        the height of the target/desired stimuli.\n    ratio : float\n        the ratio to resize the image. Defaults to 0.\n    newfolder : str\n        the folder to save the resized image. Defaults to None.\n    \"\"\"\n    [v.resize(**kwargs) for v in imdict.values()]\n</code></pre>"},{"location":"api/api/#pyfaceimage.rotate","title":"<code>rotate(imdict, **kwargs)</code>","text":"<p>Rotate the image unclockwise.</p> <p>Parameters:</p> Name Type Description Default <code>imdict</code> <code>dict</code> <p>A dictionary of image() instances.</p> required <p>Other Parameters:</p> Name Type Description <code>angle</code> <code>float</code> <p>the angle to rotate the image. Defaults to 180.</p> Source code in <code>pyfaceimage/__init__.py</code> <pre><code>def rotate(imdict, **kwargs):\n    \"\"\"Rotate the image unclockwise.\n\n    Parameters\n    ----------\n    imdict : dict\n        A dictionary of image() instances.\n\n    Other Parameters\n    -----------------\n    angle : float\n        the angle to rotate the image. Defaults to 180.\n    \"\"\"\n    [v.rotate(**kwargs) for v in imdict.values()]\n</code></pre>"},{"location":"api/api/#pyfaceimage.sample","title":"<code>sample(imdict, n=1, valueonly=True)</code>","text":"<p>Randomly sample n images from the dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>imdict</code> <code>dict</code> <p>A dictionary of image() instances.</p> required <code>n</code> <code>int</code> <p>number of images to be sampled, by default 1</p> <code>1</code> <code>valueonly</code> <code>bool</code> <p>whether return the value (i.e., the image instance only), by default True. If False, the key-value pair will be returned.</p> <code>True</code> <p>Returns:</p> Type Description <code>instance or list of tuples</code> <p>randomly sampled value or key-value pair.</p> Source code in <code>pyfaceimage/__init__.py</code> <pre><code>def sample(imdict, n=1, valueonly=True):\n    \"\"\"Randomly sample n images from the dictionary.\n\n    Parameters\n    ----------\n    imdict : dict\n        A dictionary of image() instances.\n    n : int, optional\n        number of images to be sampled, by default 1\n    valueonly : bool, optional\n        whether return the value (i.e., the image instance only), by default True. If False, the key-value pair will be returned.\n\n    Returns\n    -------\n    instance or list of tuples\n        randomly sampled value or key-value pair.\n    \"\"\"\n\n    # make sure the dictionary is flatten\n    if not _isflatten(imdict):\n        imdict = _flatten(imdict)\n\n    # random select one image from dictionary to check the output\n    assert n&lt;=len(imdict)\n    samples = random.sample(sorted(imdict.items()), n)\n\n    if valueonly:\n        # return the value (i.e., the image instance only)\n        out = [v[1] for v in samples]\n        if n==1:\n            out = out[0]\n    else:\n        # return the key-value pair/tuple\n        out = samples\n\n    return out\n</code></pre>"},{"location":"api/api/#pyfaceimage.save","title":"<code>save(imdict, **kwargs)</code>","text":"<p>Save the image PIL.</p> <p>Parameters:</p> Name Type Description Default <code>imdict</code> <code>dict</code> <p>A dictionary of image() instances.</p> required <p>Other Parameters:</p> Name Type Description <code>newfname</code> <code>str</code> <pre><code>strings to be added before the extension, by default ''\n</code></pre> <code>newfolder</code> <code>str</code> <pre><code>folder name to replace the global directory or the last directory level, by default ''\n</code></pre> <code>addfn</code> <code>bool</code> <pre><code>whether to add the newfname to the the original fname (instead of replacing it), by default True\n</code></pre> Source code in <code>pyfaceimage/__init__.py</code> <pre><code>def save(imdict, **kwargs):\n    \"\"\"Save the image PIL.\n\n    Parameters\n    ----------\n    imdict : dict\n        A dictionary of image() instances.\n\n    Other Parameters\n    ----------------\n    newfname : str\n            strings to be added before the extension, by default ''\n    newfolder : str\n            folder name to replace the global directory or the last directory level, by default ''\n    addfn : bool\n            whether to add the newfname to the the original fname (instead of replacing it), by default True\n    \"\"\"\n    [v.save(**kwargs) for v in imdict.values()]\n</code></pre>"},{"location":"api/api/#pyfaceimage.sffilter","title":"<code>sffilter(imdict, **kwargs)</code>","text":"<p>Apply spatial frequency filter to the image.</p> <p>Parameters:</p> Name Type Description Default <code>imdict</code> <code>dict</code> <p>A dictionary of image() instances.</p> required <p>Other Parameters:</p> Name Type Description <code>rms</code> <code>float</code> <p>the desired RMS of the image. Defaults to 0.3.</p> <code>maxvalue</code> <code>int</code> <p>the maximum value of the image. Defaults to 255.</p> <code>sffilter</code> <code>str</code> <p>the spatial frequency filter. Defaults to 'low'.</p> <code>cutoff</code> <code>float</code> <p>the cutoff frequency. Defaults to 0.05.</p> <code>n</code> <code>int</code> <p>the order of the filter. Defaults to 10.</p> Source code in <code>pyfaceimage/__init__.py</code> <pre><code>def sffilter(imdict, **kwargs):\n    \"\"\"Apply spatial frequency filter to the image.\n\n    Parameters\n    ----------\n    imdict : dict\n        A dictionary of image() instances.\n\n    Other Parameters\n    ----------------\n    rms : float\n        the desired RMS of the image. Defaults to 0.3.\n    maxvalue : int\n        the maximum value of the image. Defaults to 255.\n    sffilter : str\n        the spatial frequency filter. Defaults to 'low'.\n    cutoff : float\n        the cutoff frequency. Defaults to 0.05.\n    n : int\n        the order of the filter. Defaults to 10.\n    \"\"\"\n    [v.sffilter(**kwargs) for v in imdict.values()]\n</code></pre>"},{"location":"api/api/#pyfaceimage.torgba","title":"<code>torgba(imdict, **kwargs)</code>","text":"<p>Convert the image to RGBA.</p> <p>Parameters:</p> Name Type Description Default <code>imdict</code> <code>dict</code> <p>A dictionary of image() instances.</p> required Source code in <code>pyfaceimage/__init__.py</code> <pre><code>def torgba(imdict, **kwargs):\n    \"\"\"Convert the image to RGBA.\n\n    Parameters\n    ----------\n    imdict : dict\n        A dictionary of image() instances.\n    \"\"\"\n    [v.torgba(**kwargs) for v in imdict.values()]\n</code></pre>"},{"location":"api/api/#pyfaceimage.touch","title":"<code>touch(path, touchfolder='touch')</code>","text":"<p>Touch empty files for the directory.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str or dict</code> <p>path to be touched. A dictionary of image() instances.</p> required <code>touchfolder</code> <code>str</code> <p>the new folder name for saving the empty files.</p> <code>'touch'</code> Source code in <code>pyfaceimage/__init__.py</code> <pre><code>def touch(path, touchfolder=\"touch\"):\n    \"\"\"Touch empty files for the directory.\n\n    Parameters\n    ----------\n    path : str or dict\n        path to be touched.\n        A dictionary of image() instances.\n    touchfolder : str, optional\n        the new folder name for saving the empty files.\n    \"\"\"\n    # if path is not a dictionary, it will be treated as a path\n    if not isinstance(path, dict):\n        imdict = dir(path=path)\n    else:\n        imdict = path\n\n    # make sure the dictionary is flatten\n    if not _isflatten(imdict):\n        imdict = _flatten(imdict)\n\n    # touch the directory\n    [v.touch(touchfolder) for v in imdict.values()]\n</code></pre>"},{"location":"api/api/#pyfaceimage.updateext","title":"<code>updateext(imdict, **kwargs)</code>","text":"<p>Update the filename information.</p> <p>Parameters:</p> Name Type Description Default <code>imdict</code> <code>dict</code> <p>A dictionary of image() instances.</p> required <p>Other Parameters:</p> Name Type Description <code>ext</code> <code>str</code> <p>the new extension.</p> Source code in <code>pyfaceimage/__init__.py</code> <pre><code>def updateext(imdict, **kwargs):\n    \"\"\"Update the filename information.\n\n    Parameters\n    ----------\n    imdict : dict\n        A dictionary of image() instances.\n\n    Other Parameters\n    ----------------\n    ext : str\n        the new extension.\n    \"\"\"\n    [v.updateext(**kwargs) for v in imdict.values()]\n</code></pre>"},{"location":"api/class/","title":"class","text":"<p>Auto-generate API documentation using <code>mkdocstrings</code>. Add the following content:</p>"},{"location":"api/class/#api-reference","title":"API Reference","text":"<p>A class to process a single image.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>path and image filename.</p> required <code>read</code> <code>bool</code> <p>Whether to read the image via PIL, by default False.</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>filename</code> <code>str</code> <p>path and image filename.</p> <code>fname</code> <code>str</code> <p>the image filename.</p> <code>fnonly</code> <code>str</code> <p>the image filename without extension.</p> <code>ext</code> <code>str</code> <p>the image extension.</p> <code>dirname</code> <code>str</code> <p>the image directory.</p> <code>isfile</code> <code>bool</code> <p>whether the image file exists.</p> <code>group</code> <code>str</code> <p>the group name of the image.</p> <code>gpath</code> <code>str</code> <p>the global path of the image.</p> <code>pil</code> <code>Image</code> <p>the PIL image.</p> <code>mat</code> <code>array</code> <p>the image matrix.</p> <code>dims</code> <code>tuple</code> <p>the image dimensions.</p> <code>ndim</code> <code>int</code> <p>the number of dimensions.</p> <code>h</code> <code>int</code> <p>the height of the image.</p> <code>w</code> <code>int</code> <p>the width of the image.</p> <code>nchan</code> <code>int</code> <p>the number of channels.</p> <code>rgbmat</code> <code>array</code> <p>the RGB matrix.</p> <code>amat</code> <code>array</code> <p>the alpha matrix.</p> <p>Methods:</p> Name Description <code>updateext</code> <p>Update the filename information.</p> <code>read</code> <p>Read the image via PIL.</p> <code>imshow</code> <p>Show the image matrix.</p> <code>show</code> <p>Show the image PIL.</p> <code>imsave</code> <p>Save the image mat.</p> <code>save</code> <p>Save the image PIL.</p> <code>deepcopy</code> <p>Make a deep copy of the instance.</p> <code>remat</code> <p>Re-assign value to .mat and update related information.</p> <code>torgba</code> <p>Convert the image to RGBA.</p> <code>grayscale</code> <p>Convert the image to gray-scale.</p> <code>rotate</code> <p>Rotate the image unclockwise.</p> <code>adjust</code> <p>Adjust the luminance and contrast of the image.</p> <code>cropoval</code> <p>Crop the image with an oval shape.</p> <code>croprect</code> <p>Crop the image with a rectangle box.</p> <code>resize</code> <p>Resize the image.</p> <code>pad</code> <p>Add padding to the image/stimuli.</p> <code>mkboxscr</code> <p>Make box scrambled stimuli.</p> <code>mkphasescr</code> <p>Make phase scrambled stimuli.</p> <code>sffilter</code> <p>Apply spatial frequency filter to the image.</p> <code>_logit</code> <p>Convert the ratio to log odds.</p> <code>_sigmoid</code> <p>Convert the log odds to the ratio.</p> <code>_repil</code> <p>Update the image PIL.</p> <code>_updatefrommat</code> <p>Update information from the image matrix.</p> <code>_newfilename</code> <p>Update the filename with newfname and newfolder.</p> <code>_updatefromfilename</code> <p>Update information from the filename.</p> <code>_setgroup</code> <p>Set the group name of the image.</p> <code>_setgpath</code> <p>Set the global path of the image.</p> <code>_stdim</code> <p>Standardize the image.</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>class image:\n    \"\"\"A class to process a single image.\n\n    Parameters\n    ----------\n    filename : str\n        path and image filename.  \n    read : bool, optional\n        Whether to read the image via PIL, by default False.\n\n    Attributes\n    ----------\n    filename : str\n        path and image filename.\n    fname : str\n        the image filename.\n    fnonly : str\n        the image filename without extension.\n    ext : str\n        the image extension.\n    dirname : str\n        the image directory.\n    isfile : bool\n        whether the image file exists.\n    group : str\n        the group name of the image.\n    gpath : str\n        the global path of the image.\n    pil : PIL.Image\n        the PIL image.\n    mat : np.array\n        the image matrix.\n    dims : tuple\n        the image dimensions.\n    ndim : int\n        the number of dimensions.\n    h : int\n        the height of the image.\n    w : int\n        the width of the image.\n    nchan : int\n        the number of channels.\n    rgbmat : np.array\n        the RGB matrix.\n    amat : np.array\n        the alpha matrix.\n\n    Methods\n    -------\n    updateext(ext)\n        Update the filename information.\n    read()\n        Read the image via PIL.\n    imshow()\n        Show the image matrix.\n    show()\n        Show the image PIL.\n    imsave(newfname='', newfolder='', addfn=True, **kwargs)\n        Save the image mat.\n    save(newfname='', newfolder='', addfn=True, **kwargs)\n        Save the image PIL.\n    deepcopy()\n        Make a deep copy of the instance.\n    remat(mat)\n        Re-assign value to .mat and update related information.\n    torgba()\n        Convert the image to RGBA.\n    grayscale()\n        Convert the image to gray-scale.\n    rotate(angle=180)\n        Rotate the image unclockwise.\n    adjust(lum=None, rms=None, mask=None)\n        Adjust the luminance and contrast of the image.\n    cropoval(radius=(100,128), bgcolor=None)\n        Crop the image with an oval shape.\n    croprect(box=None)\n        Crop the image with a rectangle box.\n    resize(**kwargs)\n        Resize the image.\n    pad(**kwargs)\n        Add padding to the image/stimuli.\n    mkboxscr(**kwargs)\n        Make box scrambled stimuli.\n    mkphasescr(**kwargs)\n        Make phase scrambled stimuli.\n    sffilter(**kwargs)\n        Apply spatial frequency filter to the image.\n    _logit(ratio=None, correction=0.00001)\n        Convert the ratio to log odds.\n    _sigmoid(logodds, correction=0.00001)\n        Convert the log odds to the ratio.\n    _repil(pil)\n        Update the image PIL.\n    _updatefrommat()\n        Update information from the image matrix.\n    _newfilename(newfname='', newfolder='', addfn=True)\n        Update the filename with newfname and newfolder.\n    _updatefromfilename()\n        Update information from the filename.\n    _setgroup(gname='')\n        Set the group name of the image.\n    _setgpath(gpath='')\n        Set the global path of the image.\n    _stdim(mat, rms=0.3)\n        Standardize the image.\n    \"\"\"\n    def __init__(self, filename, read=False):\n        \"\"\"Create an image instance.\n\n        Parameters\n        ----------\n        filename : str\n            path and image filename.  \n        read : bool, optional\n            Whether to read the image via PIL, by default False.\n\n        Raises\n        ------\n        AssertionError\n            If the file does not exist.\n        \"\"\"\n        # make sure the file exists \n        assert os.path.isfile(filename) | (not bool(filename)), f'Cannot find {filename}...'\n        self.filename = filename\n        self._updatefromfilename() # update filename information\n        self._setgroup() \n        self._setgpath()\n        if read: self.read()\n\n    def _updatefromfilename(self):\n        \"\"\"Update information from the filename.\n        \"\"\"\n        self.fname = os.path.basename(self.filename)\n        self.fnonly = \".\".join(os.path.splitext(self.fname)[0:-1])\n        self.ext = os.path.splitext(self.fname)[-1]\n        self.dirname = os.path.dirname(self.filename)\n        self.isfile = os.path.isfile(self.filename)\n\n    def updateext(self, ext):\n        \"\"\"Update the filename information.\n\n        Parameters\n        ----------\n        ext : str\n            the new extension.\n        \"\"\"\n        if ext[0] != '.':\n            ext = '.'+ext\n        self.filename = self.dirname + os.sep + self.fnonly + ext\n        self._updatefromfilename()\n\n    def read(self):\n        \"\"\"Read the image via PIL.\n        \"\"\"\n        self._repil(Image.open(self.filename)) # PIL.Image.open() \n        # potential useful functions\n        # .filename .format, .mode, .split()\n\n    def _setgroup(self, gname=''):\n        \"\"\"Set the group name of the image.\n\n        Parameters\n        ----------\n        gname : str, optional\n            the group name, by default the upper directory name of the image.\n        \"\"\"\n        # update group information\n        if not bool(gname):\n            gname = os.path.split(os.path.dirname(self.filename))[1]\n        self.group = gname\n\n    def _setgpath(self, gpath=''):\n        \"\"\"Set the global path of the image (among other images). [This atribute matters only when mutiltple images are processed together. more see dir().]\n\n        Parameters\n        ----------\n        gpath : str, optional\n            global path, i.e. path in dir(), by default ''\n        \"\"\"\n        self.gpath = gpath\n\n    def imshow(self):\n        \"\"\"Show the image matrix.\n        \"\"\"\n        # for debugging purpose (check the mat)\n        # it seems that .show() is more useful\n        Image.fromarray(self.mat).show()\n\n    def show(self):\n        \"\"\"Show the image PIL.\n        \"\"\"\n        # for debugging purpose (check the PIL)\n        self.pil.show()\n\n    def imsave(self, newfname='', newfolder='', addfn=True, **kwargs):\n        \"\"\"Save the image mat.\n\n        Parameters\n        ----------\n        newfname : str, optional\n            strings to be added before the extension, by default ''\n        newfolder : str, optional\n            folder name to replace the global directory or the last directory level, by default ''\n        addfn : bool, optional\n            whether to add the newfname to the the original fname (instead of replacing it), by default True\n        kwargs : dict, optional\n            keyword arguments for matplotlib.pyplot.imsave(), by default {}\n        \"\"\"\n        # update the filename\n        self._newfilename(newfname, newfolder, addfn=addfn)\n\n        # make dir(s)\n        if not os.path.isdir(os.path.dirname(self.filename)):\n            os.makedirs(os.path.dirname(self.filename))\n        if self.nchan==1:\n            outmat = self.mat[:,:,0]\n        else:\n            outmat = self.mat\n\n        # use matplotlib.pyplot.imsave() to save .mat\n        mpimg.imsave(self.filename,outmat.copy(order='C'),**kwargs)\n        self.isfile = os.path.isfile(self.filename)\n\n\n    def save(self, newfname='', newfolder='', addfn=True, **kwargs):\n        \"\"\"Save the image PIL.\n\n        Parameters\n        ----------\n        newfname : str, optional\n            strings to be added before the extension, by default ''\n        newfolder : str, optional\n            folder name to replace the global directory or the last directory level, by default ''\n        addfn : bool, optional\n            whether to add the newfname to the the original fname (instead of replacing it), by default True\n        kwargs : dict, optional\n            keyword arguments for matplotlib.pyplot.imsave(), by default {}\n        \"\"\"\n        # update the filename\n        self._newfilename(newfname, newfolder, addfn=addfn)\n\n        # make dir(s)\n        if not os.path.isdir(os.path.dirname(self.filename)):\n            os.makedirs(os.path.dirname(self.filename))\n\n        # use PIL.Image.save() to save .pil    \n        self.pil.save(self.filename, format=None, **kwargs)\n        self.isfile = os.path.isfile(self.filename)\n\n\n    def touch(self, touchfolder=''):\n        \"\"\"Touch a new empty file.\n\n        Parameters\n        ----------\n        touchfolder : str, optional\n            folder name to replace the global directory or the last directory level, by default ''\n        \"\"\"\n        # update the directory\n        self._newfilename(newfolder=touchfolder)\n\n        if self.isfile:\n            # throw warnings if file exists\n            warnings.warn(\"The file named '%s' already exists...\" % self.filename)\n        else:\n            # make dir if needed\n            if not os.path.isdir(self.dirname):\n                os.makedirs(self.dirname)\n            # touch the file\n            Path(self.filename).touch()\n\n\n    def _newfilename(self, newfname='', newfolder='', addfn=True):\n        \"\"\"Update the filename with newfname and newfolder.\n\n        Parameters\n        ----------\n        newfname : str, optional\n            strings to be added before the extension, by default ''\n        newfolder : str, optional\n            folder name to replace the global directory or the last directory level, by default ''\n        addfn : bool, optional\n            whether to add the newfname to the the original fname (instead of replacing it), by default True\n        \"\"\"\n        # apply newfname to the old one\n        oldfname = os.path.splitext(self.fname)[0] if addfn else ''\n        fname = oldfname+newfname+os.path.splitext(self.fname)[1]\n\n        # replace the path folder with newfolder\n        if bool(self.gpath):\n            # rename the global path and filename\n            foldername = newfolder if bool(newfolder) else os.path.basename(self.gpath) # apply newfolder to the old one if needed\n            group = self.group if self.group != 'path' else ''\n            self.filename = os.path.join(os.path.dirname(self.gpath), foldername, group, fname)\n            self.gpath = os.path.join(os.path.dirname(self.gpath), foldername)\n        else:\n            foldername = newfolder if bool(newfolder) else os.path.basename(self.dirname) # apply newfolder to the old one if needed\n            self.filename = os.path.join(os.path.dirname(self.filename), foldername, fname)\n\n        self._updatefromfilename()\n        if self.isfile:\n            warnings.warn(\"The file named '%s' already exists...\" % {self.filename})\n\n    def deepcopy(self):\n        \"\"\"make a deep copy of the instance\n        \"\"\"\n        return copy.deepcopy(self)\n\n    def remat(self, mat):\n        # re-assign value to .mat and update related information\n        self.mat = mat\n        self.pil = Image.fromarray(mat)\n        self._updatefrommat()\n\n    def _repil(self, pil):\n        self.pil = pil\n        self.mat = np.asarray(self.pil)\n        self._updatefrommat()\n\n    def _updatefrommat(self):\n        self.dims = self.mat.shape\n        self.ndim = len(self.dims)\n        if self.ndim==2:\n            self.h, self.w = self.dims\n            self.nchan = 0\n        elif self.ndim==3:\n            self.h, self.w, self.nchan = self.dims\n\n    def torgba(self):\n        \"\"\"Convert the image to RGBA.\n        \"\"\"\n        # convert pil to RGBA and save in .mat\n        if len(self.mat.shape)==2: # Gray\n            self.mat = self.mat[..., np.newaxis]\n        assert len(self.mat.shape)==3\n\n        nchan = self.mat.shape[2]\n        if nchan==1: # Gray 'L'\n            rgbmat = np.repeat(self.mat, 3, axis=2) # RGB\n            amat = np.ones_like(rgbmat[:,:,0],dtype=np.uint8)*rgbmat.max() # alpha\n        elif nchan==2: # Gray 'LA'\n            rgbmat = np.repeat(self.mat[:,:,0:1], 3, axis=2) # RGB\n            amat = self.mat[:,:,-1] # alpha\n        elif nchan==3: # RGB\n            rgbmat = self.mat # RGB\n            amat = np.ones_like(rgbmat[:,:,0],dtype=np.uint8)*rgbmat.max() # alpha\n        elif nchan==4: # RGBA\n            rgbmat = self.mat[:,:,0:3]\n            amat = self.mat[:,:,-1]\n\n        self.rgbmat = rgbmat\n        self.amat = amat\n        self.mat = np.concatenate((rgbmat, amat[..., np.newaxis]), axis=2) # RGBA\n        self.remat(self.mat)\n\n    def grayscale(self):\n        \"\"\"Convert the image to gray-scale.\n        \"\"\"\n        # convert image to gray-scale\n        self._repil(ImageOps.grayscale(self.pil))\n\n    def _logit(self, ratio=None, correction=0.00001):\n        \"\"\"Convert the ratio to log odds.\n\n        Parameters\n        ----------\n        ratio : np.array, optional\n            the ratio of the image. Defaults to None.\n        correction : float, optional\n            the correction value. Defaults to 0.00001.\n\n        Returns\n        -------\n        np.array\n            the log odds of the image.\n        \"\"\"\n\n        if ratio is None:\n            self.grayscale()\n            ratio = self.mat/255\n        elif type(ratio) is not np.ndarray:\n            ratio = np.array(ratio)\n\n        ratio[ratio==1] = (255-correction)/255\n        ratio[ratio==0] = correction/255\n\n        return np.log(ratio/(1-ratio))\n\n    def _sigmoid(self, logodds, correction=0.00001):\n\n        ratio = np.exp(logodds)/(np.exp(logodds)+1)\n        ratio[ratio&gt;=(1-correction)] = 1\n        ratio[ratio&lt;=(correction)] = 0\n\n        gray = ratio * 255\n\n        return gray.astype(dtype=np.uint8)\n\n    def rotate(self, angle=180):\n        \"\"\"Rotate the image unclockwise.\n\n        Parameters\n        ----------\n        angle : float\n            the angle to rotate the image. Defaults to 180.\n        \"\"\"\n        # rotate the image\n        self._repil(self.pil.rotate(angle))\n\n    def adjust(self, lum=None, rms=None, mask=None):\n        \"\"\"Adjust the luminance and contrast of the image.\n\n        Parameters\n        ----------\n        lum : float, optional\n            the desired mean of the image. Defaults to None.\n        rms : float, optional\n            the desired standard deviation of the image. Defaults to None.\n        mask : np.array, optional\n            the mask for the image. Defaults to None.\n        \"\"\"\n        # adjust the luminance (mean) or/and contrast (standard deviations) of the gray-scaled image. Default is do nothing.\n\n        # default for mask\n        if self.nchan in (2,4):\n            alpha = self.mat[...,-1]\n            isalpha = True\n        else:\n            alpha = np.ones((self.h, self.w))*255\n            isalpha = False\n        if mask is None:\n            mask = (alpha/255).astype(dtype=bool)\n\n        # force the image to be gray-scaled\n        self.grayscale()\n        ratio = self.mat/255\n        logodds = self._logit(ratio)\n\n        # in ratio\n        rmsratio = np.std(ratio[mask]-np.mean(ratio[mask]))\n\n        # in log odds\n        meanlo = np.mean(logodds[mask])\n        stdlo = np.std(logodds[mask]-meanlo)\n\n        if lum is not None:\n            lumlo = self._logit(lum)\n        else:\n            lumlo = meanlo\n\n        if rms is not None:\n            rmslo = rms * stdlo / rmsratio\n        else:\n            rmslo = stdlo\n\n        newlo = logodds\n        # apply the new luminance (in logodds)\n        newlo[mask] = (logodds[mask] - meanlo)/stdlo * rmslo + lumlo\n        newmat = self._sigmoid(newlo)\n\n        if isalpha:\n            newmat = np.concatenate((newmat[...,np.newaxis], alpha[...,np.newaxis]), axis=2)\n\n        self.remat(newmat.astype(dtype=np.uint8))\n\n\n    def cropoval(self, radius=(100,128), bgcolor=None):\n        \"\"\"Crop the image with an oval shape.\n\n        Parameters\n        ----------\n        radius : tuple, optional\n            the radius of the oval. Defaults to (100,128).\n        bgcolor : tuple, optional\n            the background color. Defaults to None.\n        \"\"\"\n\n        # for instance, if bgcolor is (255, 255, 255, 255), the output image is not transparent; if bgcolor is (255, 255, 255, 0), the output image is transparent\n\n        # to make circle\n        if type(radius) is not tuple:\n            radius = (radius, radius) # a and b in ellipse formula\n        bbox = (self.w/2-radius[0], self.h/2-radius[1], self.w/2+radius[0], self.h/2+radius[1])\n\n        # make a ellipse/oval mask\n        pil_a = Image.new(\"L\", self.pil.size, 0)\n        draw = ImageDraw.Draw(pil_a)\n        draw.ellipse(bbox, fill=255)\n\n        if bgcolor is not None:\n            if type(bgcolor) is not tuple:\n                bgcolor = ((bgcolor),)*len(self.pil.mode)\n            pil_2 = Image.new(self.pil.mode, self.pil.size, bgcolor)\n            draw = ImageDraw.Draw(pil_2)\n            draw.ellipse(bbox, fill=255)\n            self.pil = Image.composite(self.pil, pil_2, pil_a)\n        else:\n            # only apply cropping to the alpha channel\n            self.pil.putalpha(pil_a)\n        # update to pil        \n        self._repil(self.pil)\n        # crop the rectangle\n        self.croprect(bbox)\n\n    def croprect(self, box=None):\n        \"\"\"Crop the image with a rectangle box.\n\n        Parameters\n        ----------\n        box : tuple, optional\n            the box to crop the image. Defaults to None.\n        \"\"\"\n        # crop the image with a rectangle box\n        self._repil(self.pil.crop(box))\n\n    def resize(self, **kwargs):\n        \"\"\"Resize the image.\n\n        Other Parameters\n        ----------------\n        trgw : int\n            the width of the target/desired stimuli.\n        trgh : int\n            the height of the target/desired stimuli.\n        ratio : float\n            the ratio to resize the image. Defaults to 0.\n        newfolder : str\n            the folder to save the resized image. Defaults to None.\n        \"\"\"\n        # resize the image\n        defaultKwargs = {'trgw': None, 'trgh': None, 'ratio':0, 'newfolder':None}\n        kwargs = {**defaultKwargs, **kwargs}\n\n        if (kwargs['trgw'] is not None) &amp; (kwargs['trgh'] is not None):\n            (w, h) = (kwargs['trgw'], kwargs['trgh'])\n        elif (kwargs['trgw'] is not None) &amp; (kwargs['trgh'] is None):\n            w = kwargs['trgw']\n            h = int(w*self.h/self.w)\n        elif (kwargs['trgw'] is None) &amp; (kwargs['trgh'] is not None): \n            h = kwargs['trgh']\n            w = int(h*self.w/self.h)\n        elif kwargs['ratio']&gt;0:\n            w = int(self.w*kwargs['ratio'])\n            h = int(self.h*kwargs['ratio'])\n        else:\n            raise 'Cannot determine the desired dimentions...'\n\n        kwargs['size'] = (w,h)\n        if (kwargs['newfolder'] is None):\n            newfolder = str(w)+'_'+str(h)\n        else:\n            newfolder = kwargs['newfolder']\n\n        [kwargs.pop(k) for k in defaultKwargs.keys()] # remove unused keys\n\n        # save re-sized images (information)\n        self._repil(self.pil.resize(**kwargs))\n        self._newfilename(newfolder=newfolder)\n\n    def pad(self, **kwargs):  \n        \"\"\"\n        Add padding to the image/stimuli.\n\n        Other Parameters\n        ----------------\n        trgw : int\n            the width of the target/desired stimuli. \n        trgh : int\n            the height of the target/desired stimuli.\n        padvalue : int\n            padding value. Defaults to 0 (show as transparent if alpha channel exists).\n        top : bool\n            padding more to top if needed. Defaults to True.\n        left : bool \n            padding more to left if needed. Defaults to True.\n        padalpha : int\n            the transparent color. Defaults to -1, i.e., not to force it to transparent.\n        extrafn : str\n            the string to be added to the filename. Defaults to '_pad'.\n        \"\"\"\n\n        defaultKwargs = {'trgw':self.w, 'trgh':self.h, 'padvalue': 0, 'top': True, 'left':True, 'padalpha':-1, 'extrafn':'_pad'}\n        kwargs = {**defaultKwargs, **kwargs}\n\n        trgw,trgh = kwargs['trgw'], kwargs['trgh']\n\n        assert(trgw&gt;=self.w)\n        assert(trgh&gt;=self.h)\n\n        x1 = int(np.ceil(trgw-self.w)/2)\n        x2 = trgw-self.w-x1\n        y1 = int(np.ceil(trgh-self.h)/2)\n        y2 = trgh-self.h-y1\n\n        if kwargs['top']:\n            htop, hbot = y1,y2\n        else:\n            htop, hbot = y2,y1\n        if kwargs['left']:\n            wleft, wright = x1,x2\n        else:\n            wleft, wright = x2,x1\n\n        if self.nchan==0:\n            nchan = 1\n            mat = self.mat[..., np.newaxis] # add one more axis\n        else:\n            nchan = self.nchan\n            mat = self.mat\n\n        if (kwargs['padalpha']&gt;=0) &amp; (nchan==1 | nchan==3):\n            mat = np.concatenate((mat, np.ones((self.h, self.w, 1), dtype=np.uint8)*kwargs['padalpha']),axis=2)\n            nchan = nchan + 1\n\n        padmat = np.hstack((\n            np.ones((trgh,wleft,nchan),dtype=np.uint8)*kwargs['padvalue'], \n            np.vstack((\n                np.ones((htop,self.w,nchan),dtype=np.uint8)*kwargs['padvalue'], \n                mat,\n                np.ones((hbot,self.w,nchan),dtype=np.uint8)*kwargs['padvalue']\n            )),\n            np.ones((trgh,wright,nchan),dtype=np.uint8)*kwargs['padvalue'], \n        ))\n\n        if (self.nchan==0) &amp; (kwargs['padalpha']&lt;0):\n            padmat = padmat[:,:,0]\n\n        self.remat(padmat)\n        if kwargs['extrafn']!='':\n            self._newfilename(newfname=kwargs['extrafn'])\n\n    def mkboxscr(self, **kwargs):\n        \"\"\"Make box scrambled stimuli.\n\n        Other Parameters\n        ----------------\n        nBoxW : int\n            the number of boxes in width. Defaults to 10.\n        nBoxH : int\n            the number of boxes in height. Defaults to 16.\n        pBoxW : int\n            the width of a box. Defaults to 0.\n        pBoxH : int\n            the height of a box. Defaults to 0.\n        pad : bool\n            whether to add padding to the image. Defaults to False.\n        padcolor : int\n            the padding color. Defaults to 0.\n        padalpha : int\n            the padding alpha. Defaults to -1.\n        \"\"\"\n        defaultKwargs = {'nBoxW':10, 'nBoxH':16, \n                     'pBoxW':0, 'pBoxH':0, \n                     'pad': False, 'padcolor':0, 'padalpha': -1}\n        kwargs = {**defaultKwargs, **kwargs}\n\n        if (kwargs['pBoxW']!=0) &amp; (kwargs['pBoxH']!=0):\n\n            _nBoxW = self.w/kwargs['pBoxW']\n            _nBoxH = self.h/kwargs['pBoxH']\n\n            if not ((_nBoxW.is_integer()) &amp; (_nBoxH.is_integer())):\n                assert kwargs['pad'], 'Please input valid pBoxW and pBoxH. Or set \"pad\" to True.'\n\n                # add complementary parts to top and right\n                xnew = int(np.ceil(_nBoxW) * kwargs['pBoxW'])\n                ynew = int(np.ceil(_nBoxH) * kwargs['pBoxH'])\n\n                self.pad(trgw=xnew, trgh=ynew, padvalue=kwargs['padcolor'], padalpha=kwargs['padalpha'])\n\n            kwargs['nBoxW'] = int(self.w/kwargs['pBoxW'])\n            kwargs['nBoxH'] = int(self.h/kwargs['pBoxH'])\n\n        elif (kwargs['nBoxW']!=0) &amp; (kwargs['nBoxH']!=0):\n\n            # x and y pixels for each box\n            _pBoxW = self.w/kwargs['nBoxW']\n            _pBoxH = self.h/kwargs['nBoxH']\n\n            if not ((_pBoxW.is_integer()) &amp; (_pBoxH.is_integer())):\n                assert kwargs['pad'], 'Please input valid nBoxW and nBoxH. Or set \"pad\" to True.'\n\n                # add padding (top, right, bottom, left)\n                newW = int(np.ceil(_pBoxW) * kwargs['nBoxW'])\n                newY = int(np.ceil(_pBoxH) * kwargs['nBoxH'])\n                self.pad(trgw=newW, trgh=newY, padvalue=kwargs['padcolor'], padalpha=kwargs['padalpha'])\n\n            kwargs['pBoxW'] = int(self.w/kwargs['nBoxW'])\n            kwargs['pBoxH'] = int(self.h/kwargs['nBoxH'])\n        else:\n            raise 'Please set valid nBoxW and nBoxH (or pBoxW and pBoxH).'\n\n        assert kwargs['nBoxW']*kwargs['pBoxW']==self.w, f\"'nBoxW': {kwargs['nBoxW']}   'pBoxW': {kwargs['pBoxW']}    'self.w': {self.w}\"\n        assert kwargs['nBoxH']*kwargs['pBoxH']==self.h, f\"'nBoxH': {kwargs['nBoxH']}   'pBoxH': {kwargs['pBoxH']}    'self.h': {self.h}\"\n\n        # x and y for all boxes\n        xys = list(product(range(0,self.w,kwargs['pBoxW']), range(0,self.h,kwargs['pBoxH'])))\n        boxes = [self.mat[i[1]:(i[1]+kwargs['pBoxH']), i[0]:(i[0]+kwargs['pBoxW'])] for i in xys]\n        # randomize the boxes\n        bsboxes = np.random.permutation(boxes)\n        # save as np.array\n        bslist = [bsboxes[i:i+kwargs['nBoxW']] for i in range(0,len(bsboxes),kwargs['nBoxW'])]\n        # bsmat = np.moveaxis(np.asarray(bslist), [-1, 1], [0, -2]).reshape(-1, y, x)\n        bsmatm = np.asarray(bslist)\n        if len(bsmatm.shape)==4:\n            bsmatm = bsmatm[..., np.newaxis]\n        bsmat = np.moveaxis(bsmatm, [-1, 1], [0, -2]).reshape(-1, self.h, self.w)\n\n        # save box-scrambled images (and information)\n        self.remat(np.squeeze(np.moveaxis(bsmat,0,2)))\n        self._newfilename(newfname='_bscr')\n\n    def mkphasescr(self, **kwargs):\n        \"\"\"Make phase scrambled stimuli.\n\n        Other Parameters\n        ----------------\n        rms : float\n            the desired RMS of the image. Defaults to 0.3.\n        \"\"\"\n        defaultKwargs = {'rms':0.3}\n        kwargs = {**defaultKwargs, **kwargs}\n\n        # make a random phase\n        randphase = np.angle(np.fft.fft2(np.random.rand(self.h, self.w)))\n\n        if self.nchan==0:\n            nchan = 1\n            mat = self.mat[..., np.newaxis] # add one more axis\n        else:\n            nchan = self.nchan\n            mat = self.mat\n\n        outmat = np.empty(mat.shape)\n        outmat[:] = np.NaN\n\n        for i in range(nchan):\n            img_freq = np.fft.fft2(self._stdim(mat[:,:,i], kwargs['rms']))\n            amp = np.abs(img_freq)\n            phase = np.angle(img_freq) + randphase\n            outimg = np.real(np.fft.ifft2(amp * np.exp(np.sqrt(-1+0j)*phase)))\n            stdimg1= self._stdim(outimg, kwargs['rms'])\n            outmat[:,:,i] = (stdimg1+1)/2*255\n\n        if self.nchan==0:\n            outmat = outmat[:,:,0]\n\n        self.remat(np.uint8(outmat))\n        self._newfilename(newfname='_pscr')\n\n    def sffilter(self, **kwargs):\n        \"\"\"Apply spatial frequency filter to the image.\n\n        Other Parameters\n        ----------------\n        rms : float\n            the desired RMS of the image. Defaults to 0.3.\n        maxvalue : int\n            the maximum value of the image. Defaults to 255.\n        sffilter : str\n            the spatial frequency filter. Defaults to 'low'.\n        cutoff : float\n            the cutoff frequency. Defaults to 0.05.\n        n : int\n            the order of the filter. Defaults to 10.\n        \"\"\"\n        # https://www.djmannion.net/psych_programming/vision/sf_filt/sf_filt.html\n        import psychopy.filters\n\n        defaultKwargs = {'rms':0.3, 'maxvalue':255, 'sffilter':'low',\n                         'cutoff': 0.05, 'n': 10}\n        kwargs = {**defaultKwargs, **kwargs}\n\n        self.grayscale()\n        stdmat = self._stdim(self.mat, kwargs['rms'])\n        img_freq = np.fft.fft2(stdmat)\n\n        # calculate amplitude spectrum\n        # img_amp = np.fft.fftshift(np.abs(img_freq))\n\n        # # for display, take the logarithm\n        # img_amp_disp = np.log(img_amp + 0.0001)\n\n        # # rescale to -1:+1 for display\n        # img_amp_disp = (\n        #     ((img_amp_disp - np.min(img_amp_disp)) * 2) / \n        #     np.ptp(img_amp_disp)  # 'ptp' = range\n        # ) - 1\n\n        if kwargs['sffilter']=='low':\n            # for generating blury images\n            fsfilt = psychopy.filters.butter2d_lp(\n                size=(self.w, self.h),\n                cutoff=kwargs['cutoff'],\n                n=kwargs['n']\n            )\n        elif kwargs['sffilter']=='high':      \n             # for gernerating sharp images\n            fsfilt = psychopy.filters.butter2d_hp(\n                size=(self.w, self.h),\n                cutoff=kwargs['cutoff'],\n                n=kwargs['n']\n            )\n        else:\n            raise 'Cannot identify the \"sffilter\" value...'\n\n        img_filt = np.fft.fftshift(img_freq) * fsfilt.transpose()\n        # convert back to an image\n        img_new = np.real(np.fft.ifft2(np.fft.ifftshift(img_filt)))\n        # standardize the image to [-1, 1]\n        img_new = self._stdim(img_new, kwargs['rms'])\n        # convert the range to [0, 255]\n        img_new = (img_new+1)/2*kwargs['maxvalue']\n        self.remat(img_new)\n        self._newfilename(newfname='_'+kwargs['sffilter']+'_filtered')\n\n    def _stdim(self, mat, rms=0.3):\n        \"\"\"Standardize the image.\n\n        Parameters\n        ----------\n        mat : np.array\n            the image matrix.\n        rms : float, optional\n            the desired RMS of the image. Defaults to 0.3.\n\n        Returns\n        -------\n        np.array\n            the standardized image matrix.\n        \"\"\"\n        # standardize the image (the range of output should be -1,1)\n        # make the standard deviation to be the desired RMS\n        mat = (mat - np.mean(mat))/np.std(mat) * rms\n\n        # there may be some stray values outside of the presentable range; convert &lt; -1\n        # to -1 and &gt; 1 to 1\n        mat = np.clip(mat, a_min=-1.0, a_max=1.0)\n        return mat\n</code></pre>"},{"location":"api/class/#pyfaceimage.im.image.__init__","title":"<code>__init__(filename, read=False)</code>","text":"<p>Create an image instance.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>path and image filename.</p> required <code>read</code> <code>bool</code> <p>Whether to read the image via PIL, by default False.</p> <code>False</code> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the file does not exist.</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>def __init__(self, filename, read=False):\n    \"\"\"Create an image instance.\n\n    Parameters\n    ----------\n    filename : str\n        path and image filename.  \n    read : bool, optional\n        Whether to read the image via PIL, by default False.\n\n    Raises\n    ------\n    AssertionError\n        If the file does not exist.\n    \"\"\"\n    # make sure the file exists \n    assert os.path.isfile(filename) | (not bool(filename)), f'Cannot find {filename}...'\n    self.filename = filename\n    self._updatefromfilename() # update filename information\n    self._setgroup() \n    self._setgpath()\n    if read: self.read()\n</code></pre>"},{"location":"api/class/#pyfaceimage.im.image.adjust","title":"<code>adjust(lum=None, rms=None, mask=None)</code>","text":"<p>Adjust the luminance and contrast of the image.</p> <p>Parameters:</p> Name Type Description Default <code>lum</code> <code>float</code> <p>the desired mean of the image. Defaults to None.</p> <code>None</code> <code>rms</code> <code>float</code> <p>the desired standard deviation of the image. Defaults to None.</p> <code>None</code> <code>mask</code> <code>array</code> <p>the mask for the image. Defaults to None.</p> <code>None</code> Source code in <code>pyfaceimage/im.py</code> <pre><code>def adjust(self, lum=None, rms=None, mask=None):\n    \"\"\"Adjust the luminance and contrast of the image.\n\n    Parameters\n    ----------\n    lum : float, optional\n        the desired mean of the image. Defaults to None.\n    rms : float, optional\n        the desired standard deviation of the image. Defaults to None.\n    mask : np.array, optional\n        the mask for the image. Defaults to None.\n    \"\"\"\n    # adjust the luminance (mean) or/and contrast (standard deviations) of the gray-scaled image. Default is do nothing.\n\n    # default for mask\n    if self.nchan in (2,4):\n        alpha = self.mat[...,-1]\n        isalpha = True\n    else:\n        alpha = np.ones((self.h, self.w))*255\n        isalpha = False\n    if mask is None:\n        mask = (alpha/255).astype(dtype=bool)\n\n    # force the image to be gray-scaled\n    self.grayscale()\n    ratio = self.mat/255\n    logodds = self._logit(ratio)\n\n    # in ratio\n    rmsratio = np.std(ratio[mask]-np.mean(ratio[mask]))\n\n    # in log odds\n    meanlo = np.mean(logodds[mask])\n    stdlo = np.std(logodds[mask]-meanlo)\n\n    if lum is not None:\n        lumlo = self._logit(lum)\n    else:\n        lumlo = meanlo\n\n    if rms is not None:\n        rmslo = rms * stdlo / rmsratio\n    else:\n        rmslo = stdlo\n\n    newlo = logodds\n    # apply the new luminance (in logodds)\n    newlo[mask] = (logodds[mask] - meanlo)/stdlo * rmslo + lumlo\n    newmat = self._sigmoid(newlo)\n\n    if isalpha:\n        newmat = np.concatenate((newmat[...,np.newaxis], alpha[...,np.newaxis]), axis=2)\n\n    self.remat(newmat.astype(dtype=np.uint8))\n</code></pre>"},{"location":"api/class/#pyfaceimage.im.image.cropoval","title":"<code>cropoval(radius=(100, 128), bgcolor=None)</code>","text":"<p>Crop the image with an oval shape.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>tuple</code> <p>the radius of the oval. Defaults to (100,128).</p> <code>(100, 128)</code> <code>bgcolor</code> <code>tuple</code> <p>the background color. Defaults to None.</p> <code>None</code> Source code in <code>pyfaceimage/im.py</code> <pre><code>def cropoval(self, radius=(100,128), bgcolor=None):\n    \"\"\"Crop the image with an oval shape.\n\n    Parameters\n    ----------\n    radius : tuple, optional\n        the radius of the oval. Defaults to (100,128).\n    bgcolor : tuple, optional\n        the background color. Defaults to None.\n    \"\"\"\n\n    # for instance, if bgcolor is (255, 255, 255, 255), the output image is not transparent; if bgcolor is (255, 255, 255, 0), the output image is transparent\n\n    # to make circle\n    if type(radius) is not tuple:\n        radius = (radius, radius) # a and b in ellipse formula\n    bbox = (self.w/2-radius[0], self.h/2-radius[1], self.w/2+radius[0], self.h/2+radius[1])\n\n    # make a ellipse/oval mask\n    pil_a = Image.new(\"L\", self.pil.size, 0)\n    draw = ImageDraw.Draw(pil_a)\n    draw.ellipse(bbox, fill=255)\n\n    if bgcolor is not None:\n        if type(bgcolor) is not tuple:\n            bgcolor = ((bgcolor),)*len(self.pil.mode)\n        pil_2 = Image.new(self.pil.mode, self.pil.size, bgcolor)\n        draw = ImageDraw.Draw(pil_2)\n        draw.ellipse(bbox, fill=255)\n        self.pil = Image.composite(self.pil, pil_2, pil_a)\n    else:\n        # only apply cropping to the alpha channel\n        self.pil.putalpha(pil_a)\n    # update to pil        \n    self._repil(self.pil)\n    # crop the rectangle\n    self.croprect(bbox)\n</code></pre>"},{"location":"api/class/#pyfaceimage.im.image.croprect","title":"<code>croprect(box=None)</code>","text":"<p>Crop the image with a rectangle box.</p> <p>Parameters:</p> Name Type Description Default <code>box</code> <code>tuple</code> <p>the box to crop the image. Defaults to None.</p> <code>None</code> Source code in <code>pyfaceimage/im.py</code> <pre><code>def croprect(self, box=None):\n    \"\"\"Crop the image with a rectangle box.\n\n    Parameters\n    ----------\n    box : tuple, optional\n        the box to crop the image. Defaults to None.\n    \"\"\"\n    # crop the image with a rectangle box\n    self._repil(self.pil.crop(box))\n</code></pre>"},{"location":"api/class/#pyfaceimage.im.image.deepcopy","title":"<code>deepcopy()</code>","text":"<p>make a deep copy of the instance</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>def deepcopy(self):\n    \"\"\"make a deep copy of the instance\n    \"\"\"\n    return copy.deepcopy(self)\n</code></pre>"},{"location":"api/class/#pyfaceimage.im.image.grayscale","title":"<code>grayscale()</code>","text":"<p>Convert the image to gray-scale.</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>def grayscale(self):\n    \"\"\"Convert the image to gray-scale.\n    \"\"\"\n    # convert image to gray-scale\n    self._repil(ImageOps.grayscale(self.pil))\n</code></pre>"},{"location":"api/class/#pyfaceimage.im.image.imsave","title":"<code>imsave(newfname='', newfolder='', addfn=True, **kwargs)</code>","text":"<p>Save the image mat.</p> <p>Parameters:</p> Name Type Description Default <code>newfname</code> <code>str</code> <p>strings to be added before the extension, by default ''</p> <code>''</code> <code>newfolder</code> <code>str</code> <p>folder name to replace the global directory or the last directory level, by default ''</p> <code>''</code> <code>addfn</code> <code>bool</code> <p>whether to add the newfname to the the original fname (instead of replacing it), by default True</p> <code>True</code> <code>kwargs</code> <code>dict</code> <p>keyword arguments for matplotlib.pyplot.imsave(), by default {}</p> <code>{}</code> Source code in <code>pyfaceimage/im.py</code> <pre><code>def imsave(self, newfname='', newfolder='', addfn=True, **kwargs):\n    \"\"\"Save the image mat.\n\n    Parameters\n    ----------\n    newfname : str, optional\n        strings to be added before the extension, by default ''\n    newfolder : str, optional\n        folder name to replace the global directory or the last directory level, by default ''\n    addfn : bool, optional\n        whether to add the newfname to the the original fname (instead of replacing it), by default True\n    kwargs : dict, optional\n        keyword arguments for matplotlib.pyplot.imsave(), by default {}\n    \"\"\"\n    # update the filename\n    self._newfilename(newfname, newfolder, addfn=addfn)\n\n    # make dir(s)\n    if not os.path.isdir(os.path.dirname(self.filename)):\n        os.makedirs(os.path.dirname(self.filename))\n    if self.nchan==1:\n        outmat = self.mat[:,:,0]\n    else:\n        outmat = self.mat\n\n    # use matplotlib.pyplot.imsave() to save .mat\n    mpimg.imsave(self.filename,outmat.copy(order='C'),**kwargs)\n    self.isfile = os.path.isfile(self.filename)\n</code></pre>"},{"location":"api/class/#pyfaceimage.im.image.imshow","title":"<code>imshow()</code>","text":"<p>Show the image matrix.</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>def imshow(self):\n    \"\"\"Show the image matrix.\n    \"\"\"\n    # for debugging purpose (check the mat)\n    # it seems that .show() is more useful\n    Image.fromarray(self.mat).show()\n</code></pre>"},{"location":"api/class/#pyfaceimage.im.image.mkboxscr","title":"<code>mkboxscr(**kwargs)</code>","text":"<p>Make box scrambled stimuli.</p> <p>Other Parameters:</p> Name Type Description <code>nBoxW</code> <code>int</code> <p>the number of boxes in width. Defaults to 10.</p> <code>nBoxH</code> <code>int</code> <p>the number of boxes in height. Defaults to 16.</p> <code>pBoxW</code> <code>int</code> <p>the width of a box. Defaults to 0.</p> <code>pBoxH</code> <code>int</code> <p>the height of a box. Defaults to 0.</p> <code>pad</code> <code>bool</code> <p>whether to add padding to the image. Defaults to False.</p> <code>padcolor</code> <code>int</code> <p>the padding color. Defaults to 0.</p> <code>padalpha</code> <code>int</code> <p>the padding alpha. Defaults to -1.</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>def mkboxscr(self, **kwargs):\n    \"\"\"Make box scrambled stimuli.\n\n    Other Parameters\n    ----------------\n    nBoxW : int\n        the number of boxes in width. Defaults to 10.\n    nBoxH : int\n        the number of boxes in height. Defaults to 16.\n    pBoxW : int\n        the width of a box. Defaults to 0.\n    pBoxH : int\n        the height of a box. Defaults to 0.\n    pad : bool\n        whether to add padding to the image. Defaults to False.\n    padcolor : int\n        the padding color. Defaults to 0.\n    padalpha : int\n        the padding alpha. Defaults to -1.\n    \"\"\"\n    defaultKwargs = {'nBoxW':10, 'nBoxH':16, \n                 'pBoxW':0, 'pBoxH':0, \n                 'pad': False, 'padcolor':0, 'padalpha': -1}\n    kwargs = {**defaultKwargs, **kwargs}\n\n    if (kwargs['pBoxW']!=0) &amp; (kwargs['pBoxH']!=0):\n\n        _nBoxW = self.w/kwargs['pBoxW']\n        _nBoxH = self.h/kwargs['pBoxH']\n\n        if not ((_nBoxW.is_integer()) &amp; (_nBoxH.is_integer())):\n            assert kwargs['pad'], 'Please input valid pBoxW and pBoxH. Or set \"pad\" to True.'\n\n            # add complementary parts to top and right\n            xnew = int(np.ceil(_nBoxW) * kwargs['pBoxW'])\n            ynew = int(np.ceil(_nBoxH) * kwargs['pBoxH'])\n\n            self.pad(trgw=xnew, trgh=ynew, padvalue=kwargs['padcolor'], padalpha=kwargs['padalpha'])\n\n        kwargs['nBoxW'] = int(self.w/kwargs['pBoxW'])\n        kwargs['nBoxH'] = int(self.h/kwargs['pBoxH'])\n\n    elif (kwargs['nBoxW']!=0) &amp; (kwargs['nBoxH']!=0):\n\n        # x and y pixels for each box\n        _pBoxW = self.w/kwargs['nBoxW']\n        _pBoxH = self.h/kwargs['nBoxH']\n\n        if not ((_pBoxW.is_integer()) &amp; (_pBoxH.is_integer())):\n            assert kwargs['pad'], 'Please input valid nBoxW and nBoxH. Or set \"pad\" to True.'\n\n            # add padding (top, right, bottom, left)\n            newW = int(np.ceil(_pBoxW) * kwargs['nBoxW'])\n            newY = int(np.ceil(_pBoxH) * kwargs['nBoxH'])\n            self.pad(trgw=newW, trgh=newY, padvalue=kwargs['padcolor'], padalpha=kwargs['padalpha'])\n\n        kwargs['pBoxW'] = int(self.w/kwargs['nBoxW'])\n        kwargs['pBoxH'] = int(self.h/kwargs['nBoxH'])\n    else:\n        raise 'Please set valid nBoxW and nBoxH (or pBoxW and pBoxH).'\n\n    assert kwargs['nBoxW']*kwargs['pBoxW']==self.w, f\"'nBoxW': {kwargs['nBoxW']}   'pBoxW': {kwargs['pBoxW']}    'self.w': {self.w}\"\n    assert kwargs['nBoxH']*kwargs['pBoxH']==self.h, f\"'nBoxH': {kwargs['nBoxH']}   'pBoxH': {kwargs['pBoxH']}    'self.h': {self.h}\"\n\n    # x and y for all boxes\n    xys = list(product(range(0,self.w,kwargs['pBoxW']), range(0,self.h,kwargs['pBoxH'])))\n    boxes = [self.mat[i[1]:(i[1]+kwargs['pBoxH']), i[0]:(i[0]+kwargs['pBoxW'])] for i in xys]\n    # randomize the boxes\n    bsboxes = np.random.permutation(boxes)\n    # save as np.array\n    bslist = [bsboxes[i:i+kwargs['nBoxW']] for i in range(0,len(bsboxes),kwargs['nBoxW'])]\n    # bsmat = np.moveaxis(np.asarray(bslist), [-1, 1], [0, -2]).reshape(-1, y, x)\n    bsmatm = np.asarray(bslist)\n    if len(bsmatm.shape)==4:\n        bsmatm = bsmatm[..., np.newaxis]\n    bsmat = np.moveaxis(bsmatm, [-1, 1], [0, -2]).reshape(-1, self.h, self.w)\n\n    # save box-scrambled images (and information)\n    self.remat(np.squeeze(np.moveaxis(bsmat,0,2)))\n    self._newfilename(newfname='_bscr')\n</code></pre>"},{"location":"api/class/#pyfaceimage.im.image.mkphasescr","title":"<code>mkphasescr(**kwargs)</code>","text":"<p>Make phase scrambled stimuli.</p> <p>Other Parameters:</p> Name Type Description <code>rms</code> <code>float</code> <p>the desired RMS of the image. Defaults to 0.3.</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>def mkphasescr(self, **kwargs):\n    \"\"\"Make phase scrambled stimuli.\n\n    Other Parameters\n    ----------------\n    rms : float\n        the desired RMS of the image. Defaults to 0.3.\n    \"\"\"\n    defaultKwargs = {'rms':0.3}\n    kwargs = {**defaultKwargs, **kwargs}\n\n    # make a random phase\n    randphase = np.angle(np.fft.fft2(np.random.rand(self.h, self.w)))\n\n    if self.nchan==0:\n        nchan = 1\n        mat = self.mat[..., np.newaxis] # add one more axis\n    else:\n        nchan = self.nchan\n        mat = self.mat\n\n    outmat = np.empty(mat.shape)\n    outmat[:] = np.NaN\n\n    for i in range(nchan):\n        img_freq = np.fft.fft2(self._stdim(mat[:,:,i], kwargs['rms']))\n        amp = np.abs(img_freq)\n        phase = np.angle(img_freq) + randphase\n        outimg = np.real(np.fft.ifft2(amp * np.exp(np.sqrt(-1+0j)*phase)))\n        stdimg1= self._stdim(outimg, kwargs['rms'])\n        outmat[:,:,i] = (stdimg1+1)/2*255\n\n    if self.nchan==0:\n        outmat = outmat[:,:,0]\n\n    self.remat(np.uint8(outmat))\n    self._newfilename(newfname='_pscr')\n</code></pre>"},{"location":"api/class/#pyfaceimage.im.image.pad","title":"<code>pad(**kwargs)</code>","text":"<p>Add padding to the image/stimuli.</p> <p>Other Parameters:</p> Name Type Description <code>trgw</code> <code>int</code> <p>the width of the target/desired stimuli.</p> <code>trgh</code> <code>int</code> <p>the height of the target/desired stimuli.</p> <code>padvalue</code> <code>int</code> <p>padding value. Defaults to 0 (show as transparent if alpha channel exists).</p> <code>top</code> <code>bool</code> <p>padding more to top if needed. Defaults to True.</p> <code>left</code> <code>bool</code> <p>padding more to left if needed. Defaults to True.</p> <code>padalpha</code> <code>int</code> <p>the transparent color. Defaults to -1, i.e., not to force it to transparent.</p> <code>extrafn</code> <code>str</code> <p>the string to be added to the filename. Defaults to '_pad'.</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>def pad(self, **kwargs):  \n    \"\"\"\n    Add padding to the image/stimuli.\n\n    Other Parameters\n    ----------------\n    trgw : int\n        the width of the target/desired stimuli. \n    trgh : int\n        the height of the target/desired stimuli.\n    padvalue : int\n        padding value. Defaults to 0 (show as transparent if alpha channel exists).\n    top : bool\n        padding more to top if needed. Defaults to True.\n    left : bool \n        padding more to left if needed. Defaults to True.\n    padalpha : int\n        the transparent color. Defaults to -1, i.e., not to force it to transparent.\n    extrafn : str\n        the string to be added to the filename. Defaults to '_pad'.\n    \"\"\"\n\n    defaultKwargs = {'trgw':self.w, 'trgh':self.h, 'padvalue': 0, 'top': True, 'left':True, 'padalpha':-1, 'extrafn':'_pad'}\n    kwargs = {**defaultKwargs, **kwargs}\n\n    trgw,trgh = kwargs['trgw'], kwargs['trgh']\n\n    assert(trgw&gt;=self.w)\n    assert(trgh&gt;=self.h)\n\n    x1 = int(np.ceil(trgw-self.w)/2)\n    x2 = trgw-self.w-x1\n    y1 = int(np.ceil(trgh-self.h)/2)\n    y2 = trgh-self.h-y1\n\n    if kwargs['top']:\n        htop, hbot = y1,y2\n    else:\n        htop, hbot = y2,y1\n    if kwargs['left']:\n        wleft, wright = x1,x2\n    else:\n        wleft, wright = x2,x1\n\n    if self.nchan==0:\n        nchan = 1\n        mat = self.mat[..., np.newaxis] # add one more axis\n    else:\n        nchan = self.nchan\n        mat = self.mat\n\n    if (kwargs['padalpha']&gt;=0) &amp; (nchan==1 | nchan==3):\n        mat = np.concatenate((mat, np.ones((self.h, self.w, 1), dtype=np.uint8)*kwargs['padalpha']),axis=2)\n        nchan = nchan + 1\n\n    padmat = np.hstack((\n        np.ones((trgh,wleft,nchan),dtype=np.uint8)*kwargs['padvalue'], \n        np.vstack((\n            np.ones((htop,self.w,nchan),dtype=np.uint8)*kwargs['padvalue'], \n            mat,\n            np.ones((hbot,self.w,nchan),dtype=np.uint8)*kwargs['padvalue']\n        )),\n        np.ones((trgh,wright,nchan),dtype=np.uint8)*kwargs['padvalue'], \n    ))\n\n    if (self.nchan==0) &amp; (kwargs['padalpha']&lt;0):\n        padmat = padmat[:,:,0]\n\n    self.remat(padmat)\n    if kwargs['extrafn']!='':\n        self._newfilename(newfname=kwargs['extrafn'])\n</code></pre>"},{"location":"api/class/#pyfaceimage.im.image.read","title":"<code>read()</code>","text":"<p>Read the image via PIL.</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>def read(self):\n    \"\"\"Read the image via PIL.\n    \"\"\"\n    self._repil(Image.open(self.filename)) # PIL.Image.open() \n</code></pre>"},{"location":"api/class/#pyfaceimage.im.image.resize","title":"<code>resize(**kwargs)</code>","text":"<p>Resize the image.</p> <p>Other Parameters:</p> Name Type Description <code>trgw</code> <code>int</code> <p>the width of the target/desired stimuli.</p> <code>trgh</code> <code>int</code> <p>the height of the target/desired stimuli.</p> <code>ratio</code> <code>float</code> <p>the ratio to resize the image. Defaults to 0.</p> <code>newfolder</code> <code>str</code> <p>the folder to save the resized image. Defaults to None.</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>def resize(self, **kwargs):\n    \"\"\"Resize the image.\n\n    Other Parameters\n    ----------------\n    trgw : int\n        the width of the target/desired stimuli.\n    trgh : int\n        the height of the target/desired stimuli.\n    ratio : float\n        the ratio to resize the image. Defaults to 0.\n    newfolder : str\n        the folder to save the resized image. Defaults to None.\n    \"\"\"\n    # resize the image\n    defaultKwargs = {'trgw': None, 'trgh': None, 'ratio':0, 'newfolder':None}\n    kwargs = {**defaultKwargs, **kwargs}\n\n    if (kwargs['trgw'] is not None) &amp; (kwargs['trgh'] is not None):\n        (w, h) = (kwargs['trgw'], kwargs['trgh'])\n    elif (kwargs['trgw'] is not None) &amp; (kwargs['trgh'] is None):\n        w = kwargs['trgw']\n        h = int(w*self.h/self.w)\n    elif (kwargs['trgw'] is None) &amp; (kwargs['trgh'] is not None): \n        h = kwargs['trgh']\n        w = int(h*self.w/self.h)\n    elif kwargs['ratio']&gt;0:\n        w = int(self.w*kwargs['ratio'])\n        h = int(self.h*kwargs['ratio'])\n    else:\n        raise 'Cannot determine the desired dimentions...'\n\n    kwargs['size'] = (w,h)\n    if (kwargs['newfolder'] is None):\n        newfolder = str(w)+'_'+str(h)\n    else:\n        newfolder = kwargs['newfolder']\n\n    [kwargs.pop(k) for k in defaultKwargs.keys()] # remove unused keys\n\n    # save re-sized images (information)\n    self._repil(self.pil.resize(**kwargs))\n    self._newfilename(newfolder=newfolder)\n</code></pre>"},{"location":"api/class/#pyfaceimage.im.image.rotate","title":"<code>rotate(angle=180)</code>","text":"<p>Rotate the image unclockwise.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>the angle to rotate the image. Defaults to 180.</p> <code>180</code> Source code in <code>pyfaceimage/im.py</code> <pre><code>def rotate(self, angle=180):\n    \"\"\"Rotate the image unclockwise.\n\n    Parameters\n    ----------\n    angle : float\n        the angle to rotate the image. Defaults to 180.\n    \"\"\"\n    # rotate the image\n    self._repil(self.pil.rotate(angle))\n</code></pre>"},{"location":"api/class/#pyfaceimage.im.image.save","title":"<code>save(newfname='', newfolder='', addfn=True, **kwargs)</code>","text":"<p>Save the image PIL.</p> <p>Parameters:</p> Name Type Description Default <code>newfname</code> <code>str</code> <p>strings to be added before the extension, by default ''</p> <code>''</code> <code>newfolder</code> <code>str</code> <p>folder name to replace the global directory or the last directory level, by default ''</p> <code>''</code> <code>addfn</code> <code>bool</code> <p>whether to add the newfname to the the original fname (instead of replacing it), by default True</p> <code>True</code> <code>kwargs</code> <code>dict</code> <p>keyword arguments for matplotlib.pyplot.imsave(), by default {}</p> <code>{}</code> Source code in <code>pyfaceimage/im.py</code> <pre><code>def save(self, newfname='', newfolder='', addfn=True, **kwargs):\n    \"\"\"Save the image PIL.\n\n    Parameters\n    ----------\n    newfname : str, optional\n        strings to be added before the extension, by default ''\n    newfolder : str, optional\n        folder name to replace the global directory or the last directory level, by default ''\n    addfn : bool, optional\n        whether to add the newfname to the the original fname (instead of replacing it), by default True\n    kwargs : dict, optional\n        keyword arguments for matplotlib.pyplot.imsave(), by default {}\n    \"\"\"\n    # update the filename\n    self._newfilename(newfname, newfolder, addfn=addfn)\n\n    # make dir(s)\n    if not os.path.isdir(os.path.dirname(self.filename)):\n        os.makedirs(os.path.dirname(self.filename))\n\n    # use PIL.Image.save() to save .pil    \n    self.pil.save(self.filename, format=None, **kwargs)\n    self.isfile = os.path.isfile(self.filename)\n</code></pre>"},{"location":"api/class/#pyfaceimage.im.image.sffilter","title":"<code>sffilter(**kwargs)</code>","text":"<p>Apply spatial frequency filter to the image.</p> <p>Other Parameters:</p> Name Type Description <code>rms</code> <code>float</code> <p>the desired RMS of the image. Defaults to 0.3.</p> <code>maxvalue</code> <code>int</code> <p>the maximum value of the image. Defaults to 255.</p> <code>sffilter</code> <code>str</code> <p>the spatial frequency filter. Defaults to 'low'.</p> <code>cutoff</code> <code>float</code> <p>the cutoff frequency. Defaults to 0.05.</p> <code>n</code> <code>int</code> <p>the order of the filter. Defaults to 10.</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>def sffilter(self, **kwargs):\n    \"\"\"Apply spatial frequency filter to the image.\n\n    Other Parameters\n    ----------------\n    rms : float\n        the desired RMS of the image. Defaults to 0.3.\n    maxvalue : int\n        the maximum value of the image. Defaults to 255.\n    sffilter : str\n        the spatial frequency filter. Defaults to 'low'.\n    cutoff : float\n        the cutoff frequency. Defaults to 0.05.\n    n : int\n        the order of the filter. Defaults to 10.\n    \"\"\"\n    # https://www.djmannion.net/psych_programming/vision/sf_filt/sf_filt.html\n    import psychopy.filters\n\n    defaultKwargs = {'rms':0.3, 'maxvalue':255, 'sffilter':'low',\n                     'cutoff': 0.05, 'n': 10}\n    kwargs = {**defaultKwargs, **kwargs}\n\n    self.grayscale()\n    stdmat = self._stdim(self.mat, kwargs['rms'])\n    img_freq = np.fft.fft2(stdmat)\n\n    # calculate amplitude spectrum\n    # img_amp = np.fft.fftshift(np.abs(img_freq))\n\n    # # for display, take the logarithm\n    # img_amp_disp = np.log(img_amp + 0.0001)\n\n    # # rescale to -1:+1 for display\n    # img_amp_disp = (\n    #     ((img_amp_disp - np.min(img_amp_disp)) * 2) / \n    #     np.ptp(img_amp_disp)  # 'ptp' = range\n    # ) - 1\n\n    if kwargs['sffilter']=='low':\n        # for generating blury images\n        fsfilt = psychopy.filters.butter2d_lp(\n            size=(self.w, self.h),\n            cutoff=kwargs['cutoff'],\n            n=kwargs['n']\n        )\n    elif kwargs['sffilter']=='high':      \n         # for gernerating sharp images\n        fsfilt = psychopy.filters.butter2d_hp(\n            size=(self.w, self.h),\n            cutoff=kwargs['cutoff'],\n            n=kwargs['n']\n        )\n    else:\n        raise 'Cannot identify the \"sffilter\" value...'\n\n    img_filt = np.fft.fftshift(img_freq) * fsfilt.transpose()\n    # convert back to an image\n    img_new = np.real(np.fft.ifft2(np.fft.ifftshift(img_filt)))\n    # standardize the image to [-1, 1]\n    img_new = self._stdim(img_new, kwargs['rms'])\n    # convert the range to [0, 255]\n    img_new = (img_new+1)/2*kwargs['maxvalue']\n    self.remat(img_new)\n    self._newfilename(newfname='_'+kwargs['sffilter']+'_filtered')\n</code></pre>"},{"location":"api/class/#pyfaceimage.im.image.show","title":"<code>show()</code>","text":"<p>Show the image PIL.</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>def show(self):\n    \"\"\"Show the image PIL.\n    \"\"\"\n    # for debugging purpose (check the PIL)\n    self.pil.show()\n</code></pre>"},{"location":"api/class/#pyfaceimage.im.image.torgba","title":"<code>torgba()</code>","text":"<p>Convert the image to RGBA.</p> Source code in <code>pyfaceimage/im.py</code> <pre><code>def torgba(self):\n    \"\"\"Convert the image to RGBA.\n    \"\"\"\n    # convert pil to RGBA and save in .mat\n    if len(self.mat.shape)==2: # Gray\n        self.mat = self.mat[..., np.newaxis]\n    assert len(self.mat.shape)==3\n\n    nchan = self.mat.shape[2]\n    if nchan==1: # Gray 'L'\n        rgbmat = np.repeat(self.mat, 3, axis=2) # RGB\n        amat = np.ones_like(rgbmat[:,:,0],dtype=np.uint8)*rgbmat.max() # alpha\n    elif nchan==2: # Gray 'LA'\n        rgbmat = np.repeat(self.mat[:,:,0:1], 3, axis=2) # RGB\n        amat = self.mat[:,:,-1] # alpha\n    elif nchan==3: # RGB\n        rgbmat = self.mat # RGB\n        amat = np.ones_like(rgbmat[:,:,0],dtype=np.uint8)*rgbmat.max() # alpha\n    elif nchan==4: # RGBA\n        rgbmat = self.mat[:,:,0:3]\n        amat = self.mat[:,:,-1]\n\n    self.rgbmat = rgbmat\n    self.amat = amat\n    self.mat = np.concatenate((rgbmat, amat[..., np.newaxis]), axis=2) # RGBA\n    self.remat(self.mat)\n</code></pre>"},{"location":"api/class/#pyfaceimage.im.image.touch","title":"<code>touch(touchfolder='')</code>","text":"<p>Touch a new empty file.</p> <p>Parameters:</p> Name Type Description Default <code>touchfolder</code> <code>str</code> <p>folder name to replace the global directory or the last directory level, by default ''</p> <code>''</code> Source code in <code>pyfaceimage/im.py</code> <pre><code>def touch(self, touchfolder=''):\n    \"\"\"Touch a new empty file.\n\n    Parameters\n    ----------\n    touchfolder : str, optional\n        folder name to replace the global directory or the last directory level, by default ''\n    \"\"\"\n    # update the directory\n    self._newfilename(newfolder=touchfolder)\n\n    if self.isfile:\n        # throw warnings if file exists\n        warnings.warn(\"The file named '%s' already exists...\" % self.filename)\n    else:\n        # make dir if needed\n        if not os.path.isdir(self.dirname):\n            os.makedirs(self.dirname)\n        # touch the file\n        Path(self.filename).touch()\n</code></pre>"},{"location":"api/class/#pyfaceimage.im.image.updateext","title":"<code>updateext(ext)</code>","text":"<p>Update the filename information.</p> <p>Parameters:</p> Name Type Description Default <code>ext</code> <code>str</code> <p>the new extension.</p> required Source code in <code>pyfaceimage/im.py</code> <pre><code>def updateext(self, ext):\n    \"\"\"Update the filename information.\n\n    Parameters\n    ----------\n    ext : str\n        the new extension.\n    \"\"\"\n    if ext[0] != '.':\n        ext = '.'+ext\n    self.filename = self.dirname + os.sep + self.fnonly + ext\n    self._updatefromfilename()\n</code></pre>"},{"location":"api/function/","title":"function","text":"<p>Auto-generate API documentation using <code>mkdocstrings</code>. Add the following content:</p>"},{"location":"api/function/#api-reference","title":"API Reference","text":"<p>Functions to play with multiple (more than one) images.</p>"},{"location":"api/function/#pyfaceimage.multim.composite","title":"<code>composite(im_back, im_fore)</code>","text":"<p>Paste im_fore to im_back. im_back should not be smaller than im_fore.</p> <p>Parameters:</p> Name Type Description Default <code>im_back</code> <code>im.image() instance</code> <p>the background image.</p> required <code>im_fore</code> <code>im.image() instance</code> <p>the foreground image.</p> required <p>Returns:</p> Type Description <code>im.image() instance</code> <p>the final image.</p> Source code in <code>pyfaceimage/multim.py</code> <pre><code>def composite(im_back, im_fore):\n    \"\"\"Paste im_fore to im_back. im_back should not be smaller than im_fore.\n\n    Parameters\n    ----------\n    im_back : im.image() instance\n        the background image.\n    im_fore : im.image() instance\n        the foreground image.\n\n    Returns\n    -------\n    im.image() instance\n        the final image.\n    \"\"\"\n\n    # im_back should not be smaller than im_fore\n    assert im_back.w&gt;=im_fore.w and im_back.h&gt;=im_fore.h, f'im_back (({im_back.w, im_back.h})) should not be smaller than im_fore (({im_fore.w, im_fore.h})) .'\n\n    # pad im_fore if necessary\n    if im_back.w&gt;=im_fore.w or im_back.h&gt;=im_fore.h: \n        im_fore.pad(trgw=im_back.w, trgh=im_back.h)\n\n    # paste im_fore to im_back\n    im_back.pil.paste(im_fore.pil, mask=im_fore.pil)\n    im_back._repil(im_back.pil)\n\n    return im_back\n</code></pre>"},{"location":"api/function/#pyfaceimage.multim.concatenate","title":"<code>concatenate(im1, im2, axis=1, sep='-', padval=0)</code>","text":"<p>Concatenate two images along the specified axis.</p> <p>Parameters:</p> Name Type Description Default <code>im1</code> <code>im.image() instance</code> <p>the first image.</p> required <code>im2</code> <code>im.image() instance</code> <p>the second image.</p> required <p>Other Parameters:</p> Name Type Description <code>axis</code> <code>int</code> <p>the axis along which the images are concatenated. Defaults to 1, i.e. horizontally.</p> <code>sep</code> <code>str</code> <p>the separator between the two images. Defaults to \"-\".</p> <code>padval</code> <code>int</code> <p>the value to pad the images. Defaults to 0.</p> <p>Returns:</p> Type Description <code>im.image() instance</code> <p>the concatenated image.</p> Source code in <code>pyfaceimage/multim.py</code> <pre><code>def concatenate(im1, im2, axis=1, sep=\"-\", padval=0):\n    \"\"\"Concatenate two images along the specified axis.\n\n    Parameters\n    ----------\n    im1 : im.image() instance\n        the first image.\n    im2 : im.image() instance\n        the second image.\n\n    Other Parameters\n    ----------------\n    axis : int\n        the axis along which the images are concatenated. Defaults to 1, i.e. horizontally.\n    sep : str\n        the separator between the two images. Defaults to \"-\".\n    padval : int\n        the value to pad the images. Defaults to 0.\n\n    Returns\n    -------\n    im.image() instance\n        the concatenated image.\n    \"\"\"\n\n    im = im1.deepcopy()\n\n    # pad the images if necessary\n    if axis==0:\n        if im.w&gt;im2.w:\n            im2.pad(trgw=im.w, padval=padval)\n        elif im.w&lt;im2.w:\n            im.pad(trgw=im2.w, padval=padval)\n    elif axis==1:\n        if im.h&gt;im2.h:\n            im2.pad(trgh=im.h, padval=padval)\n        elif im.h&lt;im2.h:\n            im.pad(trgh=im2.h, padval=padval)\n\n    # concatenate the images\n    if axis==0:\n        im.pil = Image.fromarray(np.concatenate((im.pil, im2.pil), axis=0))\n    elif axis==1:\n        im.pil = Image.fromarray(np.concatenate((im.pil, im2.pil), axis=1))\n    im._repil(im.pil)\n\n    # update the filename\n    newfilename = im.fnonly+sep+im2.fnonly\n    im._newfilename(newfname=newfilename, addfn=False)\n\n    return (im, newfilename)\n</code></pre>"},{"location":"api/function/#pyfaceimage.multim.mkcf","title":"<code>mkcf(im1, im2, **kwargs)</code>","text":"<p>Make composite faces (for the composite face task) with im1 and im2.</p> <p>Parameters:</p> Name Type Description Default <code>im1</code> <code>im.image() instance</code> <p>one im.image() instane for creating composite faces.</p> required <code>im2</code> <code>im.image() instance</code> <p>another im.image() instane for creating composite faces.</p> required <p>Other Parameters:</p> Name Type Description <code>misali</code> <code>(int, num)</code> <p>misalignment. Positive int will shift to the right and negative int will shift to the left. If misali is int, it refers to pixels. If misali is decimal, it misali*face width is the amount of misalignment. Defaults to 0.</p> <code>topis1</code> <code>bool</code> <p>whether im1 (or im2) is used as the top of the composite face. Defaults to True.</p> <code>cueistop</code> <code>bool</code> <p>whether the top half is cued. Defaults to True.</p> <code>lineh</code> <code>int</code> <p>the height (in pixels) of the line between the top and bottom facial havles. Defaults to 3.</p> <code>width_cf</code> <code>int</code> <p>the width of the composite face/the line (also the width of the output composite face image). Defaults to three times of the face width.</p> <code>lineclr</code> <code>int tuple</code> <p>the color of the line. Defaults to (255,255,255), i.e., white.</p> <code>showcue</code> <code>bool</code> <p>whether to display cue in the image. Defaults to False.</p> <code>cueclr</code> <code>int tuple</code> <p>the color of the cue. Defaults to the same as lineclr.</p> <code>cuethick</code> <code>int</code> <p>the thickness (in pixels) of the cue. Defaults to 4.</p> <code>cuew</code> <code>int</code> <p>the width (in pixels) of the cue. Defaults to 110% of the face width.</p> <code>cueh</code> <code>int</code> <p>the height (in pixels) of the very left and right parts of the cue. Defaults to about 5% of the face height.</p> <code>cuedist</code> <code>int</code> <p>distance from the main part of the cue to edge of the face. Defaults to twice of cueh.</p> <p>Returns:</p> Name Type Description <code>im.image() instance</code> <p>the composite face stimuli as a im.image() instance.</p> <code>fn_cf</code> <code>str</code> <p>the filename of the composite face stimuli.</p> Source code in <code>pyfaceimage/multim.py</code> <pre><code>def mkcf(im1, im2, **kwargs):\n    \"\"\"Make composite faces (for the composite face task) with im1 and im2.\n\n    Parameters\n    ----------\n    im1 : im.image() instance\n        one im.image() instane for creating composite faces.\n    im2 : im.image() instance\n        another im.image() instane for creating composite faces.\n\n    Other Parameters\n    ----------------\n    misali : int, num\n        misalignment. Positive int will shift to the right and negative int will shift to the left. If misali is int, it refers to pixels. If misali is decimal, it misali*face width is the amount of misalignment. Defaults to 0.\n    topis1 : bool\n        whether im1 (or im2) is used as the top of the composite face. Defaults to True.\n    cueistop : bool\n        whether the top half is cued. Defaults to True.\n    lineh : int\n        the height (in pixels) of the line between the top and bottom facial havles. Defaults to 3.\n    width_cf : int\n        the width of the composite face/the line (also the width of the output composite face image). Defaults to three times of the face width.\n    lineclr : int tuple\n        the color of the line. Defaults to (255,255,255), i.e., white.\n    showcue : bool\n        whether to display cue in the image. Defaults to False.\n    cueclr : int tuple\n        the color of the cue. Defaults to the same as lineclr.\n    cuethick : int\n        the thickness (in pixels) of the cue. Defaults to 4.\n    cuew : int\n        the width (in pixels) of the cue. Defaults to 110% of the face width.\n    cueh : int\n        the height (in pixels) of the very left and right parts of the cue. Defaults to about 5% of the face height.\n    cuedist : int\n        distance from the main part of the cue to edge of the face. Defaults to twice of cueh.\n\n    Returns\n    -------\n    im.image() instance\n        the composite face stimuli as a im.image() instance.\n    fn_cf : str\n        the filename of the composite face stimuli.\n    \"\"\"\n\n    defaultKwargs = {'misali':0, 'topis1': True, 'cueistop': True,\n                     'lineh':3, 'width_cf': im1.w*3, 'lineclr': None,\n                     'showcue':False, 'cueclr':None,\n                     'cuethick': 4, 'cuew': int(im1.w*1.1), 'cueh': int(im1.h*.05), 'cuedist': None}\n    kwargs = {**defaultKwargs, **kwargs}\n\n    # decide the width of the output CF image\n    w_cf = kwargs['width_cf']\n    if isinstance(kwargs['misali'], int):\n        misali = kwargs['misali']\n    else:\n        misali = int(kwargs['misali']*im1.w)\n    assert (misali+im1.w/2)&lt;=w_cf/2, f'Please make sure the width of the composite face ({w_cf}) is set appropriately to fit the misalignment ({misali}).'\n\n    # generate the default color for the (white) line\n    if kwargs['lineclr'] is None: \n        kwargs['lineclr'] = (255,) * im1.nchan # white line\n    else:\n        assert len(kwargs['lineclr'])==im1.nchan, f\"The lenght of 'lineclr' should match im1.nchan({im1.nchan})\"\n\n    if kwargs['cueclr'] is None: \n        kwargs['cueclr'] = kwargs['lineclr']\n    else:\n        assert len(kwargs['cueclr'])==im1.nchan, f\"The lenght of 'cueclr' should match im1.nchan({im1.nchan})\"\n\n    alistrs = ['ali', 'mis']\n    bboxes = [(0, 0, im1.w, im1.h/2), (0, im1.h/2, im1.w, im1.h)] # top, bottom\n    dests = [((w_cf-im1.w)//2+misali*(1-kwargs['cueistop']), 0), # top position\n             ((w_cf-im1.w)//2+misali*kwargs['cueistop'], im1.h//2+kwargs['lineh'])] # bottom position\n    fns_12 = [im1.fnonly, im2.fnonly]\n\n    fn_cf = os.path.join(fns_12[1-kwargs['topis1']]+'_'+fns_12[kwargs['topis1']]+'_'+alistrs[misali!=0])\n\n    # top and bottom pil\n    im1_half = im1.deepcopy()\n    im2_half = im2.deepcopy()\n    im1_half.croprect(bboxes[1-kwargs['topis1']])\n    im2_half.croprect(bboxes[kwargs['topis1']])\n\n    # create a new canvas and paste the image\n    dist_cf = Image.new(im1.pil.mode, (w_cf, im1.h+kwargs['lineh']))\n    # white line\n    drawl = ImageDraw.Draw(dist_cf)\n    drawl.rectangle((0,im1.h//2,w_cf,im1.h//2+kwargs['lineh']-1),fill=kwargs['lineclr'])\n    # top and bottom\n    dist_cf.paste(im1_half.pil, dests[1-kwargs['topis1']])\n    dist_cf.paste(im2_half.pil, dests[kwargs['topis1']])\n\n    if kwargs['showcue']:\n        if kwargs['cuedist'] is None:\n            kwargs['cuedist']= kwargs['cueh']*2\n        # cues\n        cue1 = Image.new(im1.pil.mode, (w_cf, kwargs['cuedist']))\n        cue2 = cue1.copy()\n        drawc = ImageDraw.Draw(cue1)\n        drawc.rectangle(((w_cf-kwargs['cuew'])//2,0,(w_cf+kwargs['cuew'])//2-1,kwargs['cuethick']-1),fill=kwargs['cueclr'])\n        drawc.rectangle(((w_cf-kwargs['cuew'])//2,kwargs['cuethick'],\n                        (w_cf-kwargs['cuew'])//2+kwargs['cuethick']-1,kwargs['cueh']+kwargs['cuethick']-1),\n                        fill=kwargs['cueclr'])\n        drawc.rectangle(((w_cf+kwargs['cuew'])//2-kwargs['cuethick'],kwargs['cuethick'],\n                        (w_cf+kwargs['cuew'])//2-1,kwargs['cueh']+kwargs['cuethick']-1),\n                        fill=kwargs['cueclr'])\n        cues = [cue1, cue2]\n\n        # concatenate CF and cues\n        dist = Image.new(im1.pil.mode, (w_cf, cue1.size[1]*2+dist_cf.size[1]))\n        dist.paste(cues[1-kwargs['cueistop']], (0, 0))\n        dist.paste(dist_cf, (0, cue1.size[1]))\n        dist.paste(ImageOps.flip(cues[kwargs['cueistop']]), (0, cue1.size[1]+dist_cf.size[1]))\n\n        # add the cue str to filename\n        fn_cf = fn_cf+'_'+['top', 'bot'][1-kwargs['cueistop']]\n\n    else:\n        dist = dist_cf\n\n    # update/save the cf image information\n    im_cf = im1.deepcopy()\n    im_cf._repil(dist)\n    im_cf._newfilename(newfname=fn_cf, addfn=False)\n\n    return im_cf, fn_cf\n</code></pre>"}]}